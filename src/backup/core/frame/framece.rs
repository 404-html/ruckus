/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> Hash for __BindgenUnionField<T> {
        fn hash<H: Hasher>(&self, _state: &mut H) {}
    }
    impl<T> PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> Eq for __BindgenUnionField<T> {}

    pub mod std {

        pub mod __cxx11 {

            pub type string = root::std::__cxx11::basic_string<::std::os::raw::c_char>;
            #[repr(C)]
            pub struct basic_string<_CharT> {
                pub _M_dataplus: root::std::__cxx11::basic_string__Alloc_hider,
                pub _M_string_length: root::std::__cxx11::basic_string_size_type,
                pub __bindgen_anon_1: root::std::__cxx11::basic_string__bindgen_ty_2<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_string__Char_alloc_type = [u8; 0usize];
            pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
            pub type basic_string_traits_type<_Traits> = _Traits;
            pub type basic_string_value_type = [u8; 0usize];
            pub type basic_string_allocator_type =
                root::std::__cxx11::basic_string__Char_alloc_type;
            pub type basic_string_size_type = [u8; 0usize];
            pub type basic_string_difference_type = [u8; 0usize];
            pub type basic_string_reference = [u8; 0usize];
            pub type basic_string_const_reference = [u8; 0usize];
            pub type basic_string_pointer = [u8; 0usize];
            pub type basic_string_const_pointer = [u8; 0usize];
            pub type basic_string_iterator =
                root::__gnu_cxx::__normal_iterator<root::std::__cxx11::basic_string_pointer>;
            pub type basic_string_const_iterator =
                root::__gnu_cxx::__normal_iterator<root::std::__cxx11::basic_string_const_pointer>;
            pub type basic_string_const_reverse_iterator =
                root::std::reverse_iterator<root::std::__cxx11::basic_string_const_iterator>;
            pub type basic_string_reverse_iterator =
                root::std::reverse_iterator<root::std::__cxx11::basic_string_iterator>;
            pub type basic_string___const_iterator =
                root::std::__cxx11::basic_string_const_iterator;
            pub type basic_string___sv_type<_CharT> = root::std::basic_string_view<_CharT>;
            pub type basic_string__If_sv = root::std::enable_if_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
            pub struct basic_string___sv_wrapper<_CharT> {
                pub _M_sv: root::std::__cxx11::basic_string___sv_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string___sv_wrapper<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            #[repr(C)]
            pub struct basic_string__Alloc_hider {
                pub _M_p: root::std::__cxx11::basic_string_pointer,
            }
            impl Default for basic_string__Alloc_hider {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl ::std::fmt::Debug for basic_string__Alloc_hider {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__Alloc_hider {{  }}")
                }
            }
            impl PartialEq for basic_string__Alloc_hider {
                fn eq(&self, other: &basic_string__Alloc_hider) -> bool {
                    self._M_p == other._M_p
                }
            }
            pub const basic_string__S_local_capacity:
                root::std::__cxx11::basic_string__bindgen_ty_1 = 0;
            pub type basic_string__bindgen_ty_1 = i32;
            #[repr(C)]
            pub struct basic_string__bindgen_ty_2<_CharT> {
                pub _M_local_buf: root::__BindgenUnionField<*mut _CharT>,
                pub _M_allocated_capacity:
                    root::__BindgenUnionField<root::std::__cxx11::basic_string_size_type>,
                pub bindgen_union_field: u64,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string__bindgen_ty_2<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string__bindgen_ty_2<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__bindgen_ty_2 {{ union }}")
                }
            }
            impl<_CharT> Default for basic_string<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_string {{ _M_dataplus: {:?}, __bindgen_anon_1: {:?} }}",
                        self._M_dataplus, self.__bindgen_anon_1
                    )
                }
            }
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut ::std::os::raw::c_uchar,
            pub __align: root::std::aligned_storage_type__bindgen_ty_1,
            _bindgen_union_align: u64,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_aligned_storage_type() {
            assert_eq!(
                ::std::mem::size_of::<aligned_storage_type>(),
                8usize,
                concat!("Size of: ", stringify!(aligned_storage_type))
            );
            assert_eq!(
                ::std::mem::align_of::<aligned_storage_type>(),
                8usize,
                concat!("Alignment of ", stringify!(aligned_storage_type))
            );
        }
        impl Default for aligned_storage_type {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for aligned_storage_type {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "aligned_storage_type {{ union }}")
            }
        }
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = root::std::__undefined;
        pub type __get_first_arg_t = root::std::__get_first_arg;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = root::std::__detected_or_t;
        pub type pointer_traits_difference_type = root::std::__detected_or_t;
        pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type streamoff = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        impl<_StateT> Default for fpos<_StateT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type streampos = root::std::fpos<root::mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        impl Default for char_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        impl Default for allocator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: usize,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_const_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_iterator<_CharT> = *const _CharT;
        pub type basic_string_view_iterator<_CharT> =
            root::std::basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            root::std::reverse_iterator<root::std::basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            root::std::basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        impl<_CharT> Default for basic_string_view<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub mod literals {}
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        impl Default for _Vector_base__Vector_impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Vector_base__Vector_impl {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base__Vector_impl {{  }}")
            }
        }
        impl PartialEq for _Vector_base__Vector_impl {
            fn eq(&self, other: &_Vector_base__Vector_impl) -> bool {
                self._M_start == other._M_start
                    && self._M_finish == other._M_finish
                    && self._M_end_of_storage == other._M_end_of_storage
            }
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        impl Default for _Vector_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Vector_base {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        impl PartialEq for _Vector_base {
            fn eq(&self, other: &_Vector_base) -> bool {
                self._M_impl == other._M_impl
            }
        }
        #[repr(C)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut root::std::vector,
            pub __buf: u8,
        }
        impl Default for vector__Temporary_value {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Default for vector {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for vector {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "vector {{  }}")
            }
        }
        impl PartialEq for vector {
            fn eq(&self, other: &vector) -> bool {
                self._base == other._base
            }
        }
    }
    pub mod __gnu_cxx {

        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: root::__mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    impl Default for __mbstate_t__bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    impl Default for __mbstate_t {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
                self.__count, self.__value
            )
        }
    }
    pub type mbstate_t = root::__mbstate_t;
    #[repr(C)]
    pub struct Chuck_Local {
        pub name: root::std::__cxx11::string,
        pub size: ::std::os::raw::c_ulong,
        pub is_ref: ::std::os::raw::c_ulong,
        pub is_obj: ::std::os::raw::c_ulong,
        pub is_global: ::std::os::raw::c_ulong,
        pub offset: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Local() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Local>(),
            72usize,
            concat!("Size of: ", stringify!(Chuck_Local))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Local>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Local))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Local>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Local),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Local>())).size as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Local),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Local>())).is_ref as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Local),
                "::",
                stringify!(is_ref)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Local>())).is_obj as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Local),
                "::",
                stringify!(is_obj)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Local>())).is_global as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Local),
                "::",
                stringify!(is_global)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Local>())).offset as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Local),
                "::",
                stringify!(offset)
            )
        );
    }
    impl Default for Chuck_Local {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Local {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Local {{ name: {:?}, size: {:?}, is_ref: {:?}, is_obj: {:?}, is_global: {:?}, offset: {:?} }}" , self . name , self . size , self . is_ref , self . is_obj , self . is_global , self . offset )
        }
    }
    #[repr(C)]
    pub struct Chuck_Frame {
        pub name: root::std::__cxx11::string,
        pub curr_offset: ::std::os::raw::c_ulong,
        pub num_access: ::std::os::raw::c_ulong,
        pub stack: root::std::vector,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Frame() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Frame>(),
            72usize,
            concat!("Size of: ", stringify!(Chuck_Frame))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Frame>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Frame))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Frame>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Frame),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Frame>())).curr_offset as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Frame),
                "::",
                stringify!(curr_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Frame>())).num_access as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Frame),
                "::",
                stringify!(num_access)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Frame>())).stack as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Frame),
                "::",
                stringify!(stack)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}push_scope"]
        pub fn Chuck_Frame_push_scope(this: *mut root::Chuck_Frame);
    }
    extern "C" {
        #[link_name = "\u{1}alloc_local"]
        pub fn Chuck_Frame_alloc_local(
            this: *mut root::Chuck_Frame,
            size: ::std::os::raw::c_ulong,
            name: *const root::std::__cxx11::string,
            is_ref: ::std::os::raw::c_ulong,
            is_obj: ::std::os::raw::c_ulong,
            is_global: ::std::os::raw::c_ulong,
        ) -> *mut root::Chuck_Local;
    }
    extern "C" {
        #[link_name = "\u{1}get_scope"]
        pub fn Chuck_Frame_get_scope(this: *const root::Chuck_Frame, out: *mut root::std::vector);
    }
    extern "C" {
        #[link_name = "\u{1}pop_scope"]
        pub fn Chuck_Frame_pop_scope(this: *mut root::Chuck_Frame, out: *mut root::std::vector);
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Frame"]
        pub fn Chuck_Frame_Chuck_Frame(this: *mut root::Chuck_Frame);
    }
    impl Default for Chuck_Frame {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Frame {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Frame {{ name: {:?}, curr_offset: {:?}, num_access: {:?}, stack: {:?} }}",
                self.name, self.curr_offset, self.num_access, self.stack
            )
        }
    }
    impl Chuck_Frame {
        #[inline]
        pub unsafe fn push_scope(&mut self) {
            Chuck_Frame_push_scope(self)
        }
        #[inline]
        pub unsafe fn alloc_local(
            &mut self,
            size: ::std::os::raw::c_ulong,
            name: *const root::std::__cxx11::string,
            is_ref: ::std::os::raw::c_ulong,
            is_obj: ::std::os::raw::c_ulong,
            is_global: ::std::os::raw::c_ulong,
        ) -> *mut root::Chuck_Local {
            Chuck_Frame_alloc_local(self, size, name, is_ref, is_obj, is_global)
        }
        #[inline]
        pub unsafe fn get_scope(&self, out: *mut root::std::vector) {
            Chuck_Frame_get_scope(self, out)
        }
        #[inline]
        pub unsafe fn pop_scope(&mut self, out: *mut root::std::vector) {
            Chuck_Frame_pop_scope(self, out)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Frame_Chuck_Frame(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::__cxx11::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::__cxx11::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::__cxx11::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::__cxx11::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Local_allocator_open1_ptr_Chuck_Local_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Local_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Local_allocator_open1_ptr_Chuck_Local_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Local_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Local_allocator_open1_ptr_Chuck_Local_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Local_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
}
