/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {

    pub mod std {

        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Tp> = _Tp;
        pub type remove_reference_t = remove_reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = __detector;
        pub type __detected_or_t = __detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __pair_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        impl<_T1, _T2> Default for pair<_T1, _T2> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = __undefined;
        pub type __get_first_arg_t = __get_first_arg;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = __detected_or_t;
        pub type pointer_traits_difference_type = __detected_or_t;
        pub type pointer_traits_rebind = pointer_traits___rebind;
        pub type __ptr_rebind = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = reverse_iterator___traits_type;
        pub type reverse_iterator_reference = reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_base = new_allocator;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = allocator;
        pub type allocator_propagate_on_container_move_assignment = true_type;
        pub type allocator_is_always_equal = true_type;
        impl Default for allocator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Select1st {
            pub _address: u8,
        }
        impl Default for _Select1st {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = __allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = __detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = __detected_or_t;
        pub type allocator_traits_is_always_equal = __detected_or_t;
        pub type allocator_traits_rebind_alloc = __alloc_rebind;
        pub type allocator_traits_rebind_traits = allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = allocator_traits___construct_helper;
        pub mod literals {}
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional__Base = u8;
        pub type optional_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_handle_common {
            pub _M_ptr: _Node_handle_common__AllocTraits,
            pub _M_alloc: optional,
        }
        pub type _Node_handle_common__AllocTraits = allocator_traits;
        pub type _Node_handle_common_allocator_type = __alloc_rebind;
        impl Default for _Node_handle_common {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_handle {
            pub _base: _Node_handle_common,
            pub _M_pkey: _Node_handle___pointer,
            pub _M_pmapped: _Node_handle___pointer,
        }
        pub type _Node_handle_key_type<_Key> = _Key;
        pub type _Node_handle_mapped_type = [u8; 0usize];
        pub type _Node_handle__AllocTraits = allocator_traits;
        pub type _Node_handle___pointer = __ptr_rebind;
        impl Default for _Node_handle {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_insert_return<_Iterator, _NodeHandle> {
            pub position: _Iterator,
            pub inserted: bool,
            pub node: _NodeHandle,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeHandle>>,
        }
        impl<_Iterator, _NodeHandle> Default for _Node_insert_return<_Iterator, _NodeHandle> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Rb_tree_color {
            _S_red = 0,
            _S_black = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_node_base {
            pub _M_color: _Rb_tree_color,
            pub _M_parent: _Rb_tree_node_base__Base_ptr,
            pub _M_left: _Rb_tree_node_base__Base_ptr,
            pub _M_right: _Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr = *mut _Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr = *const _Rb_tree_node_base;
        #[test]
        fn bindgen_test_layout__Rb_tree_node_base() {
            assert_eq!(
                ::std::mem::size_of::<_Rb_tree_node_base>(),
                32usize,
                concat!("Size of: ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                ::std::mem::align_of::<_Rb_tree_node_base>(),
                8usize,
                concat!("Alignment of ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_color as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_color)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_parent as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_parent)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_left as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_left)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_right as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_right)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_minimum"]
            pub fn _Rb_tree_node_base__S_minimum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_minimum"]
            pub fn _Rb_tree_node_base__S_minimum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_maximum"]
            pub fn _Rb_tree_node_base__S_maximum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_maximum"]
            pub fn _Rb_tree_node_base__S_maximum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr;
        }
        impl Default for _Rb_tree_node_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl _Rb_tree_node_base {
            #[inline]
            pub unsafe fn _S_minimum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_minimum(__x)
            }
            #[inline]
            pub unsafe fn _S_minimum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_minimum1(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_maximum(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_maximum1(__x)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_key_compare<_Key_compare> {
            pub _M_key_compare: _Key_compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key_compare>>,
        }
        impl<_Key_compare> Default for _Rb_tree_key_compare<_Key_compare> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_node {
            pub _base: _Rb_tree_node_base,
            pub _M_storage: __aligned_membuf,
        }
        pub type _Rb_tree_node__Link_type = *mut _Rb_tree_node;
        impl Default for _Rb_tree_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_iterator {
            pub _M_node: _Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category = bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = _Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr = _Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut _Rb_tree_node;
        impl Default for _Rb_tree_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: _Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_iterator = _Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category = bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self = _Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr = _Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type = *const _Rb_tree_node;
        impl Default for _Rb_tree_const_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = [u8; 0usize];
        pub type _Rb_tree__Alloc_traits = __alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut _Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr = *const _Rb_tree_node_base;
        pub type _Rb_tree__Link_type = *mut _Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const _Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree__Reuse_or_alloc_node {
            pub _M_root: _Rb_tree__Base_ptr,
            pub _M_nodes: _Rb_tree__Base_ptr,
            pub _M_t: *mut _Rb_tree,
        }
        impl Default for _Rb_tree__Reuse_or_alloc_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree__Alloc_node {
            pub _M_t: *mut _Rb_tree,
        }
        impl Default for _Rb_tree__Alloc_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> = *mut _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> = *const _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> = *mut _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> = *const _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_size_type = usize;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator = reverse_iterator<_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator = reverse_iterator<_Rb_tree_const_iterator>;
        pub type _Rb_tree_node_type = _Node_handle;
        pub type _Rb_tree_insert_return_type = _Node_insert_return<_Iterator, _NodeHandle>;
        pub type _Rb_tree__Compatible_tree = _Rb_tree;
        pub type _Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
            _Rb_tree_key_compare<_Key_compare>;
        #[repr(C)]
        pub struct map {
            pub _M_t: map__Rep_type,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> = pair<_Key, _Tp>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct map_value_compare<_Compare> {
            pub comp: _Compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
        }
        impl<_Compare> Default for map_value_compare<_Compare> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type map__Pair_alloc_type = [u8; 0usize];
        pub type map__Rep_type = _Rb_tree;
        pub type map__Alloc_traits = __alloc_traits;
        pub type map_pointer = [u8; 0usize];
        pub type map_const_pointer = [u8; 0usize];
        pub type map_reference = [u8; 0usize];
        pub type map_const_reference = [u8; 0usize];
        pub type map_iterator = [u8; 0usize];
        pub type map_const_iterator = [u8; 0usize];
        pub type map_size_type = [u8; 0usize];
        pub type map_difference_type = [u8; 0usize];
        pub type map_reverse_iterator = [u8; 0usize];
        pub type map_const_reverse_iterator = [u8; 0usize];
        pub type map_node_type = [u8; 0usize];
        pub type map_insert_return_type = [u8; 0usize];
        impl Default for map {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for map {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "map {{ _M_t: {:?} }}", self._M_t)
            }
        }
        impl ::std::cmp::PartialEq for map {
            fn eq(&self, other: &map) -> bool {
                self._M_t == other._M_t
            }
        }
    }
    pub mod __gnu_cxx {

        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = allocator_traits;
        pub type __alloc_traits_value_type = __alloc_traits__Base_type;
        pub type __alloc_traits_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_size_type = __alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = __alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut __alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const __alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = __and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = __alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __aligned_membuf {
            pub _M_storage: *mut ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __aligned_membuf__Tp2<_Tp> {
            pub _M_t: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        impl<_Tp> Default for __aligned_membuf__Tp2<_Tp> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Default for __aligned_membuf {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
    }
    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    pub type pthread_t = ::std::os::raw::c_ulong;
    pub type FILE = _IO_FILE;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut _IO_marker,
        pub _chain: *mut _IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: __off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut _IO_lock_t,
        pub _offset: __off64_t,
        pub _codecvt: *mut _IO_codecvt,
        pub _wide_data: *mut _IO_wide_data,
        pub _freeres_list: *mut _IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[test]
    fn bindgen_test_layout__IO_FILE() {
        assert_eq!(
            ::std::mem::size_of::<_IO_FILE>(),
            216usize,
            concat!("Size of: ", stringify!(_IO_FILE))
        );
        assert_eq!(
            ::std::mem::align_of::<_IO_FILE>(),
            8usize,
            concat!("Alignment of ", stringify!(_IO_FILE))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    impl Default for _IO_FILE {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct FastCircularBuffer {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct CircularBuffer {
        pub _address: u8,
    }
    pub type THREAD_HANDLE = pthread_t;
    pub type THREAD_FUNCTION = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >;
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XThread {
        pub thread: THREAD_HANDLE,
    }
    #[test]
    fn bindgen_test_layout_XThread() {
        assert_eq!(
            ::std::mem::size_of::<XThread>(),
            8usize,
            concat!("Size of: ", stringify!(XThread))
        );
        assert_eq!(
            ::std::mem::align_of::<XThread>(),
            8usize,
            concat!("Alignment of ", stringify!(XThread))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XThread>())).thread as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XThread),
                "::",
                stringify!(thread)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}start"]
        pub fn XThread_start(
            this: *mut XThread,
            routine: THREAD_FUNCTION,
            ptr: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}wait"]
        pub fn XThread_wait(
            this: *mut XThread,
            milliseconds: ::std::os::raw::c_long,
            cancel: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}test"]
        pub fn XThread_test();
    }
    extern "C" {
        #[link_name = "\u{1}clear"]
        pub fn XThread_clear(this: *mut XThread);
    }
    extern "C" {
        #[link_name = "\u{1}XThread"]
        pub fn XThread_XThread(this: *mut XThread);
    }
    extern "C" {
        #[link_name = "\u{1}XThread_destructor"]
        pub fn XThread_XThread_destructor(this: *mut XThread);
    }
    impl XThread {
        #[inline]
        pub unsafe fn start(
            &mut self,
            routine: THREAD_FUNCTION,
            ptr: *mut ::std::os::raw::c_void,
        ) -> bool {
            XThread_start(self, routine, ptr)
        }
        #[inline]
        pub unsafe fn wait(&mut self, milliseconds: ::std::os::raw::c_long, cancel: bool) -> bool {
            XThread_wait(self, milliseconds, cancel)
        }
        #[inline]
        pub unsafe fn test() {
            XThread_test()
        }
        #[inline]
        pub unsafe fn clear(&mut self) {
            XThread_clear(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XThread_XThread(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            XThread_XThread_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XWriteThread {
        pub m_thread_exit: ::std::os::raw::c_ulong,
        pub m_thread: XThread,
        pub m_data_buffer: *mut FastCircularBuffer,
        pub m_bytes_in_buffer: usize,
        pub m_thread_buffer: *mut ::std::os::raw::c_uchar,
        pub m_stream: *mut FILE,
        pub m_msg_buffer: *mut CircularBuffer,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct XWriteThread_Message {
        pub operation: XWriteThread_Message__bindgen_ty_1,
        pub file: *mut FILE,
        pub __bindgen_anon_1: XWriteThread_Message__bindgen_ty_2,
    }
    pub const XWriteThread_Message_WRITE: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::WRITE;
    pub const XWriteThread_Message_SEEK: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::SEEK;
    pub const XWriteThread_Message_FLUSH: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::FLUSH;
    pub const XWriteThread_Message_CLOSE: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::CLOSE;
    pub const XWriteThread_Message_SHUTDOWN: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::SHUTDOWN;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum XWriteThread_Message__bindgen_ty_1 {
        WRITE = 0,
        SEEK = 1,
        FLUSH = 2,
        CLOSE = 3,
        SHUTDOWN = 4,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union XWriteThread_Message__bindgen_ty_2 {
        pub write: XWriteThread_Message__bindgen_ty_2__bindgen_ty_1,
        pub seek: XWriteThread_Message__bindgen_ty_2__bindgen_ty_2,
        _bindgen_union_align: [u64; 2usize],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XWriteThread_Message__bindgen_ty_2__bindgen_ty_1 {
        pub data_size: usize,
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>()))
                    .data_size as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(data_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XWriteThread_Message__bindgen_ty_2__bindgen_ty_2 {
        pub offset: ::std::os::raw::c_long,
        pub whence: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2__bindgen_ty_2() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>())).offset
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>())).whence
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(whence)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(XWriteThread_Message__bindgen_ty_2))
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(XWriteThread_Message__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2>())).write as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2>())).seek as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2),
                "::",
                stringify!(seek)
            )
        );
    }
    impl Default for XWriteThread_Message__bindgen_ty_2 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for XWriteThread_Message__bindgen_ty_2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "XWriteThread_Message__bindgen_ty_2 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message>(),
            32usize,
            concat!("Size of: ", stringify!(XWriteThread_Message))
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message>(),
            8usize,
            concat!("Alignment of ", stringify!(XWriteThread_Message))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message>())).operation as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message),
                "::",
                stringify!(operation)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread_Message>())).file as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message),
                "::",
                stringify!(file)
            )
        );
    }
    impl Default for XWriteThread_Message {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for XWriteThread_Message {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "XWriteThread_Message {{ operation: {:?}, file: {:?}, __bindgen_anon_1: {:?} }}",
                self.operation, self.file, self.__bindgen_anon_1
            )
        }
    }
    extern "C" {
        #[link_name = "\u{1}PRODUCER_BUFFER_SIZE"]
        pub static XWriteThread_PRODUCER_BUFFER_SIZE: usize;
    }
    extern "C" {
        #[link_name = "\u{1}o_defaultWriteThread"]
        pub static mut XWriteThread_o_defaultWriteThread: *mut XWriteThread;
    }
    #[test]
    fn bindgen_test_layout_XWriteThread() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread>(),
            56usize,
            concat!("Size of: ", stringify!(XWriteThread))
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread>(),
            8usize,
            concat!("Alignment of ", stringify!(XWriteThread))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_thread_exit as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_thread_exit)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_thread as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_thread)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_data_buffer as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_data_buffer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread>())).m_bytes_in_buffer as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_bytes_in_buffer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread>())).m_thread_buffer as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_thread_buffer)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_stream as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_stream)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_msg_buffer as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_msg_buffer)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}shared"]
        pub fn XWriteThread_shared() -> *mut XWriteThread;
    }
    extern "C" {
        #[link_name = "\u{1}fwrite"]
        pub fn XWriteThread_fwrite(
            this: *mut XWriteThread,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            nitems: usize,
            stream: *mut FILE,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}fseek"]
        pub fn XWriteThread_fseek(
            this: *mut XWriteThread,
            stream: *mut FILE,
            offset: ::std::os::raw::c_long,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}fflush"]
        pub fn XWriteThread_fflush(
            this: *mut XWriteThread,
            stream: *mut FILE,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}fclose"]
        pub fn XWriteThread_fclose(
            this: *mut XWriteThread,
            stream: *mut FILE,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}shutdown"]
        pub fn XWriteThread_shutdown(this: *mut XWriteThread);
    }
    extern "C" {
        #[link_name = "\u{1}XWriteThread"]
        pub fn XWriteThread_XWriteThread(
            this: *mut XWriteThread,
            data_buffer_size: usize,
            msg_buffer_size: usize,
        );
    }
    impl Default for XWriteThread {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl XWriteThread {
        #[inline]
        pub unsafe fn shared() -> *mut XWriteThread {
            XWriteThread_shared()
        }
        #[inline]
        pub unsafe fn fwrite(
            &mut self,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            nitems: usize,
            stream: *mut FILE,
        ) -> usize {
            XWriteThread_fwrite(self, ptr, size, nitems, stream)
        }
        #[inline]
        pub unsafe fn fseek(
            &mut self,
            stream: *mut FILE,
            offset: ::std::os::raw::c_long,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            XWriteThread_fseek(self, stream, offset, whence)
        }
        #[inline]
        pub unsafe fn fflush(&mut self, stream: *mut FILE) -> ::std::os::raw::c_int {
            XWriteThread_fflush(self, stream)
        }
        #[inline]
        pub unsafe fn fclose(&mut self, stream: *mut FILE) -> ::std::os::raw::c_int {
            XWriteThread_fclose(self, stream)
        }
        #[inline]
        pub unsafe fn shutdown(&mut self) {
            XWriteThread_shutdown(self)
        }
        #[inline]
        pub unsafe fn new(data_buffer_size: usize, msg_buffer_size: usize) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XWriteThread_XWriteThread(&mut __bindgen_tmp, data_buffer_size, msg_buffer_size);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ChucK {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_Compiler {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_VM {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_Env {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_IO_Chout {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_IO_Cherr {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ck_socket_ {
        _unused: [u8; 0],
    }
    pub type ck_socket = *mut ck_socket_;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct WvOut {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct Chuck_Carrier {
        pub chuck: *mut ChucK,
        pub compiler: *mut Chuck_Compiler,
        pub env: *mut Chuck_Env,
        pub vm: *mut Chuck_VM,
        pub chout: *mut Chuck_IO_Chout,
        pub cherr: *mut Chuck_IO_Cherr,
        pub otf_socket: ck_socket,
        pub otf_port: ::std::os::raw::c_long,
        pub otf_thread: pthread_t,
        pub stk_writeThread: *mut XWriteThread,
        pub stk_wvOutMap: map,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Carrier() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Carrier>(),
            128usize,
            concat!("Size of: ", stringify!(Chuck_Carrier))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Carrier>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Carrier))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).chuck as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(chuck)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).compiler as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(compiler)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).env as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(env)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).vm as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(vm)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).chout as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(chout)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).cherr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(cherr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_socket as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(otf_socket)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_port as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(otf_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_thread as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(otf_thread)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Carrier>())).stk_writeThread as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(stk_writeThread)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).stk_wvOutMap as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(stk_wvOutMap)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}hintIsRealtimeAudio"]
        pub fn Chuck_Carrier_hintIsRealtimeAudio(
            this: *mut Chuck_Carrier,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Carrier"]
        pub fn Chuck_Carrier_Chuck_Carrier(this: *mut Chuck_Carrier);
    }
    impl Default for Chuck_Carrier {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Carrier {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Carrier {{ chuck: {:?}, compiler: {:?}, env: {:?}, vm: {:?}, chout: {:?}, cherr: {:?}, otf_socket: {:?}, otf_port: {:?}, otf_thread: {:?}, stk_writeThread: {:?}, stk_wvOutMap: {:?} }}" , self . chuck , self . compiler , self . env , self . vm , self . chout , self . cherr , self . otf_socket , self . otf_port , self . otf_thread , self . stk_writeThread , self . stk_wvOutMap )
        }
    }
    impl ::std::cmp::PartialEq for Chuck_Carrier {
        fn eq(&self, other: &Chuck_Carrier) -> bool {
            self.chuck == other.chuck
                && self.compiler == other.compiler
                && self.env == other.env
                && self.vm == other.vm
                && self.chout == other.chout
                && self.cherr == other.cherr
                && self.otf_socket == other.otf_socket
                && self.otf_port == other.otf_port
                && self.otf_thread == other.otf_thread
                && self.stk_writeThread == other.stk_writeThread
                && self.stk_wvOutMap == other.stk_wvOutMap
        }
    }
    impl Chuck_Carrier {
        #[inline]
        pub unsafe fn hintIsRealtimeAudio(&mut self) -> ::std::os::raw::c_ulong {
            Chuck_Carrier_hintIsRealtimeAudio(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Carrier_Chuck_Carrier(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[test]
    fn __bindgen_test_layout_map_open0_ptr_WvOut_ptr_WvOut__bindgen_ty_id_35998_open1_ptr_WvOut_close1_allocator_open1_pair_open2_ptr_WvOut_ptr_WvOut_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_WvOut_ptr_WvOut_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_ptr_WvOut_ptr_WvOut_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<pair<*mut WvOut, *mut WvOut>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(pair<*mut WvOut, *mut WvOut>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<pair<*mut WvOut, *mut WvOut>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(pair<*mut WvOut, *mut WvOut>)
            )
        );
    }
}
