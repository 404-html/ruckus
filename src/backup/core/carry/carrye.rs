/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub mod std {

    pub type integral_constant_value_type<_Tp> = _Tp;
    pub type integral_constant_type = u8;
    pub type true_type = u8;
    pub type false_type = u8;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __and_ {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct is_empty {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct remove_reference {
        pub _address: u8,
    }
    pub type remove_reference_type<_Tp> = _Tp;
    pub type remove_reference_t = root::std::remove_reference;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct make_unsigned {
        pub _address: u8,
    }
    pub type make_unsigned_type = u8;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __detector {
        pub _address: u8,
    }
    pub type __detector_value_t = root::std::false_type;
    pub type __detector_type<_Default> = _Default;
    pub type __detected_or = root::std::__detector;
    pub type __detected_or_t = root::std::__detected_or;
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __pair_base {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct pair<_T1, _T2> {
        pub first: _T1,
        pub second: _T2,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
    }
    pub type pair_first_type<_T1> = _T1;
    pub type pair_second_type<_T2> = _T2;
    pub type pair__PCCP = u8;
    pub type pair__PCCFP = u8;
    impl<_T1, _T2> Default for pair<_T1, _T2> {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct input_iterator_tag {
        pub _address: u8,
    }
    // #[test]
    // fn bindgen_test_layout_input_iterator_tag() {
    //     assert_eq!(
    //         size_of::<input_iterator_tag>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(input_iterator_tag))
    //     );
    //     assert_eq!(
    //         align_of::<input_iterator_tag>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(input_iterator_tag))
    //     );
    // }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct forward_iterator_tag {
        pub _address: u8,
    }
    // #[test]
    // fn bindgen_test_layout_forward_iterator_tag() {
    //     assert_eq!(
    //         size_of::<forward_iterator_tag>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(forward_iterator_tag))
    //     );
    //     assert_eq!(
    //         align_of::<forward_iterator_tag>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(forward_iterator_tag))
    //     );
    // }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct bidirectional_iterator_tag {
        pub _address: u8,
    }
    // #[test]
    // fn bindgen_test_layout_bidirectional_iterator_tag() {
    //     assert_eq!(
    //         size_of::<bidirectional_iterator_tag>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(bidirectional_iterator_tag))
    //     );
    //     assert_eq!(
    //         align_of::<bidirectional_iterator_tag>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
    //     );
    // }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct iterator {
        pub _address: u8,
    }
    pub type iterator_iterator_category<_Category> = _Category;
    pub type iterator_value_type<_Tp> = _Tp;
    pub type iterator_difference_type<_Distance> = _Distance;
    pub type iterator_pointer<_Pointer> = _Pointer;
    pub type iterator_reference<_Reference> = _Reference;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __iterator_traits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct iterator_traits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __undefined {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __get_first_arg {
        pub _address: u8,
    }
    pub type __get_first_arg_type = root::std::__undefined;
    pub type __get_first_arg_t = root::std::__get_first_arg;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __replace_first_arg {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct pointer_traits {
        pub _address: u8,
    }
    pub type pointer_traits___element_type = [u8; 0usize];
    pub type pointer_traits___difference_type = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct pointer_traits___rebind {
        pub _address: u8,
    }
    impl Default for pointer_traits___rebind {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub type pointer_traits_pointer<_Ptr> = _Ptr;
    pub type pointer_traits_element_type = root::std::__detected_or_t;
    pub type pointer_traits_difference_type = root::std::__detected_or_t;
    pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
    pub type __ptr_rebind = root::std::pointer_traits;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct reverse_iterator<_Iterator> {
        pub current: _Iterator,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    }
    pub type reverse_iterator___traits_type = root::std::iterator_traits;
    pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
    pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
    pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
    pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
    impl<_Iterator> Default for reverse_iterator<_Iterator> {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub type __allocator_base = root::__gnu_cxx::new_allocator;
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator {
        pub _address: u8,
    }
    pub type allocator_size_type = usize;
    pub type allocator_difference_type = isize;
    pub type allocator_pointer<_Tp> = *mut _Tp;
    pub type allocator_const_pointer<_Tp> = *const _Tp;
    pub type allocator_reference<_Tp> = *mut _Tp;
    pub type allocator_const_reference<_Tp> = *const _Tp;
    pub type allocator_value_type<_Tp> = _Tp;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_rebind {
        pub _address: u8,
    }
    pub type allocator_rebind_other = root::std::allocator;
    pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
    pub type allocator_is_always_equal = root::std::true_type;
    impl Default for allocator {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct unary_function {
        pub _address: u8,
    }
    pub type unary_function_argument_type<_Arg> = _Arg;
    pub type unary_function_result_type<_Result> = _Result;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct binary_function {
        pub _address: u8,
    }
    pub type binary_function_first_argument_type<_Arg1> = _Arg1;
    pub type binary_function_second_argument_type<_Arg2> = _Arg2;
    pub type binary_function_result_type<_Result> = _Result;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Select1st {
        pub _address: u8,
    }
    impl Default for _Select1st {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __allocator_traits_base {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __allocator_traits_base___rebind {
        pub _address: u8,
    }
    impl Default for __allocator_traits_base___rebind {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub type __allocator_traits_base___pointer = [u8; 0usize];
    pub type __allocator_traits_base___c_pointer = [u8; 0usize];
    pub type __allocator_traits_base___v_pointer = [u8; 0usize];
    pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
    pub type __allocator_traits_base___pocca = [u8; 0usize];
    pub type __allocator_traits_base___pocma = [u8; 0usize];
    pub type __allocator_traits_base___pocs = [u8; 0usize];
    pub type __allocator_traits_base___equal = [u8; 0usize];
    // #[test]
    // fn bindgen_test_layout___allocator_traits_base() {
    //     assert_eq!(
    //         size_of::<__allocator_traits_base>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(__allocator_traits_base))
    //     );
    //     assert_eq!(
    //         align_of::<__allocator_traits_base>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(__allocator_traits_base))
    //     );
    // }
    pub type __alloc_rebind = root::std::__allocator_traits_base;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits {
        pub _address: u8,
    }
    pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
    pub type allocator_traits_value_type = [u8; 0usize];
    pub type allocator_traits_pointer = root::std::__detected_or_t;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits__Ptr {
        pub _address: u8,
    }
    pub type allocator_traits__Ptr_type = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits__Diff {
        pub _address: u8,
    }
    pub type allocator_traits__Diff_type = root::std::pointer_traits;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits__Size {
        pub _address: u8,
    }
    impl Default for allocator_traits__Size {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub type allocator_traits_const_pointer = [u8; 0usize];
    pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
    pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
    pub type allocator_traits_difference_type = [u8; 0usize];
    pub type allocator_traits_size_type = [u8; 0usize];
    pub type allocator_traits_propagate_on_container_copy_assignment = root::std::__detected_or_t;
    pub type allocator_traits_propagate_on_container_move_assignment = root::std::__detected_or_t;
    pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
    pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
    pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
    pub type allocator_traits_rebind_traits = root::std::allocator_traits;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits___construct_helper {
        pub _address: u8,
    }
    pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
    pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
    pub mod literals {}
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct optional {
        pub _address: u8,
    }
    pub type optional__Base = u8;
    pub type optional_value_type<_Tp> = _Tp;
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Node_handle_common {
        pub _M_ptr: root::std::_Node_handle_common__AllocTraits,
        pub _M_alloc: root::std::optional,
    }
    pub type _Node_handle_common__AllocTraits = root::std::allocator_traits;
    pub type _Node_handle_common_allocator_type = root::std::__alloc_rebind;
    impl Default for _Node_handle_common {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Node_handle {
        pub _base: root::std::_Node_handle_common,
        pub _M_pkey: root::std::_Node_handle___pointer,
        pub _M_pmapped: root::std::_Node_handle___pointer,
    }
    pub type _Node_handle_key_type<_Key> = _Key;
    pub type _Node_handle_mapped_type = [u8; 0usize];
    pub type _Node_handle__AllocTraits = root::std::allocator_traits;
    pub type _Node_handle___pointer = root::std::__ptr_rebind;
    impl Default for _Node_handle {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Node_insert_return<_Iterator, _NodeHandle> {
        pub position: _Iterator,
        pub inserted: bool,
        pub node: _NodeHandle,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeHandle>>,
    }
    impl<_Iterator, _NodeHandle> Default for _Node_insert_return<_Iterator, _NodeHandle> {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub const _Rb_tree_color__S_red: root::std::_Rb_tree_color = 0;
    pub const _Rb_tree_color__S_black: root::std::_Rb_tree_color = 1;
    pub type _Rb_tree_color = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree_node_base {
        pub _M_color: root::std::_Rb_tree_color,
        pub _M_parent: root::std::_Rb_tree_node_base__Base_ptr,
        pub _M_left: root::std::_Rb_tree_node_base__Base_ptr,
        pub _M_right: root::std::_Rb_tree_node_base__Base_ptr,
    }
    pub type _Rb_tree_node_base__Base_ptr = *mut root::std::_Rb_tree_node_base;
    pub type _Rb_tree_node_base__Const_Base_ptr = *const root::std::_Rb_tree_node_base;
    // #[test]
    // fn bindgen_test_layout__Rb_tree_node_base() {
    //     assert_eq!(
    //         size_of::<_Rb_tree_node_base>(),
    //         32usize,
    //         concat!("Size of: ", stringify!(_Rb_tree_node_base))
    //     );
    //     assert_eq!(
    //         align_of::<_Rb_tree_node_base>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(_Rb_tree_node_base))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_color as *const _ as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(_Rb_tree_node_base),
    //             "::",
    //             stringify!(_M_color)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_parent as *const _ as usize
    //         },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(_Rb_tree_node_base),
    //             "::",
    //             stringify!(_M_parent)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_left as *const _ as usize
    //         },
    //         16usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(_Rb_tree_node_base),
    //             "::",
    //             stringify!(_M_left)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_right as *const _ as usize
    //         },
    //         24usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(_Rb_tree_node_base),
    //             "::",
    //             stringify!(_M_right)
    //         )
    //     );
    // }
    impl Default for _Rb_tree_node_base {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree_key_compare<_Key_compare> {
        pub _M_key_compare: _Key_compare,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key_compare>>,
    }
    impl<_Key_compare> Default for _Rb_tree_key_compare<_Key_compare> {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree_node {
        pub _base: root::std::_Rb_tree_node_base,
        pub _M_storage: root::__gnu_cxx::__aligned_membuf,
    }
    pub type _Rb_tree_node__Link_type = *mut root::std::_Rb_tree_node;
    impl Default for _Rb_tree_node {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree_iterator {
        pub _M_node: root::std::_Rb_tree_iterator__Base_ptr,
    }
    pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
    pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
    pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
    pub type _Rb_tree_iterator_iterator_category = root::std::bidirectional_iterator_tag;
    pub type _Rb_tree_iterator_difference_type = isize;
    pub type _Rb_tree_iterator__Self = root::std::_Rb_tree_iterator;
    pub type _Rb_tree_iterator__Base_ptr = root::std::_Rb_tree_node_base__Base_ptr;
    pub type _Rb_tree_iterator__Link_type = *mut root::std::_Rb_tree_node;
    impl Default for _Rb_tree_iterator {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree_const_iterator {
        pub _M_node: root::std::_Rb_tree_const_iterator__Base_ptr,
    }
    pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
    pub type _Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
    pub type _Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
    pub type _Rb_tree_const_iterator_iterator = root::std::_Rb_tree_iterator;
    pub type _Rb_tree_const_iterator_iterator_category = root::std::bidirectional_iterator_tag;
    pub type _Rb_tree_const_iterator_difference_type = isize;
    pub type _Rb_tree_const_iterator__Self = root::std::_Rb_tree_const_iterator;
    pub type _Rb_tree_const_iterator__Base_ptr = root::std::_Rb_tree_node_base__Const_Base_ptr;
    pub type _Rb_tree_const_iterator__Link_type = *const root::std::_Rb_tree_node;
    impl Default for _Rb_tree_const_iterator {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree {
        pub _M_impl: u8,
    }
    pub type _Rb_tree__Node_allocator = [u8; 0usize];
    pub type _Rb_tree__Alloc_traits = root::__gnu_cxx::__alloc_traits;
    pub type _Rb_tree__Base_ptr = *mut root::std::_Rb_tree_node_base;
    pub type _Rb_tree__Const_Base_ptr = *const root::std::_Rb_tree_node_base;
    pub type _Rb_tree__Link_type = *mut root::std::_Rb_tree_node;
    pub type _Rb_tree__Const_Link_type = *const root::std::_Rb_tree_node;
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree__Reuse_or_alloc_node {
        pub _M_root: root::std::_Rb_tree__Base_ptr,
        pub _M_nodes: root::std::_Rb_tree__Base_ptr,
        pub _M_t: *mut root::std::_Rb_tree,
    }
    impl Default for _Rb_tree__Reuse_or_alloc_node {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Rb_tree__Alloc_node {
        pub _M_t: *mut root::std::_Rb_tree,
    }
    impl Default for _Rb_tree__Alloc_node {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub type _Rb_tree_key_type<_Key> = _Key;
    pub type _Rb_tree_value_type<_Val> = _Val;
    pub type _Rb_tree_pointer<_Val> = *mut root::std::_Rb_tree_value_type<_Val>;
    pub type _Rb_tree_const_pointer<_Val> = *const root::std::_Rb_tree_value_type<_Val>;
    pub type _Rb_tree_reference<_Val> = *mut root::std::_Rb_tree_value_type<_Val>;
    pub type _Rb_tree_const_reference<_Val> = *const root::std::_Rb_tree_value_type<_Val>;
    pub type _Rb_tree_size_type = usize;
    pub type _Rb_tree_difference_type = isize;
    pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
    pub type _Rb_tree_reverse_iterator = root::std::reverse_iterator<root::std::_Rb_tree_iterator>;
    pub type _Rb_tree_const_reverse_iterator =
        root::std::reverse_iterator<root::std::_Rb_tree_const_iterator>;
    pub type _Rb_tree_node_type = root::std::_Node_handle;
    pub type _Rb_tree_insert_return_type = root::std::_Node_insert_return<_Iterator, _NodeHandle>;
    pub type _Rb_tree__Compatible_tree = root::std::_Rb_tree;
    pub type _Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
        root::std::_Rb_tree_key_compare<_Key_compare>;
    #[repr(C)]
    pub struct map {
        pub _M_t: root::std::map__Rep_type,
    }
    pub type map_key_type<_Key> = _Key;
    pub type map_mapped_type<_Tp> = _Tp;
    pub type map_value_type<_Key, _Tp> = root::std::pair<_Key, _Tp>;
    pub type map_key_compare<_Compare> = _Compare;
    pub type map_allocator_type<_Alloc> = _Alloc;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct map_value_compare<_Compare> {
        pub comp: _Compare,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    }
    impl<_Compare> Default for map_value_compare<_Compare> {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    pub type map__Pair_alloc_type = [u8; 0usize];
    pub type map__Rep_type = root::std::_Rb_tree;
    pub type map__Alloc_traits = root::__gnu_cxx::__alloc_traits;
    pub type map_pointer = [u8; 0usize];
    pub type map_const_pointer = [u8; 0usize];
    pub type map_reference = [u8; 0usize];
    pub type map_const_reference = [u8; 0usize];
    pub type map_iterator = [u8; 0usize];
    pub type map_const_iterator = [u8; 0usize];
    pub type map_size_type = [u8; 0usize];
    pub type map_difference_type = [u8; 0usize];
    pub type map_reverse_iterator = [u8; 0usize];
    pub type map_const_reverse_iterator = [u8; 0usize];
    pub type map_node_type = [u8; 0usize];
    pub type map_insert_return_type = [u8; 0usize];
    impl Default for map {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    impl ::std::fmt::Debug for map {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "map {{ _M_t: {:?} }}", self._M_t)
        }
    }
    impl PartialEq for map {
        fn eq(&self, other: &map) -> bool {
            self._M_t == other._M_t
        }
    }
}
pub mod __gnu_cxx {

    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct new_allocator {
        pub _address: u8,
    }
    pub type new_allocator_size_type = usize;
    pub type new_allocator_difference_type = isize;
    pub type new_allocator_pointer<_Tp> = *mut _Tp;
    pub type new_allocator_const_pointer<_Tp> = *const _Tp;
    pub type new_allocator_reference<_Tp> = *mut _Tp;
    pub type new_allocator_const_reference<_Tp> = *const _Tp;
    pub type new_allocator_value_type<_Tp> = _Tp;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct new_allocator_rebind {
        pub _address: u8,
    }
    pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
    pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __alloc_traits {
        pub _address: u8,
    }
    pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
    pub type __alloc_traits__Base_type = root::std::allocator_traits;
    pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
    pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
    pub type __alloc_traits___is_custom_pointer = root::std::__and_;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __alloc_traits_rebind {
        pub _address: u8,
    }
    pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
    impl Default for __alloc_traits {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __aligned_membuf {
        pub _M_storage: *mut ::std::os::raw::c_uchar,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __aligned_membuf__Tp2<_Tp> {
        pub _M_t: _Tp,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    }
    impl<_Tp> Default for __aligned_membuf__Tp2<_Tp> {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
    impl Default for __aligned_membuf {
        fn default() -> Self {
            unsafe { zeroed() }
        }
    }
}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type pthread_t = ::std::os::raw::c_ulong;
pub type FILE = root::_IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut root::_IO_marker,
    pub _chain: *mut root::_IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: root::__off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut root::_IO_lock_t,
    pub _offset: root::__off64_t,
    pub _codecvt: *mut root::_IO_codecvt,
    pub _wide_data: *mut root::_IO_wide_data,
    pub _freeres_list: *mut root::_IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
// #[test]
// fn bindgen_test_layout__IO_FILE() {
//     assert_eq!(
//         size_of::<_IO_FILE>(),
//         216usize,
//         concat!("Size of: ", stringify!(_IO_FILE))
//     );
//     assert_eq!(
//         align_of::<_IO_FILE>(),
//         8usize,
//         concat!("Alignment of ", stringify!(_IO_FILE))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_flags)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_read_ptr)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
//         16usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_read_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
//         24usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_read_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
//         32usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_write_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
//         40usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_write_ptr)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
//         48usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_write_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
//         56usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_buf_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
//         64usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_buf_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
//         72usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_save_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
//         80usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_backup_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
//         88usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_save_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
//         96usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_markers)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
//         104usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_chain)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
//         112usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_fileno)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
//         116usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_flags2)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
//         120usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_old_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
//         128usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_cur_column)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
//         130usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_vtable_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
//         131usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_shortbuf)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
//         136usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_lock)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
//         144usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
//         152usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_codecvt)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
//         160usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_wide_data)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
//         168usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_freeres_list)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
//         176usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_freeres_buf)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
//         184usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(__pad5)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
//         192usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_mode)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
//         196usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_unused2)
//         )
//     );
// }
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FastCircularBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CircularBuffer {
    pub _address: u8,
}
pub type THREAD_HANDLE = root::pthread_t;
pub type THREAD_FUNCTION = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct XThread {
    pub thread: root::THREAD_HANDLE,
}
// #[test]
// fn bindgen_test_layout_XThread() {
//     assert_eq!(
//         size_of::<XThread>(),
//         8usize,
//         concat!("Size of: ", stringify!(XThread))
//     );
//     assert_eq!(
//         align_of::<XThread>(),
//         8usize,
//         concat!("Alignment of ", stringify!(XThread))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XThread>())).thread as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XThread),
//             "::",
//             stringify!(thread)
//         )
//     );
// }
extern "C" {
    #[link_name = "\u{1}start"]
    pub fn XThread_start(
        this: *mut root::XThread,
        routine: root::THREAD_FUNCTION,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}wait"]
    pub fn XThread_wait(
        this: *mut root::XThread,
        milliseconds: ::std::os::raw::c_long,
        cancel: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}test"]
    pub fn XThread_test();
}
extern "C" {
    #[link_name = "\u{1}XThread"]
    pub fn XThread_XThread(this: *mut root::XThread);
}
extern "C" {
    #[link_name = "\u{1}XThread_destructor"]
    pub fn XThread_XThread_destructor(this: *mut root::XThread);
}
impl XThread {
    #[inline]
    pub unsafe fn start(
        &mut self,
        routine: root::THREAD_FUNCTION,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool {
        XThread_start(self, routine, ptr)
    }
    #[inline]
    pub unsafe fn wait(&mut self, milliseconds: ::std::os::raw::c_long, cancel: bool) -> bool {
        XThread_wait(self, milliseconds, cancel)
    }
    #[inline]
    pub unsafe fn test() {
        XThread_test()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = uninitialized();
        XThread_XThread(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        XThread_XThread_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct XWriteThread {
    pub m_thread_exit: ::std::os::raw::c_ulong,
    pub m_thread: root::XThread,
    pub m_data_buffer: *mut root::FastCircularBuffer,
    pub m_bytes_in_buffer: usize,
    pub m_thread_buffer: *mut ::std::os::raw::c_uchar,
    pub m_stream: *mut root::FILE,
    pub m_msg_buffer: *mut root::CircularBuffer,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWriteThread_Message {
    pub operation: root::XWriteThread_Message__bindgen_ty_1,
    pub file: *mut root::FILE,
    pub __bindgen_anon_1: root::XWriteThread_Message__bindgen_ty_2,
}
pub const XWriteThread_Message_WRITE: root::XWriteThread_Message__bindgen_ty_1 = 0;
pub const XWriteThread_Message_SEEK: root::XWriteThread_Message__bindgen_ty_1 = 1;
pub const XWriteThread_Message_FLUSH: root::XWriteThread_Message__bindgen_ty_1 = 2;
pub const XWriteThread_Message_CLOSE: root::XWriteThread_Message__bindgen_ty_1 = 3;
pub const XWriteThread_Message_SHUTDOWN: root::XWriteThread_Message__bindgen_ty_1 = 4;
pub type XWriteThread_Message__bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union XWriteThread_Message__bindgen_ty_2 {
    pub write: root::XWriteThread_Message__bindgen_ty_2__bindgen_ty_1,
    pub seek: root::XWriteThread_Message__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct XWriteThread_Message__bindgen_ty_2__bindgen_ty_1 {
    pub data_size: usize,
}
// #[test]
// fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2__bindgen_ty_1() {
//     assert_eq!(
//         size_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>(),
//         8usize,
//         concat!(
//             "Size of: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1)
//         )
//     );
//     assert_eq!(
//         align_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>(),
//         8usize,
//         concat!(
//             "Alignment of ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>()))
//                 .data_size as *const _ as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1),
//             "::",
//             stringify!(data_size)
//         )
//     );
// }
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct XWriteThread_Message__bindgen_ty_2__bindgen_ty_2 {
    pub offset: ::std::os::raw::c_long,
    pub whence: ::std::os::raw::c_int,
}
// #[test]
// fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2__bindgen_ty_2() {
//     assert_eq!(
//         size_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>(),
//         16usize,
//         concat!(
//             "Size of: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2)
//         )
//     );
//     assert_eq!(
//         align_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>(),
//         8usize,
//         concat!(
//             "Alignment of ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>())).offset
//                 as *const _ as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2),
//             "::",
//             stringify!(offset)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>())).whence
//                 as *const _ as usize
//         },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2),
//             "::",
//             stringify!(whence)
//         )
//     );
// }
// #[test]
// fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2() {
//     assert_eq!(
//         size_of::<XWriteThread_Message__bindgen_ty_2>(),
//         16usize,
//         concat!("Size of: ", stringify!(XWriteThread_Message__bindgen_ty_2))
//     );
//     assert_eq!(
//         align_of::<XWriteThread_Message__bindgen_ty_2>(),
//         8usize,
//         concat!(
//             "Alignment of ",
//             stringify!(XWriteThread_Message__bindgen_ty_2)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2>())).write as *const _
//                 as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2),
//             "::",
//             stringify!(write)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2>())).seek as *const _
//                 as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message__bindgen_ty_2),
//             "::",
//             stringify!(seek)
//         )
//     );
// }
impl Default for XWriteThread_Message__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for XWriteThread_Message__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "XWriteThread_Message__bindgen_ty_2 {{ union }}")
    }
}
// #[test]
// fn bindgen_test_layout_XWriteThread_Message() {
//     assert_eq!(
//         size_of::<XWriteThread_Message>(),
//         32usize,
//         concat!("Size of: ", stringify!(XWriteThread_Message))
//     );
//     assert_eq!(
//         align_of::<XWriteThread_Message>(),
//         8usize,
//         concat!("Alignment of ", stringify!(XWriteThread_Message))
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread_Message>())).operation as *const _ as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message),
//             "::",
//             stringify!(operation)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XWriteThread_Message>())).file as *const _ as usize },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread_Message),
//             "::",
//             stringify!(file)
//         )
//     );
// }
impl Default for XWriteThread_Message {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for XWriteThread_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "XWriteThread_Message {{ operation: {:?}, file: {:?}, __bindgen_anon_1: {:?} }}",
            self.operation, self.file, self.__bindgen_anon_1
        )
    }
}
extern "C" {
    #[link_name = "\u{1}PRODUCER_BUFFER_SIZE"]
    pub static XWriteThread_PRODUCER_BUFFER_SIZE: usize;
}
extern "C" {
    #[link_name = "\u{1}o_defaultWriteThread"]
    pub static mut XWriteThread_o_defaultWriteThread: *mut root::XWriteThread;
}
// #[test]
// fn bindgen_test_layout_XWriteThread() {
//     assert_eq!(
//         size_of::<XWriteThread>(),
//         56usize,
//         concat!("Size of: ", stringify!(XWriteThread))
//     );
//     assert_eq!(
//         align_of::<XWriteThread>(),
//         8usize,
//         concat!("Alignment of ", stringify!(XWriteThread))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_thread_exit as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_thread_exit)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_thread as *const _ as usize },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_thread)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_data_buffer as *const _ as usize },
//         16usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_data_buffer)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread>())).m_bytes_in_buffer as *const _ as usize
//         },
//         24usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_bytes_in_buffer)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<XWriteThread>())).m_thread_buffer as *const _ as usize
//         },
//         32usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_thread_buffer)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_stream as *const _ as usize },
//         40usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_stream)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_msg_buffer as *const _ as usize },
//         48usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(XWriteThread),
//             "::",
//             stringify!(m_msg_buffer)
//         )
//     );
// }
extern "C" {
    #[link_name = "\u{1}shared"]
    pub fn XWriteThread_shared() -> *mut root::XWriteThread;
}
extern "C" {
    #[link_name = "\u{1}fwrite"]
    pub fn XWriteThread_fwrite(
        this: *mut root::XWriteThread,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nitems: usize,
        stream: *mut root::FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}fseek"]
    pub fn XWriteThread_fseek(
        this: *mut root::XWriteThread,
        stream: *mut root::FILE,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fflush"]
    pub fn XWriteThread_fflush(
        this: *mut root::XWriteThread,
        stream: *mut root::FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fclose"]
    pub fn XWriteThread_fclose(
        this: *mut root::XWriteThread,
        stream: *mut root::FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}shutdown"]
    pub fn XWriteThread_shutdown(this: *mut root::XWriteThread);
}
extern "C" {
    #[link_name = "\u{1}XWriteThread"]
    pub fn XWriteThread_XWriteThread(
        this: *mut root::XWriteThread,
        data_buffer_size: usize,
        msg_buffer_size: usize,
    );
}
impl Default for XWriteThread {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl XWriteThread {
    #[inline]
    pub unsafe fn shared() -> *mut root::XWriteThread {
        XWriteThread_shared()
    }
    #[inline]
    pub unsafe fn fwrite(
        &mut self,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nitems: usize,
        stream: *mut root::FILE,
    ) -> usize {
        XWriteThread_fwrite(self, ptr, size, nitems, stream)
    }
    #[inline]
    pub unsafe fn fseek(
        &mut self,
        stream: *mut root::FILE,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        XWriteThread_fseek(self, stream, offset, whence)
    }
    #[inline]
    pub unsafe fn fflush(&mut self, stream: *mut root::FILE) -> ::std::os::raw::c_int {
        XWriteThread_fflush(self, stream)
    }
    #[inline]
    pub unsafe fn fclose(&mut self, stream: *mut root::FILE) -> ::std::os::raw::c_int {
        XWriteThread_fclose(self, stream)
    }
    #[inline]
    pub unsafe fn shutdown(&mut self) {
        XWriteThread_shutdown(self)
    }
    #[inline]
    pub unsafe fn new(data_buffer_size: usize, msg_buffer_size: usize) -> Self {
        let mut __bindgen_tmp = uninitialized();
        XWriteThread_XWriteThread(&mut __bindgen_tmp, data_buffer_size, msg_buffer_size);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChucK {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_Compiler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_VM {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_Env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_IO_Chout {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_IO_Cherr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ck_socket_ {
    _unused: [u8; 0],
}
pub type ck_socket = *mut root::ck_socket_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WvOut {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct Chuck_Carrier {
    pub chuck: *mut root::ChucK,
    pub compiler: *mut root::Chuck_Compiler,
    pub env: *mut root::Chuck_Env,
    pub vm: *mut root::Chuck_VM,
    pub chout: *mut root::Chuck_IO_Chout,
    pub cherr: *mut root::Chuck_IO_Cherr,
    pub otf_socket: root::ck_socket,
    pub otf_port: ::std::os::raw::c_long,
    pub otf_thread: root::pthread_t,
    pub stk_writeThread: *mut root::XWriteThread,
    pub stk_wvOutMap: root::std::map,
}
// #[test]
// fn bindgen_test_layout_Chuck_Carrier() {
//     assert_eq!(
//         size_of::<Chuck_Carrier>(),
//         128usize,
//         concat!("Size of: ", stringify!(Chuck_Carrier))
//     );
//     assert_eq!(
//         align_of::<Chuck_Carrier>(),
//         8usize,
//         concat!("Alignment of ", stringify!(Chuck_Carrier))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).chuck as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(chuck)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).compiler as *const _ as usize },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(compiler)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).env as *const _ as usize },
//         16usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(env)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).vm as *const _ as usize },
//         24usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(vm)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).chout as *const _ as usize },
//         32usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(chout)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).cherr as *const _ as usize },
//         40usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(cherr)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_socket as *const _ as usize },
//         48usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(otf_socket)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_port as *const _ as usize },
//         56usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(otf_port)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_thread as *const _ as usize },
//         64usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(otf_thread)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<Chuck_Carrier>())).stk_writeThread as *const _ as usize
//         },
//         72usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(stk_writeThread)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).stk_wvOutMap as *const _ as usize },
//         80usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(Chuck_Carrier),
//             "::",
//             stringify!(stk_wvOutMap)
//         )
//     );
// }
extern "C" {
    #[link_name = "\u{1}hintIsRealtimeAudio"]
    pub fn Chuck_Carrier_hintIsRealtimeAudio(
        this: *mut root::Chuck_Carrier,
    ) -> ::std::os::raw::c_ulong;
}
impl Default for Chuck_Carrier {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for Chuck_Carrier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "Chuck_Carrier {{ chuck: {:?}, compiler: {:?}, env: {:?}, vm: {:?}, chout: {:?}, cherr: {:?}, otf_socket: {:?}, otf_port: {:?}, otf_thread: {:?}, stk_writeThread: {:?}, stk_wvOutMap: {:?} }}" , self . chuck , self . compiler , self . env , self . vm , self . chout , self . cherr , self . otf_socket , self . otf_port , self . otf_thread , self . stk_writeThread , self . stk_wvOutMap )
    }
}
impl PartialEq for Chuck_Carrier {
    fn eq(&self, other: &Chuck_Carrier) -> bool {
        self.chuck == other.chuck
            && self.compiler == other.compiler
            && self.env == other.env
            && self.vm == other.vm
            && self.chout == other.chout
            && self.cherr == other.cherr
            && self.otf_socket == other.otf_socket
            && self.otf_port == other.otf_port
            && self.otf_thread == other.otf_thread
            && self.stk_writeThread == other.stk_writeThread
            && self.stk_wvOutMap == other.stk_wvOutMap
    }
}
impl Chuck_Carrier {
    #[inline]
    pub unsafe fn hintIsRealtimeAudio(&mut self) -> ::std::os::raw::c_ulong {
        Chuck_Carrier_hintIsRealtimeAudio(self)
    }
}
// #[test]
// fn __bindgen_test_layout_map_open0_ptr_WvOut_ptr_WvOut__bindgen_ty_id_35717_open1_ptr_WvOut_close1_allocator_open1_pair_open2_ptr_WvOut_ptr_WvOut_close2_close1_close0_instantiation(
// ) {
//     assert_eq!(
//         size_of::<root::std::map>(),
//         48usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::map)
//         )
//     );
//     assert_eq!(
//         align_of::<root::std::map>(),
//         8usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::map)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_WvOut_ptr_WvOut_close1_close0_instantiation(
// ) {
//     assert_eq!(
//         size_of::<root::std::allocator>(),
//         1usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::allocator)
//         )
//     );
//     assert_eq!(
//         align_of::<root::std::allocator>(),
//         1usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::allocator)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_pair_open0_ptr_WvOut_ptr_WvOut_close0_instantiation() {
//     assert_eq!(
//         size_of::<root::std::pair<*mut root::WvOut, *mut root::WvOut>>(),
//         16usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::pair<*mut root::WvOut, *mut root::WvOut>)
//         )
//     );
//     assert_eq!(
//         align_of::<root::std::pair<*mut root::WvOut, *mut root::WvOut>>(),
//         8usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::pair<*mut root::WvOut, *mut root::WvOut>)
//         )
//     );
// }
