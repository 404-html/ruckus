/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}

    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: __mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    impl Default for __mbstate_t__bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    impl Default for __mbstate_t {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
                self.__count, self.__value
            )
        }
    }
    pub type FILE = _IO_FILE;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut _IO_marker,
        pub _chain: *mut _IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: __off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut _IO_lock_t,
        pub _offset: __off64_t,
        pub _codecvt: *mut _IO_codecvt,
        pub _wide_data: *mut _IO_wide_data,
        pub _freeres_list: *mut _IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[test]
    fn bindgen_test_layout__IO_FILE() {
        assert_eq!(
            ::std::mem::size_of::<_IO_FILE>(),
            216usize,
            concat!("Size of: ", stringify!(_IO_FILE))
        );
        assert_eq!(
            ::std::mem::align_of::<_IO_FILE>(),
            8usize,
            concat!("Alignment of ", stringify!(_IO_FILE))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    impl Default for _IO_FILE {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub mod std {

        pub mod __cxx11 {

            pub type string = basic_string<::std::os::raw::c_char>;
            #[repr(C)]
            pub struct basic_string<_CharT> {
                pub _M_dataplus: basic_string__Alloc_hider,
                pub _M_string_length: basic_string_size_type,
                pub __bindgen_anon_1: basic_string__bindgen_ty_2<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_string__Char_alloc_type = [u8; 0usize];
            pub type basic_string__Alloc_traits = __alloc_traits;
            pub type basic_string_traits_type<_Traits> = _Traits;
            pub type basic_string_value_type = [u8; 0usize];
            pub type basic_string_allocator_type = basic_string__Char_alloc_type;
            pub type basic_string_size_type = [u8; 0usize];
            pub type basic_string_difference_type = [u8; 0usize];
            pub type basic_string_reference = [u8; 0usize];
            pub type basic_string_const_reference = [u8; 0usize];
            pub type basic_string_pointer = [u8; 0usize];
            pub type basic_string_const_pointer = [u8; 0usize];
            pub type basic_string_iterator = __normal_iterator<basic_string_pointer>;
            pub type basic_string_const_iterator = __normal_iterator<basic_string_const_pointer>;
            pub type basic_string_const_reverse_iterator =
                reverse_iterator<basic_string_const_iterator>;
            pub type basic_string_reverse_iterator = reverse_iterator<basic_string_iterator>;
            pub type basic_string___const_iterator = basic_string_const_iterator;
            pub type basic_string___sv_type<_CharT> = basic_string_view<_CharT>;
            pub type basic_string__If_sv = enable_if_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
            pub struct basic_string___sv_wrapper<_CharT> {
                pub _M_sv: basic_string___sv_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string___sv_wrapper<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            #[repr(C)]
            pub struct basic_string__Alloc_hider {
                pub _M_p: basic_string_pointer,
            }
            impl Default for basic_string__Alloc_hider {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl ::std::fmt::Debug for basic_string__Alloc_hider {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__Alloc_hider {{  }}")
                }
            }
            impl ::std::cmp::PartialEq for basic_string__Alloc_hider {
                fn eq(&self, other: &basic_string__Alloc_hider) -> bool {
                    self._M_p == other._M_p
                }
            }
            pub const basic_string__S_local_capacity: basic_string__bindgen_ty_1 =
                basic_string__bindgen_ty_1::_S_local_capacity;
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
            pub enum basic_string__bindgen_ty_1 {
                _S_local_capacity = 0,
            }
            #[repr(C)]
            pub struct basic_string__bindgen_ty_2<_CharT> {
                pub _M_local_buf:
                    crate::core::instruc::instruc::root::__BindgenUnionField<*mut _CharT>,
                pub _M_allocated_capacity: crate::core::instruc::instruc::root::__BindgenUnionField<
                    basic_string_size_type,
                >,
                pub bindgen_union_field: u64,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string__bindgen_ty_2<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string__bindgen_ty_2<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__bindgen_ty_2 {{ union }}")
                }
            }
            impl<_CharT> Default for basic_string<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_string {{ _M_dataplus: {:?}, __bindgen_anon_1: {:?} }}",
                        self._M_dataplus, self.__bindgen_anon_1
                    )
                }
            }
            #[repr(C)]
            pub struct basic_stringbuf<_CharT> {
                pub _base: basic_streambuf<_CharT>,
                pub _M_mode: ios_base_openmode,
                pub _M_string: basic_stringbuf___string_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_stringbuf_char_type<_CharT> = _CharT;
            pub type basic_stringbuf_traits_type<_Traits> = _Traits;
            pub type basic_stringbuf_allocator_type<_Alloc> = _Alloc;
            pub type basic_stringbuf_int_type = [u8; 0usize];
            pub type basic_stringbuf_pos_type = [u8; 0usize];
            pub type basic_stringbuf_off_type = [u8; 0usize];
            pub type basic_stringbuf___streambuf_type<_CharT> =
                basic_streambuf<basic_stringbuf_char_type<_CharT>>;
            pub type basic_stringbuf___string_type<_CharT> =
                basic_string<basic_stringbuf_char_type<_CharT>>;
            pub type basic_stringbuf___size_type<_CharT> = basic_stringbuf___string_type<_CharT>;
            #[repr(C)]
            pub struct basic_stringbuf___xfer_bufptrs<_CharT> {
                pub _M_to: *mut basic_stringbuf<_CharT>,
                pub _M_goff: [basic_stringbuf_off_type; 3usize],
                pub _M_poff: [basic_stringbuf_off_type; 3usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_stringbuf___xfer_bufptrs<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_stringbuf___xfer_bufptrs<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write ! ( f , "basic_stringbuf___xfer_bufptrs {{ _M_to: {:?}, _M_goff: {:?}, _M_poff: {:?} }}" , self . _M_to , self . _M_goff , self . _M_poff )
                }
            }
            impl<_CharT> Default for basic_stringbuf<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_stringbuf<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_stringbuf {{ _M_mode: {:?}, _M_string: {:?} }}",
                        self._M_mode, self._M_string
                    )
                }
            }
            #[repr(C)]
            pub struct basic_stringstream<_CharT> {
                pub _base: basic_iostream<_CharT>,
                pub _M_stringbuf: basic_stringstream___stringbuf_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_stringstream_char_type<_CharT> = _CharT;
            pub type basic_stringstream_traits_type<_Traits> = _Traits;
            pub type basic_stringstream_allocator_type<_Alloc> = _Alloc;
            pub type basic_stringstream_int_type = [u8; 0usize];
            pub type basic_stringstream_pos_type = [u8; 0usize];
            pub type basic_stringstream_off_type = [u8; 0usize];
            pub type basic_stringstream___string_type<_CharT> = basic_string<_CharT>;
            pub type basic_stringstream___stringbuf_type<_CharT> = basic_stringbuf<_CharT>;
            pub type basic_stringstream___iostream_type<_CharT> =
                basic_iostream<basic_stringstream_char_type<_CharT>>;
            impl<_CharT> Default for basic_stringstream<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_stringstream<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_stringstream {{ _M_stringbuf: {:?} }}",
                        self._M_stringbuf
                    )
                }
            }
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Tp> = _Tp;
        pub type remove_reference_t = remove_reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut ::std::os::raw::c_uchar,
            pub __align: aligned_storage_type__bindgen_ty_1,
            _bindgen_union_align: u64,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_aligned_storage_type() {
            assert_eq!(
                ::std::mem::size_of::<aligned_storage_type>(),
                8usize,
                concat!("Size of: ", stringify!(aligned_storage_type))
            );
            assert_eq!(
                ::std::mem::align_of::<aligned_storage_type>(),
                8usize,
                concat!("Alignment of ", stringify!(aligned_storage_type))
            );
        }
        impl Default for aligned_storage_type {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for aligned_storage_type {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "aligned_storage_type {{ union }}")
            }
        }
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = __detector;
        pub type __detected_or_t = __detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __pair_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        impl<_T1, _T2> Default for pair<_T1, _T2> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_output_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<output_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(output_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<output_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(output_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_random_access_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(random_access_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(random_access_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = __undefined;
        pub type __get_first_arg_t = __get_first_arg;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = __detected_or_t;
        pub type pointer_traits_difference_type = __detected_or_t;
        pub type pointer_traits_rebind = pointer_traits___rebind;
        pub type __ptr_rebind = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = reverse_iterator___traits_type;
        pub type reverse_iterator_reference = reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct exception__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct exception {
            pub vtable_: *const exception__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(
                ::std::mem::size_of::<exception>(),
                8usize,
                concat!("Size of: ", stringify!(exception))
            );
            assert_eq!(
                ::std::mem::align_of::<exception>(),
                8usize,
                concat!("Alignment of ", stringify!(exception))
            );
        }
        extern "C" {
            #[link_name = "\u{1}exception"]
            pub fn exception_exception(this: *mut exception);
        }
        impl Default for exception {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl exception {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                exception_exception(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}exception_destructor"]
            pub fn exception_exception_destructor(this: *mut exception);
        }
        extern "C" {
            #[link_name = "\u{1}what"]
            pub fn exception_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        pub type __allocator_base = new_allocator;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = allocator;
        pub type allocator_propagate_on_container_move_assignment = true_type;
        pub type allocator_is_always_equal = true_type;
        impl Default for allocator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Select1st {
            pub _address: u8,
        }
        impl Default for _Select1st {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = __allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = __detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = __detected_or_t;
        pub type allocator_traits_is_always_equal = __detected_or_t;
        pub type allocator_traits_rebind_alloc = __alloc_rebind;
        pub type allocator_traits_rebind_traits = allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = allocator_traits___construct_helper;
        pub type streamoff = ::std::os::raw::c_long;
        pub type streamsize = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct fpos<_StateT> {
            pub _M_off: streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        impl<_StateT> Default for fpos<_StateT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type streampos = fpos<mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        impl Default for char_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __c_locale = __locale_t;
        pub type stringstream = basic_stringstream<::std::os::raw::c_char>;
        pub type fstream = basic_fstream<::std::os::raw::c_char>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: usize,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_const_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_iterator<_CharT> = *const _CharT;
        pub type basic_string_view_iterator<_CharT> = basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            reverse_iterator<basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        impl<_CharT> Default for basic_string_view<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub mod literals {}
        #[repr(C)]
        pub struct __cow_string {
            pub __bindgen_anon_1: __cow_string__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union __cow_string__bindgen_ty_1 {
            pub _M_p: *const ::std::os::raw::c_char,
            pub _M_bytes: [::std::os::raw::c_char; 8usize],
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout___cow_string__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<__cow_string__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(__cow_string__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<__cow_string__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(__cow_string__bindgen_ty_1))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_p as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__cow_string__bindgen_ty_1),
                    "::",
                    stringify!(_M_p)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_bytes as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__cow_string__bindgen_ty_1),
                    "::",
                    stringify!(_M_bytes)
                )
            );
        }
        impl Default for __cow_string__bindgen_ty_1 {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for __cow_string__bindgen_ty_1 {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "__cow_string__bindgen_ty_1 {{ union }}")
            }
        }
        #[test]
        fn bindgen_test_layout___cow_string() {
            assert_eq!(
                ::std::mem::size_of::<__cow_string>(),
                8usize,
                concat!("Size of: ", stringify!(__cow_string))
            );
            assert_eq!(
                ::std::mem::align_of::<__cow_string>(),
                8usize,
                concat!("Alignment of ", stringify!(__cow_string))
            );
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string(this: *mut __cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string1(this: *mut __cow_string, arg1: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string2(
                this: *mut __cow_string,
                arg1: *const ::std::os::raw::c_char,
                arg2: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string3(this: *mut __cow_string, arg1: *const __cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string4(this: *mut __cow_string, arg1: *mut __cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string_destructor"]
            pub fn __cow_string___cow_string_destructor(this: *mut __cow_string);
        }
        impl Default for __cow_string {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for __cow_string {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "__cow_string {{ __bindgen_anon_1: {:?} }}",
                    self.__bindgen_anon_1
                )
            }
        }
        impl __cow_string {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string2(&mut __bindgen_tmp, arg1, arg2);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(arg1: *const __cow_string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string3(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(arg1: *mut __cow_string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string4(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                __cow_string___cow_string_destructor(self)
            }
        }
        #[repr(C)]
        pub struct runtime_error {
            pub _base: exception,
            pub _M_msg: __cow_string,
        }
        #[test]
        fn bindgen_test_layout_runtime_error() {
            assert_eq!(
                ::std::mem::size_of::<runtime_error>(),
                16usize,
                concat!("Size of: ", stringify!(runtime_error))
            );
            assert_eq!(
                ::std::mem::align_of::<runtime_error>(),
                8usize,
                concat!("Alignment of ", stringify!(runtime_error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<runtime_error>()))._M_msg as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(runtime_error),
                    "::",
                    stringify!(_M_msg)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error"]
            pub fn runtime_error_runtime_error(this: *mut runtime_error, __arg: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error"]
            pub fn runtime_error_runtime_error1(
                this: *mut runtime_error,
                arg1: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error"]
            pub fn runtime_error_runtime_error2(
                this: *mut runtime_error,
                arg1: *const runtime_error,
            );
        }
        impl Default for runtime_error {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for runtime_error {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "runtime_error {{ _M_msg: {:?} }}", self._M_msg)
            }
        }
        impl runtime_error {
            #[inline]
            pub unsafe fn new(__arg: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                runtime_error_runtime_error(&mut __bindgen_tmp, __arg);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                runtime_error_runtime_error1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(arg1: *const runtime_error) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                runtime_error_runtime_error2(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error_destructor"]
            pub fn runtime_error_runtime_error_destructor(this: *mut runtime_error);
        }
        extern "C" {
            #[link_name = "\u{1}what"]
            pub fn runtime_error_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional__Base = u8;
        pub type optional_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_handle_common {
            pub _M_ptr: _Node_handle_common__AllocTraits,
            pub _M_alloc: optional,
        }
        pub type _Node_handle_common__AllocTraits = allocator_traits;
        pub type _Node_handle_common_allocator_type = __alloc_rebind;
        impl Default for _Node_handle_common {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_handle {
            pub _base: _Node_handle_common,
            pub _M_pkey: _Node_handle___pointer,
            pub _M_pmapped: _Node_handle___pointer,
        }
        pub type _Node_handle_key_type<_Key> = _Key;
        pub type _Node_handle_mapped_type = [u8; 0usize];
        pub type _Node_handle__AllocTraits = allocator_traits;
        pub type _Node_handle___pointer = __ptr_rebind;
        impl Default for _Node_handle {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_insert_return<_Iterator, _NodeHandle> {
            pub position: _Iterator,
            pub inserted: bool,
            pub node: _NodeHandle,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeHandle>>,
        }
        impl<_Iterator, _NodeHandle> Default for _Node_insert_return<_Iterator, _NodeHandle> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Rb_tree_color {
            _S_red = 0,
            _S_black = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_node_base {
            pub _M_color: _Rb_tree_color,
            pub _M_parent: _Rb_tree_node_base__Base_ptr,
            pub _M_left: _Rb_tree_node_base__Base_ptr,
            pub _M_right: _Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr = *mut _Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr = *const _Rb_tree_node_base;
        #[test]
        fn bindgen_test_layout__Rb_tree_node_base() {
            assert_eq!(
                ::std::mem::size_of::<_Rb_tree_node_base>(),
                32usize,
                concat!("Size of: ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                ::std::mem::align_of::<_Rb_tree_node_base>(),
                8usize,
                concat!("Alignment of ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_color as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_color)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_parent as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_parent)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_left as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_left)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_right as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_right)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_minimum"]
            pub fn _Rb_tree_node_base__S_minimum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_minimum"]
            pub fn _Rb_tree_node_base__S_minimum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_maximum"]
            pub fn _Rb_tree_node_base__S_maximum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_maximum"]
            pub fn _Rb_tree_node_base__S_maximum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr;
        }
        impl Default for _Rb_tree_node_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl _Rb_tree_node_base {
            #[inline]
            pub unsafe fn _S_minimum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_minimum(__x)
            }
            #[inline]
            pub unsafe fn _S_minimum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_minimum1(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_maximum(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_maximum1(__x)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_key_compare<_Key_compare> {
            pub _M_key_compare: _Key_compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key_compare>>,
        }
        impl<_Key_compare> Default for _Rb_tree_key_compare<_Key_compare> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_node {
            pub _base: _Rb_tree_node_base,
            pub _M_storage: __aligned_membuf,
        }
        pub type _Rb_tree_node__Link_type = *mut _Rb_tree_node;
        impl Default for _Rb_tree_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_iterator {
            pub _M_node: _Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category = bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = _Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr = _Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut _Rb_tree_node;
        impl Default for _Rb_tree_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: _Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_iterator = _Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category = bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self = _Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr = _Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type = *const _Rb_tree_node;
        impl Default for _Rb_tree_const_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = [u8; 0usize];
        pub type _Rb_tree__Alloc_traits = __alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut _Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr = *const _Rb_tree_node_base;
        pub type _Rb_tree__Link_type = *mut _Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const _Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree__Reuse_or_alloc_node {
            pub _M_root: _Rb_tree__Base_ptr,
            pub _M_nodes: _Rb_tree__Base_ptr,
            pub _M_t: *mut _Rb_tree,
        }
        impl Default for _Rb_tree__Reuse_or_alloc_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree__Alloc_node {
            pub _M_t: *mut _Rb_tree,
        }
        impl Default for _Rb_tree__Alloc_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> = *mut _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> = *const _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> = *mut _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> = *const _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_size_type = usize;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator = reverse_iterator<_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator = reverse_iterator<_Rb_tree_const_iterator>;
        pub type _Rb_tree_node_type = _Node_handle;
        pub type _Rb_tree_insert_return_type = _Node_insert_return<_Iterator, _NodeHandle>;
        pub type _Rb_tree__Compatible_tree = _Rb_tree;
        pub type _Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
            _Rb_tree_key_compare<_Key_compare>;
        #[repr(C)]
        pub struct map {
            pub _M_t: map__Rep_type,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> = pair<_Key, _Tp>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct map_value_compare<_Compare> {
            pub comp: _Compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
        }
        impl<_Compare> Default for map_value_compare<_Compare> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type map__Pair_alloc_type = [u8; 0usize];
        pub type map__Rep_type = _Rb_tree;
        pub type map__Alloc_traits = __alloc_traits;
        pub type map_pointer = [u8; 0usize];
        pub type map_const_pointer = [u8; 0usize];
        pub type map_reference = [u8; 0usize];
        pub type map_const_reference = [u8; 0usize];
        pub type map_iterator = [u8; 0usize];
        pub type map_const_iterator = [u8; 0usize];
        pub type map_size_type = [u8; 0usize];
        pub type map_difference_type = [u8; 0usize];
        pub type map_reverse_iterator = [u8; 0usize];
        pub type map_const_reverse_iterator = [u8; 0usize];
        pub type map_node_type = [u8; 0usize];
        pub type map_insert_return_type = [u8; 0usize];
        impl Default for map {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for map {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "map {{ _M_t: {:?} }}", self._M_t)
            }
        }
        impl ::std::cmp::PartialEq for map {
            fn eq(&self, other: &map) -> bool {
                self._M_t == other._M_t
            }
        }
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: _Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: _Vector_base_pointer,
            pub _M_finish: _Vector_base_pointer,
            pub _M_end_of_storage: _Vector_base_pointer,
        }
        impl Default for _Vector_base__Vector_impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Vector_base__Vector_impl {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base__Vector_impl {{  }}")
            }
        }
        impl ::std::cmp::PartialEq for _Vector_base__Vector_impl {
            fn eq(&self, other: &_Vector_base__Vector_impl) -> bool {
                self._M_start == other._M_start
                    && self._M_finish == other._M_finish
                    && self._M_end_of_storage == other._M_end_of_storage
            }
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        impl Default for _Vector_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Vector_base {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        impl ::std::cmp::PartialEq for _Vector_base {
            fn eq(&self, other: &_Vector_base) -> bool {
                self._M_impl == other._M_impl
            }
        }
        #[repr(C)]
        pub struct vector {
            pub _base: _Vector_base,
        }
        pub type vector__Base = _Vector_base;
        pub type vector__Tp_alloc_type = vector__Base;
        pub type vector__Alloc_traits = __alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = vector__Base;
        pub type vector_const_pointer = vector__Alloc_traits;
        pub type vector_reference = vector__Alloc_traits;
        pub type vector_const_reference = vector__Alloc_traits;
        pub type vector_iterator = __normal_iterator<vector_pointer>;
        pub type vector_const_iterator = __normal_iterator<vector_const_pointer>;
        pub type vector_const_reverse_iterator = reverse_iterator<vector_const_iterator>;
        pub type vector_reverse_iterator = reverse_iterator<vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut vector,
            pub __buf: u8,
        }
        impl Default for vector__Temporary_value {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Default for vector {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for vector {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "vector {{  }}")
            }
        }
        impl ::std::cmp::PartialEq for vector {
            fn eq(&self, other: &vector) -> bool {
                self._base == other._base
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Deque_iterator {
            pub _M_cur: _Deque_iterator__Elt_pointer,
            pub _M_first: _Deque_iterator__Elt_pointer,
            pub _M_last: _Deque_iterator__Elt_pointer,
            pub _M_node: _Deque_iterator__Map_pointer,
        }
        pub type _Deque_iterator___ptr_to = pointer_traits;
        pub type _Deque_iterator___iter = _Deque_iterator;
        pub type _Deque_iterator_iterator = _Deque_iterator___iter;
        pub type _Deque_iterator_const_iterator = _Deque_iterator___iter;
        pub type _Deque_iterator__Elt_pointer = _Deque_iterator___ptr_to;
        pub type _Deque_iterator__Map_pointer = _Deque_iterator___ptr_to;
        pub type _Deque_iterator_iterator_category = random_access_iterator_tag;
        pub type _Deque_iterator_value_type<_Tp> = _Tp;
        pub type _Deque_iterator_pointer<_Ptr> = _Ptr;
        pub type _Deque_iterator_reference<_Ref> = _Ref;
        pub type _Deque_iterator_size_type = usize;
        pub type _Deque_iterator_difference_type = isize;
        pub type _Deque_iterator__Self = _Deque_iterator;
        impl Default for _Deque_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct _Deque_base {
            pub _M_impl: _Deque_base__Deque_impl,
        }
        pub type _Deque_base__Tp_alloc_type = [u8; 0usize];
        pub type _Deque_base__Alloc_traits = __alloc_traits;
        pub type _Deque_base__Ptr = [u8; 0usize];
        pub type _Deque_base__Ptr_const = [u8; 0usize];
        pub type _Deque_base__Map_alloc_type = [u8; 0usize];
        pub type _Deque_base__Map_alloc_traits = __alloc_traits;
        pub type _Deque_base_allocator_type<_Alloc> = _Alloc;
        pub type _Deque_base_size_type = [u8; 0usize];
        pub type _Deque_base_iterator = _Deque_iterator;
        pub type _Deque_base_const_iterator = _Deque_iterator;
        pub type _Deque_base__Map_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Deque_base__Deque_impl {
            pub _M_map: _Deque_base__Map_pointer,
            pub _M_map_size: usize,
            pub _M_start: _Deque_base_iterator,
            pub _M_finish: _Deque_base_iterator,
        }
        impl Default for _Deque_base__Deque_impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Deque_base__Deque_impl {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! ( f , "_Deque_base__Deque_impl {{ _M_map_size: {:?}, _M_start: {:?}, _M_finish: {:?} }}" , self . _M_map_size , self . _M_start , self . _M_finish )
            }
        }
        impl ::std::cmp::PartialEq for _Deque_base__Deque_impl {
            fn eq(&self, other: &_Deque_base__Deque_impl) -> bool {
                self._M_map == other._M_map
                    && self._M_map_size == other._M_map_size
                    && self._M_start == other._M_start
                    && self._M_finish == other._M_finish
            }
        }
        pub const _Deque_base__S_initial_map_size: _Deque_base__bindgen_ty_1 =
            _Deque_base__bindgen_ty_1::_S_initial_map_size;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Deque_base__bindgen_ty_1 {
            _S_initial_map_size = 0,
        }
        impl Default for _Deque_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Deque_base {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Deque_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        impl ::std::cmp::PartialEq for _Deque_base {
            fn eq(&self, other: &_Deque_base) -> bool {
                self._M_impl == other._M_impl
            }
        }
        #[repr(C)]
        pub struct deque {
            pub _base: _Deque_base,
        }
        pub type deque__Base = _Deque_base;
        pub type deque__Tp_alloc_type = deque__Base;
        pub type deque__Alloc_traits = deque__Base;
        pub type deque__Map_pointer = deque__Base;
        pub type deque_value_type<_Tp> = _Tp;
        pub type deque_pointer = deque__Alloc_traits;
        pub type deque_const_pointer = deque__Alloc_traits;
        pub type deque_reference = deque__Alloc_traits;
        pub type deque_const_reference = deque__Alloc_traits;
        pub type deque_iterator = deque__Base;
        pub type deque_const_iterator = deque__Base;
        pub type deque_const_reverse_iterator = reverse_iterator<deque_const_iterator>;
        pub type deque_reverse_iterator = reverse_iterator<deque_iterator>;
        pub type deque_size_type = usize;
        pub type deque_difference_type = isize;
        pub type deque_allocator_type<_Alloc> = _Alloc;
        impl Default for deque {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for deque {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "deque {{  }}")
            }
        }
        impl ::std::cmp::PartialEq for deque {
            fn eq(&self, other: &deque) -> bool {
                self._base == other._base
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct queue<_Sequence> {
            pub c: _Sequence,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sequence>>,
        }
        pub type queue__Uses = u8;
        pub type queue_value_type = [u8; 0usize];
        pub type queue_reference = [u8; 0usize];
        pub type queue_const_reference = [u8; 0usize];
        pub type queue_size_type = [u8; 0usize];
        pub type queue_container_type<_Sequence> = _Sequence;
        impl<_Sequence> Default for queue<_Sequence> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale {
            pub _M_impl: *mut locale__Impl,
        }
        pub type locale_category = ::std::os::raw::c_int;
        pub const locale__S_categories_size: locale__bindgen_ty_1 =
            locale__bindgen_ty_1::_S_categories_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum locale__bindgen_ty_1 {
            _S_categories_size = 12,
        }
        pub const locale_none: locale_category = 0;
        pub const locale_ctype: locale_category = 1;
        pub const locale_numeric: locale_category = 2;
        pub const locale_collate: locale_category = 4;
        pub const locale_time: locale_category = 8;
        pub const locale_monetary: locale_category = 16;
        pub const locale_messages: locale_category = 32;
        pub const locale_all: locale_category = 63;
        extern "C" {
            #[link_name = "\u{1}_S_classic"]
            pub static mut locale__S_classic: *mut locale__Impl;
        }
        extern "C" {
            #[link_name = "\u{1}_S_global"]
            pub static mut locale__S_global: *mut locale__Impl;
        }
        extern "C" {
            #[link_name = "\u{1}_S_categories"]
            pub static locale__S_categories: *const *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_S_once"]
            pub static mut locale__S_once: __gthread_once_t;
        }
        extern "C" {
            #[link_name = "\u{1}_S_twinned_facets"]
            pub static mut locale__S_twinned_facets: [*const locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale() {
            assert_eq!(
                ::std::mem::size_of::<locale>(),
                8usize,
                concat!("Size of: ", stringify!(locale))
            );
            assert_eq!(
                ::std::mem::align_of::<locale>(),
                8usize,
                concat!("Alignment of ", stringify!(locale))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale>()))._M_impl as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale),
                    "::",
                    stringify!(_M_impl)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}name"]
            pub fn locale_name(this: *const locale) -> string;
        }
        extern "C" {
            #[link_name = "\u{1}global"]
            pub fn locale_global(__loc: *const locale) -> locale;
        }
        extern "C" {
            #[link_name = "\u{1}classic"]
            pub fn locale_classic() -> *const locale;
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale(this: *mut locale);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale1(this: *mut locale, __other: *const locale);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale2(this: *mut locale, __s: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale3(
                this: *mut locale,
                __base: *const locale,
                __s: *const ::std::os::raw::c_char,
                __cat: locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale4(this: *mut locale, __s: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale5(
                this: *mut locale,
                __base: *const locale,
                __s: *const string,
                __cat: locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale6(
                this: *mut locale,
                __base: *const locale,
                __add: *const locale,
                __cat: locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}locale_destructor"]
            pub fn locale_locale_destructor(this: *mut locale);
        }
        impl Default for locale {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl locale {
            #[inline]
            pub unsafe fn name(&self) -> string {
                locale_name(self)
            }
            #[inline]
            pub unsafe fn global(__loc: *const locale) -> locale {
                locale_global(__loc)
            }
            #[inline]
            pub unsafe fn classic() -> *const locale {
                locale_classic()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__other: *const locale) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale1(&mut __bindgen_tmp, __other);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale2(&mut __bindgen_tmp, __s);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                __base: *const locale,
                __s: *const ::std::os::raw::c_char,
                __cat: locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale3(&mut __bindgen_tmp, __base, __s, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(__s: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale4(&mut __bindgen_tmp, __s);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                __base: *const locale,
                __s: *const string,
                __cat: locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale5(&mut __bindgen_tmp, __base, __s, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new6(
                __base: *const locale,
                __add: *const locale,
                __cat: locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale6(&mut __bindgen_tmp, __base, __add, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                locale_locale_destructor(self)
            }
        }
        #[repr(C)]
        pub struct locale_facet__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale_facet {
            pub vtable_: *const locale_facet__bindgen_vtable,
            pub _M_refcount: _Atomic_word,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct locale_facet___shim {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_S_c_locale"]
            pub static mut locale_facet__S_c_locale: __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_c_name"]
            pub static mut locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_once"]
            pub static mut locale_facet__S_once: __gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale_facet() {
            assert_eq!(
                ::std::mem::size_of::<locale_facet>(),
                16usize,
                concat!("Size of: ", stringify!(locale_facet))
            );
            assert_eq!(
                ::std::mem::align_of::<locale_facet>(),
                8usize,
                concat!("Alignment of ", stringify!(locale_facet))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale_facet>()))._M_refcount as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale_facet),
                    "::",
                    stringify!(_M_refcount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_create_c_locale"]
            pub fn locale_facet__S_create_c_locale(
                __cloc: *mut __c_locale,
                __s: *const ::std::os::raw::c_char,
                __old: __c_locale,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_clone_c_locale"]
            pub fn locale_facet__S_clone_c_locale(__cloc: *mut __c_locale) -> __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_destroy_c_locale"]
            pub fn locale_facet__S_destroy_c_locale(__cloc: *mut __c_locale);
        }
        extern "C" {
            #[link_name = "\u{1}_S_lc_ctype_c_locale"]
            pub fn locale_facet__S_lc_ctype_c_locale(
                __cloc: __c_locale,
                __s: *const ::std::os::raw::c_char,
            ) -> __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_get_c_locale"]
            pub fn locale_facet__S_get_c_locale() -> __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_get_c_name"]
            pub fn locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}facet"]
            pub fn locale_facet_facet(this: *mut locale_facet, __refs: usize);
        }
        extern "C" {
            #[link_name = "\u{1}facet"]
            pub fn locale_facet_facet1(this: *mut locale_facet, arg1: *const locale_facet);
        }
        impl Default for locale_facet {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl locale_facet {
            #[inline]
            pub unsafe fn _S_create_c_locale(
                __cloc: *mut __c_locale,
                __s: *const ::std::os::raw::c_char,
                __old: __c_locale,
            ) {
                locale_facet__S_create_c_locale(__cloc, __s, __old)
            }
            #[inline]
            pub unsafe fn _S_clone_c_locale(__cloc: *mut __c_locale) -> __c_locale {
                locale_facet__S_clone_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_destroy_c_locale(__cloc: *mut __c_locale) {
                locale_facet__S_destroy_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_lc_ctype_c_locale(
                __cloc: __c_locale,
                __s: *const ::std::os::raw::c_char,
            ) -> __c_locale {
                locale_facet__S_lc_ctype_c_locale(__cloc, __s)
            }
            #[inline]
            pub unsafe fn _S_get_c_locale() -> __c_locale {
                locale_facet__S_get_c_locale()
            }
            #[inline]
            pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
                locale_facet__S_get_c_name()
            }
            #[inline]
            pub unsafe fn new(__refs: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_facet_facet(&mut __bindgen_tmp, __refs);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const locale_facet) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_facet_facet1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}facet_destructor"]
            pub fn locale_facet_facet_destructor(this: *mut locale_facet);
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale_id {
            pub _M_index: usize,
        }
        extern "C" {
            #[link_name = "\u{1}_S_refcount"]
            pub static mut locale_id__S_refcount: _Atomic_word;
        }
        #[test]
        fn bindgen_test_layout_locale_id() {
            assert_eq!(
                ::std::mem::size_of::<locale_id>(),
                8usize,
                concat!("Size of: ", stringify!(locale_id))
            );
            assert_eq!(
                ::std::mem::align_of::<locale_id>(),
                8usize,
                concat!("Alignment of ", stringify!(locale_id))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale_id>()))._M_index as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale_id),
                    "::",
                    stringify!(_M_index)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_M_id"]
            pub fn locale_id__M_id(this: *const locale_id) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}id"]
            pub fn locale_id_id(this: *mut locale_id);
        }
        impl locale_id {
            #[inline]
            pub unsafe fn _M_id(&self) -> usize {
                locale_id__M_id(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_id_id(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale__Impl {
            pub _M_refcount: _Atomic_word,
            pub _M_facets: *mut *const locale_facet,
            pub _M_facets_size: usize,
            pub _M_caches: *mut *const locale_facet,
            pub _M_names: *mut *mut ::std::os::raw::c_char,
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_ctype"]
            pub static mut locale__Impl__S_id_ctype: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_numeric"]
            pub static mut locale__Impl__S_id_numeric: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_collate"]
            pub static mut locale__Impl__S_id_collate: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_time"]
            pub static mut locale__Impl__S_id_time: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_monetary"]
            pub static mut locale__Impl__S_id_monetary: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_messages"]
            pub static mut locale__Impl__S_id_messages: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_facet_categories"]
            pub static mut locale__Impl__S_facet_categories: [*const *const locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale__Impl() {
            assert_eq!(
                ::std::mem::size_of::<locale__Impl>(),
                40usize,
                concat!("Size of: ", stringify!(locale__Impl))
            );
            assert_eq!(
                ::std::mem::align_of::<locale__Impl>(),
                8usize,
                concat!("Alignment of ", stringify!(locale__Impl))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale__Impl>()))._M_refcount as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_refcount)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_facets as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_facets)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale__Impl>()))._M_facets_size as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_facets_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_caches as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_caches)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_names as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_names)
                )
            );
        }
        impl Default for locale__Impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub mod _V2 {

            #[repr(C)]
            pub struct error_category__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
            pub struct error_category {
                pub vtable_: *const error_category__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_error_category() {
                assert_eq!(
                    ::std::mem::size_of::<error_category>(),
                    8usize,
                    concat!("Size of: ", stringify!(error_category))
                );
                assert_eq!(
                    ::std::mem::align_of::<error_category>(),
                    8usize,
                    concat!("Alignment of ", stringify!(error_category))
                );
            }
            extern "C" {
                #[link_name = "\u{1}error_category"]
                pub fn error_category_error_category(this: *mut error_category);
            }
            extern "C" {
                #[link_name = "\u{1}error_category"]
                pub fn error_category_error_category1(
                    this: *mut error_category,
                    arg1: *const error_category,
                );
            }
            impl Default for error_category {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl error_category {
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    error_category_error_category(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(arg1: *const error_category) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    error_category_error_category1(&mut __bindgen_tmp, arg1);
                    __bindgen_tmp
                }
            }
            extern "C" {
                #[link_name = "\u{1}error_category_destructor"]
                pub fn error_category_error_category_destructor(this: *mut error_category);
            }
            extern "C" {
                #[link_name = "\u{1}default_error_condition"]
                pub fn error_category_default_error_condition(
                    this: *mut ::std::os::raw::c_void,
                    __i: ::std::os::raw::c_int,
                ) -> error_condition;
            }
            extern "C" {
                #[link_name = "\u{1}equivalent"]
                pub fn error_category_equivalent(
                    this: *mut ::std::os::raw::c_void,
                    __i: ::std::os::raw::c_int,
                    __cond: *const error_condition,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}equivalent"]
                pub fn error_category_equivalent1(
                    this: *mut ::std::os::raw::c_void,
                    __code: *const error_code,
                    __i: ::std::os::raw::c_int,
                ) -> bool;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct error_code {
            pub _M_value: ::std::os::raw::c_int,
            pub _M_cat: *const error_category,
        }
        #[test]
        fn bindgen_test_layout_error_code() {
            assert_eq!(
                ::std::mem::size_of::<error_code>(),
                16usize,
                concat!("Size of: ", stringify!(error_code))
            );
            assert_eq!(
                ::std::mem::align_of::<error_code>(),
                8usize,
                concat!("Alignment of ", stringify!(error_code))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_code>()))._M_value as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_code),
                    "::",
                    stringify!(_M_value)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_code>()))._M_cat as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_code),
                    "::",
                    stringify!(_M_cat)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}assign"]
            pub fn error_code_assign(
                this: *mut error_code,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}clear"]
            pub fn error_code_clear(this: *mut error_code);
        }
        extern "C" {
            #[link_name = "\u{1}value"]
            pub fn error_code_value(this: *const error_code) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}category"]
            pub fn error_code_category(this: *const error_code) -> *const error_category;
        }
        extern "C" {
            #[link_name = "\u{1}default_error_condition"]
            pub fn error_code_default_error_condition(this: *const error_code) -> error_condition;
        }
        extern "C" {
            #[link_name = "\u{1}message"]
            pub fn error_code_message(this: *const error_code) -> string;
        }
        extern "C" {
            #[link_name = "\u{1}error_code"]
            pub fn error_code_error_code(this: *mut error_code);
        }
        extern "C" {
            #[link_name = "\u{1}error_code"]
            pub fn error_code_error_code1(
                this: *mut error_code,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        impl Default for error_code {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl error_code {
            #[inline]
            pub unsafe fn assign(
                &mut self,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            ) {
                error_code_assign(self, __v, __cat)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                error_code_clear(self)
            }
            #[inline]
            pub unsafe fn value(&self) -> ::std::os::raw::c_int {
                error_code_value(self)
            }
            #[inline]
            pub unsafe fn category(&self) -> *const error_category {
                error_code_category(self)
            }
            #[inline]
            pub unsafe fn default_error_condition(&self) -> error_condition {
                error_code_default_error_condition(self)
            }
            #[inline]
            pub unsafe fn message(&self) -> string {
                error_code_message(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_code_error_code(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__v: ::std::os::raw::c_int, __cat: *const error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_code_error_code1(&mut __bindgen_tmp, __v, __cat);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct error_condition {
            pub _M_value: ::std::os::raw::c_int,
            pub _M_cat: *const error_category,
        }
        #[test]
        fn bindgen_test_layout_error_condition() {
            assert_eq!(
                ::std::mem::size_of::<error_condition>(),
                16usize,
                concat!("Size of: ", stringify!(error_condition))
            );
            assert_eq!(
                ::std::mem::align_of::<error_condition>(),
                8usize,
                concat!("Alignment of ", stringify!(error_condition))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<error_condition>()))._M_value as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_condition),
                    "::",
                    stringify!(_M_value)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_condition>()))._M_cat as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_condition),
                    "::",
                    stringify!(_M_cat)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}assign"]
            pub fn error_condition_assign(
                this: *mut error_condition,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}clear"]
            pub fn error_condition_clear(this: *mut error_condition);
        }
        extern "C" {
            #[link_name = "\u{1}value"]
            pub fn error_condition_value(this: *const error_condition) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}category"]
            pub fn error_condition_category(this: *const error_condition) -> *const error_category;
        }
        extern "C" {
            #[link_name = "\u{1}message"]
            pub fn error_condition_message(this: *const error_condition) -> string;
        }
        extern "C" {
            #[link_name = "\u{1}error_condition"]
            pub fn error_condition_error_condition(this: *mut error_condition);
        }
        extern "C" {
            #[link_name = "\u{1}error_condition"]
            pub fn error_condition_error_condition1(
                this: *mut error_condition,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        impl Default for error_condition {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl error_condition {
            #[inline]
            pub unsafe fn assign(
                &mut self,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            ) {
                error_condition_assign(self, __v, __cat)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                error_condition_clear(self)
            }
            #[inline]
            pub unsafe fn value(&self) -> ::std::os::raw::c_int {
                error_condition_value(self)
            }
            #[inline]
            pub unsafe fn category(&self) -> *const error_category {
                error_condition_category(self)
            }
            #[inline]
            pub unsafe fn message(&self) -> string {
                error_condition_message(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_condition_error_condition(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__v: ::std::os::raw::c_int, __cat: *const error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_condition_error_condition1(&mut __bindgen_tmp, __v, __cat);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        pub struct system_error {
            pub _base: runtime_error,
            pub _M_code: error_code,
        }
        #[test]
        fn bindgen_test_layout_system_error() {
            assert_eq!(
                ::std::mem::size_of::<system_error>(),
                32usize,
                concat!("Size of: ", stringify!(system_error))
            );
            assert_eq!(
                ::std::mem::align_of::<system_error>(),
                8usize,
                concat!("Alignment of ", stringify!(system_error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<system_error>()))._M_code as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(system_error),
                    "::",
                    stringify!(_M_code)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}code"]
            pub fn system_error_code(this: *const system_error) -> *const error_code;
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error(this: *mut system_error, __ec: error_code);
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error1(
                this: *mut system_error,
                __ec: error_code,
                __what: *const string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error2(
                this: *mut system_error,
                __ec: error_code,
                __what: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error3(
                this: *mut system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error4(
                this: *mut system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error5(
                this: *mut system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const string,
            );
        }
        impl Default for system_error {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for system_error {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "system_error {{ _M_code: {:?} }}", self._M_code)
            }
        }
        impl system_error {
            #[inline]
            pub unsafe fn code(&self) -> *const error_code {
                system_error_code(self)
            }
            #[inline]
            pub unsafe fn new(__ec: error_code) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error(&mut __bindgen_tmp, __ec);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__ec: error_code, __what: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error1(&mut __bindgen_tmp, __ec, __what);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(__ec: error_code, __what: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error2(&mut __bindgen_tmp, __ec, __what);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error3(&mut __bindgen_tmp, __v, __ecat, __what);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(__v: ::std::os::raw::c_int, __ecat: *const error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error4(&mut __bindgen_tmp, __v, __ecat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const string,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error5(&mut __bindgen_tmp, __v, __ecat, __what);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}system_error_destructor"]
            pub fn system_error_system_error_destructor(this: *mut system_error);
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Fmtflags {
            _S_boolalpha = 1,
            _S_dec = 2,
            _S_fixed = 4,
            _S_hex = 8,
            _S_internal = 16,
            _S_left = 32,
            _S_oct = 64,
            _S_right = 128,
            _S_scientific = 256,
            _S_showbase = 512,
            _S_showpoint = 1024,
            _S_showpos = 2048,
            _S_skipws = 4096,
            _S_unitbuf = 8192,
            _S_uppercase = 16384,
            _S_adjustfield = 176,
            _S_basefield = 74,
            _S_floatfield = 260,
            _S_ios_fmtflags_end = 65536,
            _S_ios_fmtflags_max = 2147483647,
            _S_ios_fmtflags_min = -2147483648,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Openmode {
            _S_app = 1,
            _S_ate = 2,
            _S_bin = 4,
            _S_in = 8,
            _S_out = 16,
            _S_trunc = 32,
            _S_ios_openmode_end = 65536,
            _S_ios_openmode_max = 2147483647,
            _S_ios_openmode_min = -2147483648,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Iostate {
            _S_goodbit = 0,
            _S_badbit = 1,
            _S_eofbit = 2,
            _S_failbit = 4,
            _S_ios_iostate_end = 65536,
            _S_ios_iostate_max = 2147483647,
            _S_ios_iostate_min = -2147483648,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Seekdir {
            _S_beg = 0,
            _S_cur = 1,
            _S_end = 2,
            _S_ios_seekdir_end = 65536,
        }
        #[repr(C)]
        pub struct ios_base__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base {
            pub vtable_: *const ios_base__bindgen_vtable,
            pub _M_precision: streamsize,
            pub _M_width: streamsize,
            pub _M_flags: ios_base_fmtflags,
            pub _M_exception: ios_base_iostate,
            pub _M_streambuf_state: ios_base_iostate,
            pub _M_callbacks: *mut ios_base__Callback_list,
            pub _M_word_zero: ios_base__Words,
            pub _M_local_word: [ios_base__Words; 8usize],
            pub _M_word_size: ::std::os::raw::c_int,
            pub _M_word: *mut ios_base__Words,
            pub _M_ios_locale: locale,
        }
        #[repr(C)]
        pub struct ios_base_failure {
            pub _base: system_error,
        }
        #[test]
        fn bindgen_test_layout_ios_base_failure() {
            assert_eq!(
                ::std::mem::size_of::<ios_base_failure>(),
                32usize,
                concat!("Size of: ", stringify!(ios_base_failure))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base_failure>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base_failure))
            );
        }
        extern "C" {
            #[link_name = "\u{1}failure"]
            pub fn ios_base_failure_failure(this: *mut ios_base_failure, __str: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}failure"]
            pub fn ios_base_failure_failure1(
                this: *mut ios_base_failure,
                arg1: *const string,
                arg2: *const error_code,
            );
        }
        extern "C" {
            #[link_name = "\u{1}failure"]
            pub fn ios_base_failure_failure2(
                this: *mut ios_base_failure,
                arg1: *const ::std::os::raw::c_char,
                arg2: *const error_code,
            );
        }
        impl Default for ios_base_failure {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for ios_base_failure {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "ios_base_failure {{  }}")
            }
        }
        impl ios_base_failure {
            #[inline]
            pub unsafe fn new(__str: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure(&mut __bindgen_tmp, __str);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const string, arg2: *const error_code) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure1(&mut __bindgen_tmp, arg1, arg2);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const error_code,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure2(&mut __bindgen_tmp, arg1, arg2);
                __bindgen_tmp
            }
        }
        pub use _Ios_Fmtflags as ios_base_fmtflags;
        pub use _Ios_Iostate as ios_base_iostate;
        pub use _Ios_Openmode as ios_base_openmode;
        pub use _Ios_Seekdir as ios_base_seekdir;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum ios_base_event {
            erase_event = 0,
            imbue_event = 1,
            copyfmt_event = 2,
        }
        pub type ios_base_event_callback = ::std::option::Option<
            unsafe extern "C" fn(
                __e: ios_base_event,
                __b: *mut ios_base,
                __i: ::std::os::raw::c_int,
            ),
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base__Callback_list {
            pub _M_next: *mut ios_base__Callback_list,
            pub _M_fn: ios_base_event_callback,
            pub _M_index: ::std::os::raw::c_int,
            pub _M_refcount: _Atomic_word,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Callback_list() {
            assert_eq!(
                ::std::mem::size_of::<ios_base__Callback_list>(),
                24usize,
                concat!("Size of: ", stringify!(ios_base__Callback_list))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base__Callback_list>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base__Callback_list))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_next as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_next)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_fn as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_fn)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_index as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_index)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_refcount as *const _
                        as usize
                },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_refcount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_M_add_reference"]
            pub fn ios_base__Callback_list__M_add_reference(this: *mut ios_base__Callback_list);
        }
        extern "C" {
            #[link_name = "\u{1}_M_remove_reference"]
            pub fn ios_base__Callback_list__M_remove_reference(
                this: *mut ios_base__Callback_list,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_Callback_list"]
            pub fn ios_base__Callback_list__Callback_list(
                this: *mut ios_base__Callback_list,
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
                __cb: *mut ios_base__Callback_list,
            );
        }
        impl Default for ios_base__Callback_list {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ios_base__Callback_list {
            #[inline]
            pub unsafe fn _M_add_reference(&mut self) {
                ios_base__Callback_list__M_add_reference(self)
            }
            #[inline]
            pub unsafe fn _M_remove_reference(&mut self) -> ::std::os::raw::c_int {
                ios_base__Callback_list__M_remove_reference(self)
            }
            #[inline]
            pub unsafe fn new(
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
                __cb: *mut ios_base__Callback_list,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base__Callback_list__Callback_list(&mut __bindgen_tmp, __fn, __index, __cb);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base__Words {
            pub _M_pword: *mut ::std::os::raw::c_void,
            pub _M_iword: ::std::os::raw::c_long,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Words() {
            assert_eq!(
                ::std::mem::size_of::<ios_base__Words>(),
                16usize,
                concat!("Size of: ", stringify!(ios_base__Words))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base__Words>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base__Words))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Words>()))._M_pword as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Words),
                    "::",
                    stringify!(_M_pword)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Words>()))._M_iword as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Words),
                    "::",
                    stringify!(_M_iword)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_Words"]
            pub fn ios_base__Words__Words(this: *mut ios_base__Words);
        }
        impl Default for ios_base__Words {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ios_base__Words {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base__Words__Words(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        pub const ios_base__S_local_word_size: ios_base__bindgen_ty_1 =
            ios_base__bindgen_ty_1::_S_local_word_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum ios_base__bindgen_ty_1 {
            _S_local_word_size = 8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base_Init {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}_S_refcount"]
            pub static mut ios_base_Init__S_refcount: _Atomic_word;
        }
        extern "C" {
            #[link_name = "\u{1}_S_synced_with_stdio"]
            pub static mut ios_base_Init__S_synced_with_stdio: bool;
        }
        #[test]
        fn bindgen_test_layout_ios_base_Init() {
            assert_eq!(
                ::std::mem::size_of::<ios_base_Init>(),
                1usize,
                concat!("Size of: ", stringify!(ios_base_Init))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base_Init>(),
                1usize,
                concat!("Alignment of ", stringify!(ios_base_Init))
            );
        }
        extern "C" {
            #[link_name = "\u{1}Init"]
            pub fn ios_base_Init_Init(this: *mut ios_base_Init);
        }
        extern "C" {
            #[link_name = "\u{1}Init_destructor"]
            pub fn ios_base_Init_Init_destructor(this: *mut ios_base_Init);
        }
        impl ios_base_Init {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_Init_Init(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ios_base_Init_Init_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}boolalpha"]
            pub static ios_base_boolalpha: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}dec"]
            pub static ios_base_dec: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}fixed"]
            pub static ios_base_fixed: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}hex"]
            pub static ios_base_hex: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}internal"]
            pub static ios_base_internal: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}left"]
            pub static ios_base_left: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}oct"]
            pub static ios_base_oct: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}right"]
            pub static ios_base_right: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}scientific"]
            pub static ios_base_scientific: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}showbase"]
            pub static ios_base_showbase: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}showpoint"]
            pub static ios_base_showpoint: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}showpos"]
            pub static ios_base_showpos: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}skipws"]
            pub static ios_base_skipws: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}unitbuf"]
            pub static ios_base_unitbuf: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}uppercase"]
            pub static ios_base_uppercase: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}adjustfield"]
            pub static ios_base_adjustfield: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}basefield"]
            pub static ios_base_basefield: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}floatfield"]
            pub static ios_base_floatfield: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}badbit"]
            pub static ios_base_badbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}eofbit"]
            pub static ios_base_eofbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}failbit"]
            pub static ios_base_failbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}goodbit"]
            pub static ios_base_goodbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}app"]
            pub static ios_base_app: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}ate"]
            pub static ios_base_ate: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}binary"]
            pub static ios_base_binary: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}in"]
            pub static ios_base_in: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}out"]
            pub static ios_base_out: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}trunc"]
            pub static ios_base_trunc: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}beg"]
            pub static ios_base_beg: ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "\u{1}cur"]
            pub static ios_base_cur: ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "\u{1}end"]
            pub static ios_base_end: ios_base_seekdir;
        }
        #[test]
        fn bindgen_test_layout_ios_base() {
            assert_eq!(
                ::std::mem::size_of::<ios_base>(),
                216usize,
                concat!("Size of: ", stringify!(ios_base))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_precision as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_precision)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_width as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_width)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_flags as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_flags)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_exception as *const _ as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_exception)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base>()))._M_streambuf_state as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_streambuf_state)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_callbacks as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_callbacks)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_zero as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word_zero)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_local_word as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_local_word)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_size as *const _ as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word as *const _ as usize },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_ios_locale as *const _ as usize },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_ios_locale)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}register_callback"]
            pub fn ios_base_register_callback(
                this: *mut ios_base,
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_M_call_callbacks"]
            pub fn ios_base__M_call_callbacks(this: *mut ios_base, __ev: ios_base_event);
        }
        extern "C" {
            #[link_name = "\u{1}_M_dispose_callbacks"]
            pub fn ios_base__M_dispose_callbacks(this: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_M_grow_words"]
            pub fn ios_base__M_grow_words(
                this: *mut ios_base,
                __index: ::std::os::raw::c_int,
                __iword: bool,
            ) -> *mut ios_base__Words;
        }
        extern "C" {
            #[link_name = "\u{1}_M_init"]
            pub fn ios_base__M_init(this: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}flags"]
            pub fn ios_base_flags(this: *const ios_base) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}flags"]
            pub fn ios_base_flags1(
                this: *mut ios_base,
                __fmtfl: ios_base_fmtflags,
            ) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}setf"]
            pub fn ios_base_setf(
                this: *mut ios_base,
                __fmtfl: ios_base_fmtflags,
            ) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}setf"]
            pub fn ios_base_setf1(
                this: *mut ios_base,
                __fmtfl: ios_base_fmtflags,
                __mask: ios_base_fmtflags,
            ) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}unsetf"]
            pub fn ios_base_unsetf(this: *mut ios_base, __mask: ios_base_fmtflags);
        }
        extern "C" {
            #[link_name = "\u{1}precision"]
            pub fn ios_base_precision(this: *const ios_base) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}precision"]
            pub fn ios_base_precision1(this: *mut ios_base, __prec: streamsize) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}width"]
            pub fn ios_base_width(this: *const ios_base) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}width"]
            pub fn ios_base_width1(this: *mut ios_base, __wide: streamsize) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}sync_with_stdio"]
            pub fn ios_base_sync_with_stdio(__sync: bool) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}imbue"]
            pub fn ios_base_imbue(this: *mut ios_base, __loc: *const locale) -> locale;
        }
        extern "C" {
            #[link_name = "\u{1}getloc"]
            pub fn ios_base_getloc(this: *const ios_base) -> locale;
        }
        extern "C" {
            #[link_name = "\u{1}_M_getloc"]
            pub fn ios_base__M_getloc(this: *const ios_base) -> *const locale;
        }
        extern "C" {
            #[link_name = "\u{1}xalloc"]
            pub fn ios_base_xalloc() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}iword"]
            pub fn ios_base_iword(
                this: *mut ios_base,
                __ix: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}pword"]
            pub fn ios_base_pword(
                this: *mut ios_base,
                __ix: ::std::os::raw::c_int,
            ) -> *mut *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_M_move"]
            pub fn ios_base__M_move(this: *mut ios_base, arg1: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_M_swap"]
            pub fn ios_base__M_swap(this: *mut ios_base, __rhs: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}ios_base"]
            pub fn ios_base_ios_base(this: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}ios_base"]
            pub fn ios_base_ios_base1(this: *mut ios_base, arg1: *const ios_base);
        }
        impl Default for ios_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ios_base {
            #[inline]
            pub unsafe fn register_callback(
                &mut self,
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
            ) {
                ios_base_register_callback(self, __fn, __index)
            }
            #[inline]
            pub unsafe fn _M_call_callbacks(&mut self, __ev: ios_base_event) {
                ios_base__M_call_callbacks(self, __ev)
            }
            #[inline]
            pub unsafe fn _M_dispose_callbacks(&mut self) {
                ios_base__M_dispose_callbacks(self)
            }
            #[inline]
            pub unsafe fn _M_grow_words(
                &mut self,
                __index: ::std::os::raw::c_int,
                __iword: bool,
            ) -> *mut ios_base__Words {
                ios_base__M_grow_words(self, __index, __iword)
            }
            #[inline]
            pub unsafe fn _M_init(&mut self) {
                ios_base__M_init(self)
            }
            #[inline]
            pub unsafe fn flags(&self) -> ios_base_fmtflags {
                ios_base_flags(self)
            }
            #[inline]
            pub unsafe fn flags1(&mut self, __fmtfl: ios_base_fmtflags) -> ios_base_fmtflags {
                ios_base_flags1(self, __fmtfl)
            }
            #[inline]
            pub unsafe fn setf(&mut self, __fmtfl: ios_base_fmtflags) -> ios_base_fmtflags {
                ios_base_setf(self, __fmtfl)
            }
            #[inline]
            pub unsafe fn setf1(
                &mut self,
                __fmtfl: ios_base_fmtflags,
                __mask: ios_base_fmtflags,
            ) -> ios_base_fmtflags {
                ios_base_setf1(self, __fmtfl, __mask)
            }
            #[inline]
            pub unsafe fn unsetf(&mut self, __mask: ios_base_fmtflags) {
                ios_base_unsetf(self, __mask)
            }
            #[inline]
            pub unsafe fn precision(&self) -> streamsize {
                ios_base_precision(self)
            }
            #[inline]
            pub unsafe fn precision1(&mut self, __prec: streamsize) -> streamsize {
                ios_base_precision1(self, __prec)
            }
            #[inline]
            pub unsafe fn width(&self) -> streamsize {
                ios_base_width(self)
            }
            #[inline]
            pub unsafe fn width1(&mut self, __wide: streamsize) -> streamsize {
                ios_base_width1(self, __wide)
            }
            #[inline]
            pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
                ios_base_sync_with_stdio(__sync)
            }
            #[inline]
            pub unsafe fn imbue(&mut self, __loc: *const locale) -> locale {
                ios_base_imbue(self, __loc)
            }
            #[inline]
            pub unsafe fn getloc(&self) -> locale {
                ios_base_getloc(self)
            }
            #[inline]
            pub unsafe fn _M_getloc(&self) -> *const locale {
                ios_base__M_getloc(self)
            }
            #[inline]
            pub unsafe fn xalloc() -> ::std::os::raw::c_int {
                ios_base_xalloc()
            }
            #[inline]
            pub unsafe fn iword(
                &mut self,
                __ix: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_long {
                ios_base_iword(self, __ix)
            }
            #[inline]
            pub unsafe fn pword(
                &mut self,
                __ix: ::std::os::raw::c_int,
            ) -> *mut *mut ::std::os::raw::c_void {
                ios_base_pword(self, __ix)
            }
            #[inline]
            pub unsafe fn _M_move(&mut self, arg1: *mut ios_base) {
                ios_base__M_move(self, arg1)
            }
            #[inline]
            pub unsafe fn _M_swap(&mut self, __rhs: *mut ios_base) {
                ios_base__M_swap(self, __rhs)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_ios_base(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const ios_base) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_ios_base1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}failure_destructor"]
            pub fn ios_base_failure_failure_destructor(this: *mut ios_base_failure);
        }
        extern "C" {
            #[link_name = "\u{1}what"]
            pub fn ios_base_failure_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}ios_base_destructor"]
            pub fn ios_base_ios_base_destructor(this: *mut ios_base);
        }
        #[repr(C)]
        pub struct basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_streambuf<_CharT> {
            pub vtable_: *const basic_streambuf__bindgen_vtable,
            pub _M_in_beg: *mut basic_streambuf_char_type<_CharT>,
            pub _M_in_cur: *mut basic_streambuf_char_type<_CharT>,
            pub _M_in_end: *mut basic_streambuf_char_type<_CharT>,
            pub _M_out_beg: *mut basic_streambuf_char_type<_CharT>,
            pub _M_out_cur: *mut basic_streambuf_char_type<_CharT>,
            pub _M_out_end: *mut basic_streambuf_char_type<_CharT>,
            pub _M_buf_locale: locale,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_streambuf_char_type<_CharT> = _CharT;
        pub type basic_streambuf_traits_type<_Traits> = _Traits;
        pub type basic_streambuf_int_type = [u8; 0usize];
        pub type basic_streambuf_pos_type = [u8; 0usize];
        pub type basic_streambuf_off_type = [u8; 0usize];
        pub type basic_streambuf___streambuf_type<_CharT> =
            basic_streambuf<basic_streambuf_char_type<_CharT>>;
        impl<_CharT> Default for basic_streambuf<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ctype_base {
            pub _address: u8,
        }
        pub type ctype_base___to_type = *const ::std::os::raw::c_int;
        pub type ctype_base_mask = ::std::os::raw::c_ushort;
        pub const ctype_base_upper: ctype_base_mask = 256;
        pub const ctype_base_lower: ctype_base_mask = 512;
        pub const ctype_base_alpha: ctype_base_mask = 1024;
        pub const ctype_base_digit: ctype_base_mask = 2048;
        pub const ctype_base_xdigit: ctype_base_mask = 4096;
        pub const ctype_base_space: ctype_base_mask = 8192;
        pub const ctype_base_print: ctype_base_mask = 16384;
        pub const ctype_base_graph: ctype_base_mask = 3076;
        pub const ctype_base_cntrl: ctype_base_mask = 2;
        pub const ctype_base_punct: ctype_base_mask = 4;
        pub const ctype_base_alnum: ctype_base_mask = 3072;
        pub const ctype_base_blank: ctype_base_mask = 1;
        #[test]
        fn bindgen_test_layout_ctype_base() {
            assert_eq!(
                ::std::mem::size_of::<ctype_base>(),
                1usize,
                concat!("Size of: ", stringify!(ctype_base))
            );
            assert_eq!(
                ::std::mem::align_of::<ctype_base>(),
                1usize,
                concat!("Alignment of ", stringify!(ctype_base))
            );
        }
        #[repr(C)]
        pub struct istreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut istreambuf_iterator_streambuf_type<_CharT>,
            pub _M_c: istreambuf_iterator_int_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type istreambuf_iterator_char_type<_CharT> = _CharT;
        pub type istreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type istreambuf_iterator_int_type = [u8; 0usize];
        pub type istreambuf_iterator_streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type istreambuf_iterator_istream_type<_CharT> = basic_istream<_CharT>;
        impl<_CharT> Default for istreambuf_iterator<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for istreambuf_iterator<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "istreambuf_iterator {{ _M_sbuf: {:?} }}", self._M_sbuf)
            }
        }
        impl<_CharT> ::std::cmp::PartialEq for istreambuf_iterator<_CharT>
        where
            _CharT: PartialEq,
        {
            fn eq(&self, other: &istreambuf_iterator<_CharT>) -> bool {
                self._M_sbuf == other._M_sbuf && self._M_c == other._M_c
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ostreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut ostreambuf_iterator_streambuf_type<_CharT>,
            pub _M_failed: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type ostreambuf_iterator_char_type<_CharT> = _CharT;
        pub type ostreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type ostreambuf_iterator_streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type ostreambuf_iterator_ostream_type<_CharT> = basic_ostream<_CharT>;
        impl<_CharT> Default for ostreambuf_iterator<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __ctype_abstract_base {
            pub _base: locale_facet,
        }
        pub type __ctype_abstract_base_char_type<_CharT> = _CharT;
        impl Default for __ctype_abstract_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ctype {
            pub _base: __ctype_abstract_base,
        }
        pub type ctype_char_type<_CharT> = _CharT;
        pub type ctype_mask = __ctype_abstract_base;
        impl Default for ctype {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct num_get {
            pub _base: locale_facet,
        }
        pub type num_get_char_type<_CharT> = _CharT;
        pub type num_get_iter_type<_InIter> = _InIter;
        impl Default for num_get {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct num_put {
            pub _base: locale_facet,
        }
        pub type num_put_char_type<_CharT> = _CharT;
        pub type num_put_iter_type<_OutIter> = _OutIter;
        impl Default for num_put {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_ios<_CharT> {
            pub _base: ios_base,
            pub _M_tie: *mut basic_ostream<_CharT>,
            pub _M_fill: basic_ios_char_type<_CharT>,
            pub _M_fill_init: bool,
            pub _M_streambuf: *mut basic_streambuf<_CharT>,
            pub _M_ctype: *const basic_ios___ctype_type,
            pub _M_num_put: *const basic_ios___num_put_type,
            pub _M_num_get: *const basic_ios___num_get_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_ios_char_type<_CharT> = _CharT;
        pub type basic_ios_int_type = [u8; 0usize];
        pub type basic_ios_pos_type = [u8; 0usize];
        pub type basic_ios_off_type = [u8; 0usize];
        pub type basic_ios_traits_type<_Traits> = _Traits;
        pub type basic_ios___ctype_type = ctype;
        pub type basic_ios___num_put_type = num_put;
        pub type basic_ios___num_get_type = num_get;
        impl<_CharT> Default for basic_ios<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_ostream<_CharT> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_ostream_char_type<_CharT> = _CharT;
        pub type basic_ostream_int_type = [u8; 0usize];
        pub type basic_ostream_pos_type = [u8; 0usize];
        pub type basic_ostream_off_type = [u8; 0usize];
        pub type basic_ostream_traits_type<_Traits> = _Traits;
        pub type basic_ostream___streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type basic_ostream___ios_type<_CharT> = basic_ios<_CharT>;
        pub type basic_ostream___ostream_type<_CharT> = basic_ostream<_CharT>;
        pub type basic_ostream___num_put_type = num_put;
        pub type basic_ostream___ctype_type = ctype;
        impl<_CharT> Default for basic_ostream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_ostream_sentry {
            pub _M_ok: bool,
            pub _M_os: *mut basic_ostream<_CharT>,
        }
        impl Default for basic_ostream_sentry {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_istream<_CharT> {
            pub _M_gcount: streamsize,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_istream_char_type<_CharT> = _CharT;
        pub type basic_istream_int_type = [u8; 0usize];
        pub type basic_istream_pos_type = [u8; 0usize];
        pub type basic_istream_off_type = [u8; 0usize];
        pub type basic_istream_traits_type<_Traits> = _Traits;
        pub type basic_istream___streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type basic_istream___ios_type<_CharT> = basic_ios<_CharT>;
        pub type basic_istream___istream_type<_CharT> = basic_istream<_CharT>;
        pub type basic_istream___num_get_type = num_get;
        pub type basic_istream___ctype_type = ctype;
        impl<_CharT> Default for basic_istream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_istream_sentry {
            pub _M_ok: bool,
        }
        pub type basic_istream_sentry_traits_type = _Traits;
        pub type basic_istream_sentry___streambuf_type = basic_streambuf<_CharT>;
        pub type basic_istream_sentry___istream_type = basic_istream<_CharT>;
        pub type basic_istream_sentry___ctype_type = basic_istream___ctype_type;
        pub type basic_istream_sentry___int_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_iostream<_CharT> {
            pub _base: basic_istream<_CharT>,
            pub _base_1: basic_ostream<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_iostream_char_type<_CharT> = _CharT;
        pub type basic_iostream_int_type = [u8; 0usize];
        pub type basic_iostream_pos_type = [u8; 0usize];
        pub type basic_iostream_off_type = [u8; 0usize];
        pub type basic_iostream_traits_type<_Traits> = _Traits;
        pub type basic_iostream___istream_type<_CharT> = basic_istream<_CharT>;
        pub type basic_iostream___ostream_type<_CharT> = basic_ostream<_CharT>;
        impl<_CharT> Default for basic_iostream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct codecvt_base {
            pub _address: u8,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum codecvt_base_result {
            ok = 0,
            partial = 1,
            error = 2,
            noconv = 3,
        }
        #[test]
        fn bindgen_test_layout_codecvt_base() {
            assert_eq!(
                ::std::mem::size_of::<codecvt_base>(),
                1usize,
                concat!("Size of: ", stringify!(codecvt_base))
            );
            assert_eq!(
                ::std::mem::align_of::<codecvt_base>(),
                1usize,
                concat!("Alignment of ", stringify!(codecvt_base))
            );
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __codecvt_abstract_base {
            pub _base: locale_facet,
        }
        pub use codecvt_base_result as __codecvt_abstract_base_result;
        pub type __codecvt_abstract_base_intern_type<_InternT> = _InternT;
        pub type __codecvt_abstract_base_extern_type<_ExternT> = _ExternT;
        pub type __codecvt_abstract_base_state_type<_StateT> = _StateT;
        impl Default for __codecvt_abstract_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct codecvt {
            pub _base: __codecvt_abstract_base,
            pub _M_c_locale_codecvt: __c_locale,
        }
        pub use codecvt_base_result as codecvt_result;
        pub type codecvt_intern_type<_InternT> = _InternT;
        pub type codecvt_extern_type<_ExternT> = _ExternT;
        pub type codecvt_state_type<_StateT> = _StateT;
        impl Default for codecvt {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __c_lock = __gthread_mutex_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __basic_file {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct basic_filebuf<_CharT> {
            pub _base: basic_streambuf<_CharT>,
            pub _M_lock: __c_lock,
            pub _M_file: basic_filebuf___file_type,
            pub _M_mode: ios_base_openmode,
            pub _M_state_beg: basic_filebuf___state_type,
            pub _M_state_cur: basic_filebuf___state_type,
            pub _M_state_last: basic_filebuf___state_type,
            pub _M_buf: *mut basic_filebuf_char_type<_CharT>,
            pub _M_buf_size: usize,
            pub _M_buf_allocated: bool,
            pub _M_reading: bool,
            pub _M_writing: bool,
            pub _M_pback: basic_filebuf_char_type<_CharT>,
            pub _M_pback_cur_save: *mut basic_filebuf_char_type<_CharT>,
            pub _M_pback_end_save: *mut basic_filebuf_char_type<_CharT>,
            pub _M_pback_init: bool,
            pub _M_codecvt: *const basic_filebuf___codecvt_type,
            pub _M_ext_buf: *mut ::std::os::raw::c_char,
            pub _M_ext_buf_size: streamsize,
            pub _M_ext_next: *const ::std::os::raw::c_char,
            pub _M_ext_end: *mut ::std::os::raw::c_char,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_filebuf___chk_state = __and_;
        pub type basic_filebuf_char_type<_CharT> = _CharT;
        pub type basic_filebuf_traits_type<_Traits> = _Traits;
        pub type basic_filebuf_int_type = [u8; 0usize];
        pub type basic_filebuf_pos_type = [u8; 0usize];
        pub type basic_filebuf_off_type = [u8; 0usize];
        pub type basic_filebuf___streambuf_type<_CharT> =
            basic_streambuf<basic_filebuf_char_type<_CharT>>;
        pub type basic_filebuf___filebuf_type<_CharT> =
            basic_filebuf<basic_filebuf_char_type<_CharT>>;
        pub type basic_filebuf___file_type = __basic_file;
        pub type basic_filebuf___state_type = [u8; 0usize];
        pub type basic_filebuf___codecvt_type = codecvt;
        impl<_CharT> Default for basic_filebuf<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_filebuf<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! ( f , "basic_filebuf {{ _M_lock: {:?}, _M_file: {:?}, _M_mode: {:?}, _M_buf: {:?}, _M_buf_size: {:?}, _M_buf_allocated: {:?}, _M_reading: {:?}, _M_writing: {:?}, _M_pback: Non-debuggable generic, _M_pback_cur_save: {:?}, _M_pback_end_save: {:?}, _M_pback_init: {:?}, _M_codecvt: {:?}, _M_ext_buf: {:?}, _M_ext_buf_size: {:?}, _M_ext_next: {:?}, _M_ext_end: {:?} }}" , self . _M_lock , self . _M_file , self . _M_mode , self . _M_buf , self . _M_buf_size , self . _M_buf_allocated , self . _M_reading , self . _M_writing , self . _M_pback_cur_save , self . _M_pback_end_save , self . _M_pback_init , self . _M_codecvt , self . _M_ext_buf , self . _M_ext_buf_size , self . _M_ext_next , self . _M_ext_end )
            }
        }
        #[repr(C)]
        pub struct basic_fstream<_CharT> {
            pub _base: basic_iostream<_CharT>,
            pub _M_filebuf: basic_fstream___filebuf_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_fstream_char_type<_CharT> = _CharT;
        pub type basic_fstream_traits_type<_Traits> = _Traits;
        pub type basic_fstream_int_type = [u8; 0usize];
        pub type basic_fstream_pos_type = [u8; 0usize];
        pub type basic_fstream_off_type = [u8; 0usize];
        pub type basic_fstream___filebuf_type<_CharT> =
            basic_filebuf<basic_fstream_char_type<_CharT>>;
        pub type basic_fstream___ios_type<_CharT> = basic_ios<basic_fstream_char_type<_CharT>>;
        pub type basic_fstream___iostream_type<_CharT> =
            basic_iostream<basic_fstream_char_type<_CharT>>;
        impl<_CharT> Default for basic_fstream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_fstream<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "basic_fstream {{ _M_filebuf: {:?} }}", self._M_filebuf)
            }
        }
    }
    pub mod __gnu_cxx {

        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category = __normal_iterator___traits_type;
        pub type __normal_iterator_value_type = __normal_iterator___traits_type;
        pub type __normal_iterator_difference_type = __normal_iterator___traits_type;
        pub type __normal_iterator_reference = __normal_iterator___traits_type;
        pub type __normal_iterator_pointer = __normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = allocator_traits;
        pub type __alloc_traits_value_type = __alloc_traits__Base_type;
        pub type __alloc_traits_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_size_type = __alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = __alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut __alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const __alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = __and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = __alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __aligned_membuf {
            pub _M_storage: *mut ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __aligned_membuf__Tp2<_Tp> {
            pub _M_t: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        impl<_Tp> Default for __aligned_membuf__Tp2<_Tp> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Default for __aligned_membuf {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = streampos;
        pub type _Char_types_off_type = streamoff;
        pub type _Char_types_state_type = mbstate_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = _Char_types;
        pub type char_traits_pos_type = _Char_types;
        pub type char_traits_off_type = _Char_types;
        pub type char_traits_state_type = _Char_types;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __locale_struct {
        pub __locales: [*mut __locale_data; 13usize],
        pub __ctype_b: *const ::std::os::raw::c_ushort,
        pub __ctype_tolower: *const ::std::os::raw::c_int,
        pub __ctype_toupper: *const ::std::os::raw::c_int,
        pub __names: [*const ::std::os::raw::c_char; 13usize],
    }
    #[test]
    fn bindgen_test_layout___locale_struct() {
        assert_eq!(
            ::std::mem::size_of::<__locale_struct>(),
            232usize,
            concat!("Size of: ", stringify!(__locale_struct))
        );
        assert_eq!(
            ::std::mem::align_of::<__locale_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(__locale_struct))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    impl Default for __locale_struct {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type __locale_t = *mut __locale_struct;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[test]
    fn bindgen_test_layout___pthread_internal_list() {
        assert_eq!(
            ::std::mem::size_of::<__pthread_internal_list>(),
            16usize,
            concat!("Size of: ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            ::std::mem::align_of::<__pthread_internal_list>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    impl Default for __pthread_internal_list {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type __pthread_list_t = __pthread_internal_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __pthread_mutex_s {
        pub __lock: ::std::os::raw::c_int,
        pub __count: ::std::os::raw::c_uint,
        pub __owner: ::std::os::raw::c_int,
        pub __nusers: ::std::os::raw::c_uint,
        pub __kind: ::std::os::raw::c_int,
        pub __spins: ::std::os::raw::c_short,
        pub __elision: ::std::os::raw::c_short,
        pub __list: __pthread_list_t,
    }
    #[test]
    fn bindgen_test_layout___pthread_mutex_s() {
        assert_eq!(
            ::std::mem::size_of::<__pthread_mutex_s>(),
            40usize,
            concat!("Size of: ", stringify!(__pthread_mutex_s))
        );
        assert_eq!(
            ::std::mem::align_of::<__pthread_mutex_s>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_mutex_s))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    impl Default for __pthread_mutex_s {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type pthread_t = ::std::os::raw::c_ulong;
    pub type pthread_once_t = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [::std::os::raw::c_char; 40usize],
        pub __align: ::std::os::raw::c_long,
        _bindgen_union_align: [u64; 5usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_mutex_t() {
        assert_eq!(
            ::std::mem::size_of::<pthread_mutex_t>(),
            40usize,
            concat!("Size of: ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            ::std::mem::align_of::<pthread_mutex_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    impl Default for pthread_mutex_t {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for pthread_mutex_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "pthread_mutex_t {{ union }}")
        }
    }
    pub type c_str = *mut ::std::os::raw::c_char;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct S_Symbol_ {
        _unused: [u8; 0],
    }
    pub type S_Symbol = *mut S_Symbol_;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Operator {
        ae_op_plus = 0,
        ae_op_minus = 1,
        ae_op_times = 2,
        ae_op_divide = 3,
        ae_op_eq = 4,
        ae_op_neq = 5,
        ae_op_lt = 6,
        ae_op_le = 7,
        ae_op_gt = 8,
        ae_op_ge = 9,
        ae_op_and = 10,
        ae_op_or = 11,
        ae_op_s_or = 12,
        ae_op_s_and = 13,
        ae_op_shift_left = 14,
        ae_op_shift_right = 15,
        ae_op_percent = 16,
        ae_op_s_xor = 17,
        ae_op_chuck = 18,
        ae_op_plus_chuck = 19,
        ae_op_minus_chuck = 20,
        ae_op_times_chuck = 21,
        ae_op_divide_chuck = 22,
        ae_op_s_and_chuck = 23,
        ae_op_s_or_chuck = 24,
        ae_op_s_xor_chuck = 25,
        ae_op_shift_right_chuck = 26,
        ae_op_shift_left_chuck = 27,
        ae_op_percent_chuck = 28,
        ae_op_s_chuck = 29,
        ae_op_plusplus = 30,
        ae_op_minusminus = 31,
        ae_op_tilda = 32,
        ae_op_exclamation = 33,
        ae_op_at_chuck = 34,
        ae_op_unchuck = 35,
        ae_op_upchuck = 36,
        ae_op_spork = 37,
        ae_op_typeof = 38,
        ae_op_sizeof = 39,
        ae_op_new = 40,
        ae_op_arrow_left = 41,
        ae_op_arrow_right = 42,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Keyword {
        ae_key_this = 0,
        ae_key_me = 1,
        ae_key_func = 2,
        ae_key_public = 3,
        ae_key_protected = 4,
        ae_key_private = 5,
        ae_key_static = 6,
        ae_key_instance = 7,
        ae_key_abstract = 8,
    }
    pub type a_Program = *mut a_Program_;
    pub type a_Section = *mut a_Section_;
    pub type a_Stmt_List = *mut a_Stmt_List_;
    pub type a_Class_Def = *mut a_Class_Def_;
    pub type a_Func_Def = *mut a_Func_Def_;
    pub type a_Stmt = *mut a_Stmt_;
    pub type a_Exp = *mut a_Exp_;
    pub type a_Var_Decl = *mut a_Var_Decl_;
    pub type a_Var_Decl_List = *mut a_Var_Decl_List_;
    pub type a_Type_Decl = *mut a_Type_Decl_;
    pub type a_Arg_List = *mut a_Arg_List_;
    pub type a_Id_List = *mut a_Id_List_;
    pub type a_Class_Ext = *mut a_Class_Ext_;
    pub type a_Class_Body = *mut a_Class_Body_;
    pub type a_Array_Sub = *mut a_Array_Sub_;
    pub type a_Complex = *mut a_Complex_;
    pub type a_Polar = *mut a_Polar_;
    pub type a_Vec = *mut a_Vec_;
    pub type t_CKTYPE = *mut Chuck_Type;
    pub type t_CKVALUE = *mut Chuck_Value;
    pub type t_CKFUNC = *mut Chuck_Func;
    pub type t_CKNSPC = *mut Chuck_Namespace;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_VM_Code {
        _unused: [u8; 0],
    }
    pub type t_CKVMCODE = *mut Chuck_VM_Code;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Binary_ {
        pub lhs: a_Exp,
        pub op: ae_Operator,
        pub rhs: a_Exp,
        pub ck_func: t_CKFUNC,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Binary_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Binary_>(),
            48usize,
            concat!("Size of: ", stringify!(a_Exp_Binary_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Binary_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Binary_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Binary_>())).lhs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Binary_),
                "::",
                stringify!(lhs)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Binary_>())).op as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Binary_),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Binary_>())).rhs as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Binary_),
                "::",
                stringify!(rhs)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Binary_>())).ck_func as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Binary_),
                "::",
                stringify!(ck_func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Binary_>())).linepos as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Binary_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Binary_>())).self_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Binary_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Binary_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Cast_ {
        pub type_: a_Type_Decl,
        pub exp: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Cast_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Cast_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Exp_Cast_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Cast_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Cast_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Cast_>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Cast_),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Cast_>())).exp as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Cast_),
                "::",
                stringify!(exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Cast_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Cast_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Cast_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Cast_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Cast_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Unary_ {
        pub op: ae_Operator,
        pub exp: a_Exp,
        pub type_: a_Type_Decl,
        pub array: a_Array_Sub,
        pub code: a_Stmt,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Unary_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Unary_>(),
            56usize,
            concat!("Size of: ", stringify!(a_Exp_Unary_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Unary_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Unary_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).op as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).exp as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).type_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).array as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(array)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).code as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(code)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).linepos as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Unary_>())).self_ as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Unary_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Unary_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Postfix_ {
        pub exp: a_Exp,
        pub op: ae_Operator,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Postfix_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Postfix_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Exp_Postfix_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Postfix_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Postfix_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Postfix_>())).exp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Postfix_),
                "::",
                stringify!(exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Postfix_>())).op as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Postfix_),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Postfix_>())).linepos as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Postfix_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Postfix_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Postfix_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Postfix_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Dur_ {
        pub base: a_Exp,
        pub unit: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Dur_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Dur_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Exp_Dur_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Dur_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Dur_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dur_>())).base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dur_),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dur_>())).unit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dur_),
                "::",
                stringify!(unit)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dur_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dur_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dur_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dur_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Dur_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Array_ {
        pub base: a_Exp,
        pub indices: a_Array_Sub,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Array_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Array_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Exp_Array_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Array_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Array_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Array_>())).base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Array_),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Array_>())).indices as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Array_),
                "::",
                stringify!(indices)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Array_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Array_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Array_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Array_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Array_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Func_Call_ {
        pub func: a_Exp,
        pub args: a_Exp,
        pub ret_type: t_CKTYPE,
        pub ck_func: t_CKFUNC,
        pub ck_vm_code: t_CKVMCODE,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Func_Call_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Func_Call_>(),
            56usize,
            concat!("Size of: ", stringify!(a_Exp_Func_Call_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Func_Call_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Func_Call_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).func as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).args as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(args)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).ret_type as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(ret_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).ck_func as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(ck_func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).ck_vm_code as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(ck_vm_code)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).linepos as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Func_Call_>())).self_ as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Func_Call_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Func_Call_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Dot_Member_ {
        pub base: a_Exp,
        pub t_base: t_CKTYPE,
        pub xid: S_Symbol,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Dot_Member_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Dot_Member_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Exp_Dot_Member_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Dot_Member_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Dot_Member_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dot_Member_>())).base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dot_Member_),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dot_Member_>())).t_base as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dot_Member_),
                "::",
                stringify!(t_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dot_Member_>())).xid as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dot_Member_),
                "::",
                stringify!(xid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dot_Member_>())).linepos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dot_Member_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Dot_Member_>())).self_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Dot_Member_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Dot_Member_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_If_ {
        pub cond: a_Exp,
        pub if_exp: a_Exp,
        pub else_exp: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_If_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_If_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Exp_If_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_If_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_If_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_If_>())).cond as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_If_),
                "::",
                stringify!(cond)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_If_>())).if_exp as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_If_),
                "::",
                stringify!(if_exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_If_>())).else_exp as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_If_),
                "::",
                stringify!(else_exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_If_>())).linepos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_If_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_If_>())).self_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_If_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_If_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Exp_Decl_ {
        pub type_: a_Type_Decl,
        pub var_decl_list: a_Var_Decl_List,
        pub num_var_decls: ::std::os::raw::c_int,
        pub is_static: ::std::os::raw::c_int,
        pub is_global: ::std::os::raw::c_int,
        pub ck_type: t_CKTYPE,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Decl_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Decl_>(),
            56usize,
            concat!("Size of: ", stringify!(a_Exp_Decl_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Decl_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Decl_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).var_decl_list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(var_decl_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).num_var_decls as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(num_var_decls)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).is_static as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(is_static)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).is_global as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(is_global)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).ck_type as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(ck_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).linepos as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Decl_>())).self_ as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Decl_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Decl_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Var_Decl_List_ {
        pub var_decl: a_Var_Decl,
        pub next: a_Var_Decl_List,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Var_Decl_List_() {
        assert_eq!(
            ::std::mem::size_of::<a_Var_Decl_List_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Var_Decl_List_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Var_Decl_List_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Var_Decl_List_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_List_>())).var_decl as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_List_),
                "::",
                stringify!(var_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_List_>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_List_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_List_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_List_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_List_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_List_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Var_Decl_List_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Var_Decl_ {
        pub xid: S_Symbol,
        pub var_decl: a_Var_Decl,
        pub array: a_Array_Sub,
        pub value: t_CKVALUE,
        pub addr: *mut ::std::os::raw::c_void,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Var_Decl_() {
        assert_eq!(
            ::std::mem::size_of::<a_Var_Decl_>(),
            56usize,
            concat!("Size of: ", stringify!(a_Var_Decl_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Var_Decl_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Var_Decl_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).xid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(xid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).var_decl as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(var_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).array as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(array)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).value as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(value)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).addr as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).linepos as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Var_Decl_>())).self_ as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Var_Decl_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Var_Decl_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Type_Decl_ {
        pub xid: a_Id_List,
        pub array: a_Array_Sub,
        pub ref_: ::std::os::raw::c_int,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Type_Decl_() {
        assert_eq!(
            ::std::mem::size_of::<a_Type_Decl_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Type_Decl_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Type_Decl_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Type_Decl_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Type_Decl_>())).xid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Type_Decl_),
                "::",
                stringify!(xid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Type_Decl_>())).array as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Type_Decl_),
                "::",
                stringify!(array)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Type_Decl_>())).ref_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Type_Decl_),
                "::",
                stringify!(ref_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Type_Decl_>())).linepos as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Type_Decl_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Type_Decl_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Array_Sub_ {
        pub depth: ::std::os::raw::c_ulong,
        pub exp_list: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
        pub err_num: ::std::os::raw::c_int,
        pub err_pos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Array_Sub_() {
        assert_eq!(
            ::std::mem::size_of::<a_Array_Sub_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Array_Sub_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Array_Sub_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Array_Sub_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Array_Sub_>())).depth as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Array_Sub_),
                "::",
                stringify!(depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Array_Sub_>())).exp_list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Array_Sub_),
                "::",
                stringify!(exp_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Array_Sub_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Array_Sub_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Array_Sub_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Array_Sub_),
                "::",
                stringify!(self_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Array_Sub_>())).err_num as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Array_Sub_),
                "::",
                stringify!(err_num)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Array_Sub_>())).err_pos as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Array_Sub_),
                "::",
                stringify!(err_pos)
            )
        );
    }
    impl Default for a_Array_Sub_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Arg_List_ {
        pub type_decl: a_Type_Decl,
        pub var_decl: a_Var_Decl,
        pub type_: t_CKTYPE,
        pub next: a_Arg_List,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Arg_List_() {
        assert_eq!(
            ::std::mem::size_of::<a_Arg_List_>(),
            48usize,
            concat!("Size of: ", stringify!(a_Arg_List_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Arg_List_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Arg_List_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Arg_List_>())).type_decl as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Arg_List_),
                "::",
                stringify!(type_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Arg_List_>())).var_decl as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Arg_List_),
                "::",
                stringify!(var_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Arg_List_>())).type_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Arg_List_),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Arg_List_>())).next as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Arg_List_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Arg_List_>())).linepos as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Arg_List_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Arg_List_>())).self_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Arg_List_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Arg_List_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Complex_ {
        pub re: a_Exp,
        pub im: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Complex_() {
        assert_eq!(
            ::std::mem::size_of::<a_Complex_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Complex_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Complex_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Complex_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Complex_>())).re as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Complex_),
                "::",
                stringify!(re)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Complex_>())).im as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Complex_),
                "::",
                stringify!(im)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Complex_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Complex_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Complex_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Complex_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Complex_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Polar_ {
        pub mod_: a_Exp,
        pub phase: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Polar_() {
        assert_eq!(
            ::std::mem::size_of::<a_Polar_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Polar_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Polar_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Polar_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Polar_>())).mod_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Polar_),
                "::",
                stringify!(mod_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Polar_>())).phase as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Polar_),
                "::",
                stringify!(phase)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Polar_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Polar_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Polar_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Polar_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Polar_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Vec_ {
        pub args: a_Exp,
        pub numdims: ::std::os::raw::c_int,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[test]
    fn bindgen_test_layout_a_Vec_() {
        assert_eq!(
            ::std::mem::size_of::<a_Vec_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Vec_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Vec_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Vec_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Vec_>())).args as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Vec_),
                "::",
                stringify!(args)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Vec_>())).numdims as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Vec_),
                "::",
                stringify!(numdims)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Vec_>())).linepos as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Vec_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Vec_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Vec_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Vec_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Exp_Primary_Type {
        ae_primary_var = 0,
        ae_primary_num = 1,
        ae_primary_float = 2,
        ae_primary_str = 3,
        ae_primary_array = 4,
        ae_primary_exp = 5,
        ae_primary_hack = 6,
        ae_primary_complex = 7,
        ae_primary_polar = 8,
        ae_primary_vec = 9,
        ae_primary_char = 10,
        ae_primary_nil = 11,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct a_Exp_Primary_ {
        pub s_type: ae_Exp_Primary_Type,
        pub value: t_CKVALUE,
        pub __bindgen_anon_1: a_Exp_Primary___bindgen_ty_1,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Exp,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union a_Exp_Primary___bindgen_ty_1 {
        pub var: S_Symbol,
        pub num: ::std::os::raw::c_long,
        pub fnum: f64,
        pub str: c_str,
        pub chr: c_str,
        pub array: a_Array_Sub,
        pub exp: a_Exp,
        pub complex: a_Complex,
        pub polar: a_Polar,
        pub vec: a_Vec,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Primary___bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Primary___bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(a_Exp_Primary___bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Primary___bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Primary___bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).var as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(var)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).num as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(num)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).fnum as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(fnum)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).str as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(str)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).chr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(chr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).array as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).exp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(exp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).complex as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(complex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).polar as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(polar)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp_Primary___bindgen_ty_1>())).vec as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary___bindgen_ty_1),
                "::",
                stringify!(vec)
            )
        );
    }
    impl Default for a_Exp_Primary___bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Exp_Primary___bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "a_Exp_Primary___bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_a_Exp_Primary_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_Primary_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Exp_Primary_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_Primary_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_Primary_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Primary_>())).s_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary_),
                "::",
                stringify!(s_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Primary_>())).value as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary_),
                "::",
                stringify!(value)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Primary_>())).linepos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_Primary_>())).self_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_Primary_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Exp_Primary_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Exp_Primary_ {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "a_Exp_Primary_ {{ s_type: {:?}, value: {:?}, __bindgen_anon_1: {:?}, linepos: {:?}, self: {:?} }}" , self . s_type , self . value , self . __bindgen_anon_1 , self . linepos , self . self_ )
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Exp_Type {
        ae_exp_binary = 0,
        ae_exp_unary = 1,
        ae_exp_cast = 2,
        ae_exp_postfix = 3,
        ae_exp_dur = 4,
        ae_exp_primary = 5,
        ae_exp_array = 6,
        ae_exp_func_call = 7,
        ae_exp_dot_member = 8,
        ae_exp_if = 9,
        ae_exp_decl = 10,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Exp_Meta {
        ae_meta_value = 0,
        ae_meta_var = 1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct a_Exp_ {
        pub s_type: ae_Exp_Type,
        pub s_meta: ae_Exp_Meta,
        pub type_: t_CKTYPE,
        pub owner: t_CKNSPC,
        pub next: a_Exp,
        pub group_size: ::std::os::raw::c_ulong,
        pub cast_to: t_CKTYPE,
        pub emit_var: ::std::os::raw::c_ulong,
        pub __bindgen_anon_1: a_Exp___bindgen_ty_1,
        pub linepos: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union a_Exp___bindgen_ty_1 {
        pub binary: a_Exp_Binary_,
        pub unary: a_Exp_Unary_,
        pub cast: a_Exp_Cast_,
        pub postfix: a_Exp_Postfix_,
        pub dur: a_Exp_Dur_,
        pub primary: a_Exp_Primary_,
        pub array: a_Exp_Array_,
        pub func_call: a_Exp_Func_Call_,
        pub dot_member: a_Exp_Dot_Member_,
        pub exp_if: a_Exp_If_,
        pub decl: a_Exp_Decl_,
        _bindgen_union_align: [u64; 7usize],
    }
    #[test]
    fn bindgen_test_layout_a_Exp___bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp___bindgen_ty_1>(),
            56usize,
            concat!("Size of: ", stringify!(a_Exp___bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp___bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp___bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).binary as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(binary)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).unary as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(unary)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).cast as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(cast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).postfix as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(postfix)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).dur as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(dur)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).primary as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(primary)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).array as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).func_call as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(func_call)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).dot_member as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(dot_member)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).exp_if as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(exp_if)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp___bindgen_ty_1>())).decl as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp___bindgen_ty_1),
                "::",
                stringify!(decl)
            )
        );
    }
    impl Default for a_Exp___bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Exp___bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "a_Exp___bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_a_Exp_() {
        assert_eq!(
            ::std::mem::size_of::<a_Exp_>(),
            120usize,
            concat!("Size of: ", stringify!(a_Exp_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Exp_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Exp_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).s_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(s_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).s_meta as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(s_meta)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).type_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).owner as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).next as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).group_size as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(group_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).cast_to as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(cast_to)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).emit_var as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(emit_var)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Exp_>())).linepos as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Exp_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Exp_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Exp_ {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "a_Exp_ {{ s_type: {:?}, s_meta: {:?}, type: {:?}, owner: {:?}, next: {:?}, group_size: {:?}, cast_to: {:?}, emit_var: {:?}, __bindgen_anon_1: {:?}, linepos: {:?} }}" , self . s_type , self . s_meta , self . type_ , self . owner , self . next , self . group_size , self . cast_to , self . emit_var , self . __bindgen_anon_1 , self . linepos )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_While_ {
        pub is_do: ::std::os::raw::c_int,
        pub cond: a_Exp,
        pub body: a_Stmt,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_While_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_While_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Stmt_While_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_While_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_While_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_While_>())).is_do as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_While_),
                "::",
                stringify!(is_do)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_While_>())).cond as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_While_),
                "::",
                stringify!(cond)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_While_>())).body as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_While_),
                "::",
                stringify!(body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_While_>())).linepos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_While_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_While_>())).self_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_While_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_While_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Until_ {
        pub is_do: ::std::os::raw::c_int,
        pub cond: a_Exp,
        pub body: a_Stmt,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Until_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Until_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Stmt_Until_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Until_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Until_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Until_>())).is_do as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Until_),
                "::",
                stringify!(is_do)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Until_>())).cond as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Until_),
                "::",
                stringify!(cond)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Until_>())).body as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Until_),
                "::",
                stringify!(body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Until_>())).linepos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Until_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Until_>())).self_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Until_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Until_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_For_ {
        pub c1: a_Stmt,
        pub c2: a_Stmt,
        pub c3: a_Exp,
        pub body: a_Stmt,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_For_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_For_>(),
            48usize,
            concat!("Size of: ", stringify!(a_Stmt_For_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_For_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_For_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_For_>())).c1 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_For_),
                "::",
                stringify!(c1)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_For_>())).c2 as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_For_),
                "::",
                stringify!(c2)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_For_>())).c3 as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_For_),
                "::",
                stringify!(c3)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_For_>())).body as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_For_),
                "::",
                stringify!(body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_For_>())).linepos as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_For_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_For_>())).self_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_For_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_For_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Loop_ {
        pub cond: a_Exp,
        pub body: a_Stmt,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Loop_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Loop_>(),
            32usize,
            concat!("Size of: ", stringify!(a_Stmt_Loop_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Loop_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Loop_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Loop_>())).cond as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Loop_),
                "::",
                stringify!(cond)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Loop_>())).body as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Loop_),
                "::",
                stringify!(body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Loop_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Loop_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Loop_>())).self_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Loop_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Loop_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Code_ {
        pub stmt_list: a_Stmt_List,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Code_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Code_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Stmt_Code_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Code_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Code_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Code_>())).stmt_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Code_),
                "::",
                stringify!(stmt_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Code_>())).linepos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Code_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Code_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Code_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Code_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_If_ {
        pub cond: a_Exp,
        pub if_body: a_Stmt,
        pub else_body: a_Stmt,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_If_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_If_>(),
            40usize,
            concat!("Size of: ", stringify!(a_Stmt_If_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_If_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_If_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_If_>())).cond as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_If_),
                "::",
                stringify!(cond)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_If_>())).if_body as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_If_),
                "::",
                stringify!(if_body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_If_>())).else_body as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_If_),
                "::",
                stringify!(else_body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_If_>())).linepos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_If_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_If_>())).self_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_If_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_If_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Switch_ {
        pub val: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Switch_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Switch_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Stmt_Switch_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Switch_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Switch_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Switch_>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Switch_),
                "::",
                stringify!(val)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Switch_>())).linepos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Switch_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Switch_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Switch_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Switch_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Break_ {
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Break_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Break_>(),
            16usize,
            concat!("Size of: ", stringify!(a_Stmt_Break_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Break_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Break_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Break_>())).linepos as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Break_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Break_>())).self_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Break_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Break_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Continue_ {
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Continue_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Continue_>(),
            16usize,
            concat!("Size of: ", stringify!(a_Stmt_Continue_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Continue_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Continue_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Continue_>())).linepos as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Continue_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Continue_>())).self_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Continue_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Continue_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Return_ {
        pub val: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Return_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Return_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Stmt_Return_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Return_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Return_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Return_>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Return_),
                "::",
                stringify!(val)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Return_>())).linepos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Return_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Return_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Return_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Return_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_Case_ {
        pub exp: a_Exp,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_Case_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_Case_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Stmt_Case_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_Case_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_Case_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Case_>())).exp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Case_),
                "::",
                stringify!(exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Case_>())).linepos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Case_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_Case_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_Case_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_Case_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_GotoLabel_ {
        pub name: S_Symbol,
        pub linepos: ::std::os::raw::c_int,
        pub self_: a_Stmt,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_GotoLabel_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_GotoLabel_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Stmt_GotoLabel_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_GotoLabel_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_GotoLabel_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_GotoLabel_>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_GotoLabel_),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_GotoLabel_>())).linepos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_GotoLabel_),
                "::",
                stringify!(linepos)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_GotoLabel_>())).self_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_GotoLabel_),
                "::",
                stringify!(self_)
            )
        );
    }
    impl Default for a_Stmt_GotoLabel_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Stmt_Type {
        ae_stmt_exp = 0,
        ae_stmt_while = 1,
        ae_stmt_until = 2,
        ae_stmt_for = 3,
        ae_stmt_loop = 4,
        ae_stmt_if = 5,
        ae_stmt_code = 6,
        ae_stmt_switch = 7,
        ae_stmt_break = 8,
        ae_stmt_continue = 9,
        ae_stmt_return = 10,
        ae_stmt_case = 11,
        ae_stmt_gotolabel = 12,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct a_Stmt_ {
        pub s_type: ae_Stmt_Type,
        pub skip: ::std::os::raw::c_int,
        pub __bindgen_anon_1: a_Stmt___bindgen_ty_1,
        pub linepos: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union a_Stmt___bindgen_ty_1 {
        pub stmt_exp: a_Exp,
        pub stmt_code: a_Stmt_Code_,
        pub stmt_while: a_Stmt_While_,
        pub stmt_until: a_Stmt_Until_,
        pub stmt_loop: a_Stmt_Loop_,
        pub stmt_for: a_Stmt_For_,
        pub stmt_if: a_Stmt_If_,
        pub stmt_switch: a_Stmt_Switch_,
        pub stmt_break: a_Stmt_Break_,
        pub stmt_continue: a_Stmt_Continue_,
        pub stmt_return: a_Stmt_Return_,
        pub stmt_case: a_Stmt_Case_,
        pub stmt_gotolabel: a_Stmt_GotoLabel_,
        _bindgen_union_align: [u64; 6usize],
    }
    #[test]
    fn bindgen_test_layout_a_Stmt___bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt___bindgen_ty_1>(),
            48usize,
            concat!("Size of: ", stringify!(a_Stmt___bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt___bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt___bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_exp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_exp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_code as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_code)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_while as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_while)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_until as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_until)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_loop as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_loop)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_for as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_for)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_if as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_if)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_switch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_switch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_break as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_break)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_continue as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_continue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_return as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_return)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_case as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_case)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Stmt___bindgen_ty_1>())).stmt_gotolabel as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt___bindgen_ty_1),
                "::",
                stringify!(stmt_gotolabel)
            )
        );
    }
    impl Default for a_Stmt___bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Stmt___bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "a_Stmt___bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_>(),
            64usize,
            concat!("Size of: ", stringify!(a_Stmt_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_>())).s_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_),
                "::",
                stringify!(s_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_>())).skip as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_),
                "::",
                stringify!(skip)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_>())).linepos as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Stmt_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Stmt_ {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "a_Stmt_ {{ s_type: {:?}, skip: {:?}, __bindgen_anon_1: {:?}, linepos: {:?} }}",
                self.s_type, self.skip, self.__bindgen_anon_1, self.linepos
            )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Stmt_List_ {
        pub stmt: a_Stmt,
        pub next: a_Stmt_List,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Stmt_List_() {
        assert_eq!(
            ::std::mem::size_of::<a_Stmt_List_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Stmt_List_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Stmt_List_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Stmt_List_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_List_>())).stmt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_List_),
                "::",
                stringify!(stmt)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_List_>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_List_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Stmt_List_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Stmt_List_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Stmt_List_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Class_Def_ {
        pub decl: ae_Keyword,
        pub name: a_Id_List,
        pub ext: a_Class_Ext,
        pub body: a_Class_Body,
        pub type_: t_CKTYPE,
        pub iface: ::std::os::raw::c_int,
        pub home: t_CKNSPC,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Class_Def_() {
        assert_eq!(
            ::std::mem::size_of::<a_Class_Def_>(),
            64usize,
            concat!("Size of: ", stringify!(a_Class_Def_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Class_Def_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Class_Def_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).decl as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).ext as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(ext)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).body as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(body)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).type_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).iface as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(iface)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).home as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(home)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Def_>())).linepos as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Def_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Class_Def_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Class_Ext_ {
        pub extend_id: a_Id_List,
        pub impl_list: a_Id_List,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Class_Ext_() {
        assert_eq!(
            ::std::mem::size_of::<a_Class_Ext_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Class_Ext_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Class_Ext_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Class_Ext_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Ext_>())).extend_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Ext_),
                "::",
                stringify!(extend_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Ext_>())).impl_list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Ext_),
                "::",
                stringify!(impl_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Ext_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Ext_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Class_Ext_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Class_Body_ {
        pub section: a_Section,
        pub next: a_Class_Body,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Class_Body_() {
        assert_eq!(
            ::std::mem::size_of::<a_Class_Body_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Class_Body_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Class_Body_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Class_Body_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Body_>())).section as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Body_),
                "::",
                stringify!(section)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Body_>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Body_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Class_Body_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Class_Body_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Class_Body_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Id_List_ {
        pub xid: S_Symbol,
        pub next: a_Id_List,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Id_List_() {
        assert_eq!(
            ::std::mem::size_of::<a_Id_List_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Id_List_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Id_List_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Id_List_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Id_List_>())).xid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Id_List_),
                "::",
                stringify!(xid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Id_List_>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Id_List_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Id_List_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Id_List_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Id_List_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Func_Def_ {
        pub func_decl: ae_Keyword,
        pub static_decl: ae_Keyword,
        pub type_decl: a_Type_Decl,
        pub ret_type: t_CKTYPE,
        pub name: S_Symbol,
        pub arg_list: a_Arg_List,
        pub code: a_Stmt,
        pub ck_func: t_CKFUNC,
        pub global: ::std::os::raw::c_uint,
        pub s_type: ::std::os::raw::c_uint,
        pub stack_depth: ::std::os::raw::c_uint,
        pub dl_func_ptr: *mut ::std::os::raw::c_void,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Func_Def_() {
        assert_eq!(
            ::std::mem::size_of::<a_Func_Def_>(),
            88usize,
            concat!("Size of: ", stringify!(a_Func_Def_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Func_Def_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Func_Def_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).func_decl as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(func_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).static_decl as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(static_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).type_decl as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(type_decl)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).ret_type as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(ret_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).name as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).arg_list as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(arg_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).code as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(code)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).ck_func as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(ck_func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).global as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(global)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).s_type as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(s_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).stack_depth as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(stack_depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).dl_func_ptr as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(dl_func_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Func_Def_>())).linepos as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Func_Def_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Func_Def_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum ae_Section_Type {
        ae_section_stmt = 0,
        ae_section_func = 1,
        ae_section_class = 2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct a_Section_ {
        pub s_type: ae_Section_Type,
        pub __bindgen_anon_1: a_Section___bindgen_ty_1,
        pub linepos: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union a_Section___bindgen_ty_1 {
        pub stmt_list: a_Stmt_List,
        pub class_def: a_Class_Def,
        pub func_def: a_Func_Def,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_a_Section___bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<a_Section___bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(a_Section___bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Section___bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Section___bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Section___bindgen_ty_1>())).stmt_list as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Section___bindgen_ty_1),
                "::",
                stringify!(stmt_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Section___bindgen_ty_1>())).class_def as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Section___bindgen_ty_1),
                "::",
                stringify!(class_def)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<a_Section___bindgen_ty_1>())).func_def as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Section___bindgen_ty_1),
                "::",
                stringify!(func_def)
            )
        );
    }
    impl Default for a_Section___bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Section___bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "a_Section___bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_a_Section_() {
        assert_eq!(
            ::std::mem::size_of::<a_Section_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Section_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Section_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Section_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Section_>())).s_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Section_),
                "::",
                stringify!(s_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Section_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Section_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Section_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for a_Section_ {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "a_Section_ {{ s_type: {:?}, __bindgen_anon_1: {:?}, linepos: {:?} }}",
                self.s_type, self.__bindgen_anon_1, self.linepos
            )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct a_Program_ {
        pub section: a_Section,
        pub next: a_Program,
        pub linepos: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_a_Program_() {
        assert_eq!(
            ::std::mem::size_of::<a_Program_>(),
            24usize,
            concat!("Size of: ", stringify!(a_Program_))
        );
        assert_eq!(
            ::std::mem::align_of::<a_Program_>(),
            8usize,
            concat!("Alignment of ", stringify!(a_Program_))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Program_>())).section as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Program_),
                "::",
                stringify!(section)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Program_>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Program_),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<a_Program_>())).linepos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(a_Program_),
                "::",
                stringify!(linepos)
            )
        );
    }
    impl Default for a_Program_ {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct FastCircularBuffer {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct CircularBuffer {
        pub _address: u8,
    }
    pub type THREAD_HANDLE = pthread_t;
    pub type THREAD_RETURN = *mut ::std::os::raw::c_void;
    pub type THREAD_FUNCTION = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >;
    pub type MUTEX = pthread_mutex_t;
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XThread {
        pub thread: THREAD_HANDLE,
    }
    #[test]
    fn bindgen_test_layout_XThread() {
        assert_eq!(
            ::std::mem::size_of::<XThread>(),
            8usize,
            concat!("Size of: ", stringify!(XThread))
        );
        assert_eq!(
            ::std::mem::align_of::<XThread>(),
            8usize,
            concat!("Alignment of ", stringify!(XThread))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XThread>())).thread as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XThread),
                "::",
                stringify!(thread)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}start"]
        pub fn XThread_start(
            this: *mut XThread,
            routine: THREAD_FUNCTION,
            ptr: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}wait"]
        pub fn XThread_wait(
            this: *mut XThread,
            milliseconds: ::std::os::raw::c_long,
            cancel: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}test"]
        pub fn XThread_test();
    }
    extern "C" {
        #[link_name = "\u{1}clear"]
        pub fn XThread_clear(this: *mut XThread);
    }
    extern "C" {
        #[link_name = "\u{1}XThread"]
        pub fn XThread_XThread(this: *mut XThread);
    }
    extern "C" {
        #[link_name = "\u{1}XThread_destructor"]
        pub fn XThread_XThread_destructor(this: *mut XThread);
    }
    impl XThread {
        #[inline]
        pub unsafe fn start(
            &mut self,
            routine: THREAD_FUNCTION,
            ptr: *mut ::std::os::raw::c_void,
        ) -> bool {
            XThread_start(self, routine, ptr)
        }
        #[inline]
        pub unsafe fn wait(&mut self, milliseconds: ::std::os::raw::c_long, cancel: bool) -> bool {
            XThread_wait(self, milliseconds, cancel)
        }
        #[inline]
        pub unsafe fn test() {
            XThread_test()
        }
        #[inline]
        pub unsafe fn clear(&mut self) {
            XThread_clear(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XThread_XThread(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            XThread_XThread_destructor(self)
        }
    }
    #[repr(C)]
    pub struct XMutex {
        pub mutex: MUTEX,
    }
    #[test]
    fn bindgen_test_layout_XMutex() {
        assert_eq!(
            ::std::mem::size_of::<XMutex>(),
            40usize,
            concat!("Size of: ", stringify!(XMutex))
        );
        assert_eq!(
            ::std::mem::align_of::<XMutex>(),
            8usize,
            concat!("Alignment of ", stringify!(XMutex))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XMutex>())).mutex as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XMutex),
                "::",
                stringify!(mutex)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}acquire"]
        pub fn XMutex_acquire(this: *mut XMutex);
    }
    extern "C" {
        #[link_name = "\u{1}release"]
        pub fn XMutex_release(this: *mut XMutex);
    }
    extern "C" {
        #[link_name = "\u{1}XMutex"]
        pub fn XMutex_XMutex(this: *mut XMutex);
    }
    extern "C" {
        #[link_name = "\u{1}XMutex_destructor"]
        pub fn XMutex_XMutex_destructor(this: *mut XMutex);
    }
    impl Default for XMutex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for XMutex {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "XMutex {{ mutex: {:?} }}", self.mutex)
        }
    }
    impl XMutex {
        #[inline]
        pub unsafe fn acquire(&mut self) {
            XMutex_acquire(self)
        }
        #[inline]
        pub unsafe fn release(&mut self) {
            XMutex_release(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XMutex_XMutex(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            XMutex_XMutex_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XWriteThread {
        pub m_thread_exit: ::std::os::raw::c_ulong,
        pub m_thread: XThread,
        pub m_data_buffer: *mut FastCircularBuffer,
        pub m_bytes_in_buffer: usize,
        pub m_thread_buffer: *mut ::std::os::raw::c_uchar,
        pub m_stream: *mut FILE,
        pub m_msg_buffer: *mut CircularBuffer,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct XWriteThread_Message {
        pub operation: XWriteThread_Message__bindgen_ty_1,
        pub file: *mut FILE,
        pub __bindgen_anon_1: XWriteThread_Message__bindgen_ty_2,
    }
    pub const XWriteThread_Message_WRITE: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::WRITE;
    pub const XWriteThread_Message_SEEK: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::SEEK;
    pub const XWriteThread_Message_FLUSH: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::FLUSH;
    pub const XWriteThread_Message_CLOSE: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::CLOSE;
    pub const XWriteThread_Message_SHUTDOWN: XWriteThread_Message__bindgen_ty_1 =
        XWriteThread_Message__bindgen_ty_1::SHUTDOWN;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum XWriteThread_Message__bindgen_ty_1 {
        WRITE = 0,
        SEEK = 1,
        FLUSH = 2,
        CLOSE = 3,
        SHUTDOWN = 4,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union XWriteThread_Message__bindgen_ty_2 {
        pub write: XWriteThread_Message__bindgen_ty_2__bindgen_ty_1,
        pub seek: XWriteThread_Message__bindgen_ty_2__bindgen_ty_2,
        _bindgen_union_align: [u64; 2usize],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XWriteThread_Message__bindgen_ty_2__bindgen_ty_1 {
        pub data_size: usize,
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_1>()))
                    .data_size as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(data_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XWriteThread_Message__bindgen_ty_2__bindgen_ty_2 {
        pub offset: ::std::os::raw::c_long,
        pub whence: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2__bindgen_ty_2() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>())).offset
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2__bindgen_ty_2>())).whence
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(whence)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message__bindgen_ty_2() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(XWriteThread_Message__bindgen_ty_2))
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(XWriteThread_Message__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2>())).write as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message__bindgen_ty_2>())).seek as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message__bindgen_ty_2),
                "::",
                stringify!(seek)
            )
        );
    }
    impl Default for XWriteThread_Message__bindgen_ty_2 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for XWriteThread_Message__bindgen_ty_2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "XWriteThread_Message__bindgen_ty_2 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_XWriteThread_Message() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread_Message>(),
            32usize,
            concat!("Size of: ", stringify!(XWriteThread_Message))
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread_Message>(),
            8usize,
            concat!("Alignment of ", stringify!(XWriteThread_Message))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread_Message>())).operation as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message),
                "::",
                stringify!(operation)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread_Message>())).file as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread_Message),
                "::",
                stringify!(file)
            )
        );
    }
    impl Default for XWriteThread_Message {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for XWriteThread_Message {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "XWriteThread_Message {{ operation: {:?}, file: {:?}, __bindgen_anon_1: {:?} }}",
                self.operation, self.file, self.__bindgen_anon_1
            )
        }
    }
    extern "C" {
        #[link_name = "\u{1}PRODUCER_BUFFER_SIZE"]
        pub static XWriteThread_PRODUCER_BUFFER_SIZE: usize;
    }
    extern "C" {
        #[link_name = "\u{1}o_defaultWriteThread"]
        pub static mut XWriteThread_o_defaultWriteThread: *mut XWriteThread;
    }
    #[test]
    fn bindgen_test_layout_XWriteThread() {
        assert_eq!(
            ::std::mem::size_of::<XWriteThread>(),
            56usize,
            concat!("Size of: ", stringify!(XWriteThread))
        );
        assert_eq!(
            ::std::mem::align_of::<XWriteThread>(),
            8usize,
            concat!("Alignment of ", stringify!(XWriteThread))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_thread_exit as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_thread_exit)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_thread as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_thread)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_data_buffer as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_data_buffer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread>())).m_bytes_in_buffer as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_bytes_in_buffer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<XWriteThread>())).m_thread_buffer as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_thread_buffer)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_stream as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_stream)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XWriteThread>())).m_msg_buffer as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(XWriteThread),
                "::",
                stringify!(m_msg_buffer)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}shared"]
        pub fn XWriteThread_shared() -> *mut XWriteThread;
    }
    extern "C" {
        #[link_name = "\u{1}fwrite"]
        pub fn XWriteThread_fwrite(
            this: *mut XWriteThread,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            nitems: usize,
            stream: *mut FILE,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}fseek"]
        pub fn XWriteThread_fseek(
            this: *mut XWriteThread,
            stream: *mut FILE,
            offset: ::std::os::raw::c_long,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}fflush"]
        pub fn XWriteThread_fflush(
            this: *mut XWriteThread,
            stream: *mut FILE,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}fclose"]
        pub fn XWriteThread_fclose(
            this: *mut XWriteThread,
            stream: *mut FILE,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}shutdown"]
        pub fn XWriteThread_shutdown(this: *mut XWriteThread);
    }
    extern "C" {
        #[link_name = "\u{1}XWriteThread"]
        pub fn XWriteThread_XWriteThread(
            this: *mut XWriteThread,
            data_buffer_size: usize,
            msg_buffer_size: usize,
        );
    }
    impl Default for XWriteThread {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl XWriteThread {
        #[inline]
        pub unsafe fn shared() -> *mut XWriteThread {
            XWriteThread_shared()
        }
        #[inline]
        pub unsafe fn fwrite(
            &mut self,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            nitems: usize,
            stream: *mut FILE,
        ) -> usize {
            XWriteThread_fwrite(self, ptr, size, nitems, stream)
        }
        #[inline]
        pub unsafe fn fseek(
            &mut self,
            stream: *mut FILE,
            offset: ::std::os::raw::c_long,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            XWriteThread_fseek(self, stream, offset, whence)
        }
        #[inline]
        pub unsafe fn fflush(&mut self, stream: *mut FILE) -> ::std::os::raw::c_int {
            XWriteThread_fflush(self, stream)
        }
        #[inline]
        pub unsafe fn fclose(&mut self, stream: *mut FILE) -> ::std::os::raw::c_int {
            XWriteThread_fclose(self, stream)
        }
        #[inline]
        pub unsafe fn shutdown(&mut self) {
            XWriteThread_shutdown(self)
        }
        #[inline]
        pub unsafe fn new(data_buffer_size: usize, msg_buffer_size: usize) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XWriteThread_XWriteThread(&mut __bindgen_tmp, data_buffer_size, msg_buffer_size);
            __bindgen_tmp
        }
    }
    pub type mbstate_t = __mbstate_t;
    pub type __gthread_once_t = pthread_once_t;
    pub type __gthread_mutex_t = pthread_mutex_t;
    pub type _Atomic_word = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ChucK {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_Compiler {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_VM {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ck_socket_ {
        _unused: [u8; 0],
    }
    pub type ck_socket = *mut ck_socket_;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct WvOut {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct Chuck_Carrier {
        pub chuck: *mut ChucK,
        pub compiler: *mut Chuck_Compiler,
        pub env: *mut Chuck_Env,
        pub vm: *mut Chuck_VM,
        pub chout: *mut Chuck_IO_Chout,
        pub cherr: *mut Chuck_IO_Cherr,
        pub otf_socket: ck_socket,
        pub otf_port: ::std::os::raw::c_long,
        pub otf_thread: pthread_t,
        pub stk_writeThread: *mut XWriteThread,
        pub stk_wvOutMap: map,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Carrier() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Carrier>(),
            128usize,
            concat!("Size of: ", stringify!(Chuck_Carrier))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Carrier>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Carrier))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).chuck as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(chuck)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).compiler as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(compiler)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).env as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(env)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).vm as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(vm)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).chout as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(chout)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).cherr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(cherr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_socket as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(otf_socket)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_port as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(otf_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).otf_thread as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(otf_thread)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Carrier>())).stk_writeThread as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(stk_writeThread)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Carrier>())).stk_wvOutMap as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Carrier),
                "::",
                stringify!(stk_wvOutMap)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}hintIsRealtimeAudio"]
        pub fn Chuck_Carrier_hintIsRealtimeAudio(
            this: *mut Chuck_Carrier,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Carrier"]
        pub fn Chuck_Carrier_Chuck_Carrier(this: *mut Chuck_Carrier);
    }
    impl Default for Chuck_Carrier {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Carrier {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Carrier {{ chuck: {:?}, compiler: {:?}, env: {:?}, vm: {:?}, chout: {:?}, cherr: {:?}, otf_socket: {:?}, otf_port: {:?}, otf_thread: {:?}, stk_writeThread: {:?}, stk_wvOutMap: {:?} }}" , self . chuck , self . compiler , self . env , self . vm , self . chout , self . cherr , self . otf_socket , self . otf_port , self . otf_thread , self . stk_writeThread , self . stk_wvOutMap )
        }
    }
    impl ::std::cmp::PartialEq for Chuck_Carrier {
        fn eq(&self, other: &Chuck_Carrier) -> bool {
            self.chuck == other.chuck
                && self.compiler == other.compiler
                && self.env == other.env
                && self.vm == other.vm
                && self.chout == other.chout
                && self.cherr == other.cherr
                && self.otf_socket == other.otf_socket
                && self.otf_port == other.otf_port
                && self.otf_thread == other.otf_thread
                && self.stk_writeThread == other.stk_writeThread
                && self.stk_wvOutMap == other.stk_wvOutMap
        }
    }
    impl Chuck_Carrier {
        #[inline]
        pub unsafe fn hintIsRealtimeAudio(&mut self) -> ::std::os::raw::c_ulong {
            Chuck_Carrier_hintIsRealtimeAudio(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Carrier_Chuck_Carrier(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __dirstream {
        _unused: [u8; 0],
    }
    pub type DIR = __dirstream;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_VM_Shred {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CBufferSimple {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct Chuck_VM_Object__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_VM_Object {
        pub vtable_: *const Chuck_VM_Object__bindgen_vtable,
        pub m_ref_count: ::std::os::raw::c_ulong,
        pub m_pooled: ::std::os::raw::c_ulong,
        pub m_locked: ::std::os::raw::c_ulong,
        pub m_v_ref: *mut vector,
    }
    extern "C" {
        #[link_name = "\u{1}our_locks_in_effect"]
        pub static mut Chuck_VM_Object_our_locks_in_effect: ::std::os::raw::c_ulong;
    }
    #[test]
    fn bindgen_test_layout_Chuck_VM_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_VM_Object>(),
            40usize,
            concat!("Size of: ", stringify!(Chuck_VM_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_VM_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_VM_Object))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_ref_count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_ref_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_pooled as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_pooled)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_locked as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_locked)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_v_ref as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_v_ref)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}lock_all"]
        pub fn Chuck_VM_Object_lock_all();
    }
    extern "C" {
        #[link_name = "\u{1}unlock_all"]
        pub fn Chuck_VM_Object_unlock_all();
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_VM_Object"]
        pub fn Chuck_VM_Object_Chuck_VM_Object(this: *mut Chuck_VM_Object);
    }
    impl Default for Chuck_VM_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_VM_Object {
        #[inline]
        pub unsafe fn lock_all() {
            Chuck_VM_Object_lock_all()
        }
        #[inline]
        pub unsafe fn unlock_all() {
            Chuck_VM_Object_unlock_all()
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_VM_Object_Chuck_VM_Object(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_VM_Object_destructor"]
        pub fn Chuck_VM_Object_Chuck_VM_Object_destructor(this: *mut Chuck_VM_Object);
    }
    extern "C" {
        #[link_name = "\u{1}add_ref"]
        pub fn Chuck_VM_Object_add_ref(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}release"]
        pub fn Chuck_VM_Object_release(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}lock"]
        pub fn Chuck_VM_Object_lock(this: *mut ::std::os::raw::c_void);
    }
    #[repr(C)]
    pub struct Chuck_VTable {
        pub funcs: vector,
    }
    #[test]
    fn bindgen_test_layout_Chuck_VTable() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_VTable>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_VTable))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_VTable>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_VTable))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VTable>())).funcs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VTable),
                "::",
                stringify!(funcs)
            )
        );
    }
    impl Default for Chuck_VTable {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_VTable {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "Chuck_VTable {{ funcs: {:?} }}", self.funcs)
        }
    }
    impl ::std::cmp::PartialEq for Chuck_VTable {
        fn eq(&self, other: &Chuck_VTable) -> bool {
            self.funcs == other.funcs
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Object {
        pub _base: Chuck_VM_Object,
        pub vtable: *mut Chuck_VTable,
        pub type_ref: *mut Chuck_Type,
        pub size: ::std::os::raw::c_ulong,
        pub data: *mut ::std::os::raw::c_uchar,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Object>(),
            72usize,
            concat!("Size of: ", stringify!(Chuck_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Object))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).vtable as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(vtable)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).type_ref as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(type_ref)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).size as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).data as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(data)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Object"]
        pub fn Chuck_Object_Chuck_Object(this: *mut Chuck_Object);
    }
    impl Default for Chuck_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Object {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Object_Chuck_Object(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Object_destructor"]
        pub fn Chuck_Object_Chuck_Object_destructor(this: *mut Chuck_Object);
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Array {
        pub _base: Chuck_Object,
        pub m_array_type: *mut Chuck_Type,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Array() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Array>(),
            80usize,
            concat!("Size of: ", stringify!(Chuck_Array))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Array>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Array))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Array>())).m_array_type as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Array),
                "::",
                stringify!(m_array_type)
            )
        );
    }
    impl Default for Chuck_Array {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    pub struct Chuck_Array4 {
        pub _base: Chuck_Array,
        pub m_vector: vector,
        pub m_map: map,
        pub m_is_obj: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Array4() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Array4>(),
            160usize,
            concat!("Size of: ", stringify!(Chuck_Array4))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Array4>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Array4))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Array4>())).m_vector as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Array4),
                "::",
                stringify!(m_vector)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Array4>())).m_map as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Array4),
                "::",
                stringify!(m_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Array4>())).m_is_obj as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Array4),
                "::",
                stringify!(m_is_obj)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}addr"]
        pub fn Chuck_Array4_addr(
            this: *mut Chuck_Array4,
            i: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}addr"]
        pub fn Chuck_Array4_addr1(
            this: *mut Chuck_Array4,
            key: *const string,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}get"]
        pub fn Chuck_Array4_get(
            this: *mut Chuck_Array4,
            i: ::std::os::raw::c_long,
            val: *mut ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}get"]
        pub fn Chuck_Array4_get1(
            this: *mut Chuck_Array4,
            key: *const string,
            val: *mut ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}set"]
        pub fn Chuck_Array4_set(
            this: *mut Chuck_Array4,
            i: ::std::os::raw::c_long,
            val: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}set"]
        pub fn Chuck_Array4_set1(
            this: *mut Chuck_Array4,
            key: *const string,
            val: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}push_back"]
        pub fn Chuck_Array4_push_back(
            this: *mut Chuck_Array4,
            val: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}pop_back"]
        pub fn Chuck_Array4_pop_back(this: *mut Chuck_Array4) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}back"]
        pub fn Chuck_Array4_back(
            this: *const Chuck_Array4,
            val: *mut ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}zero"]
        pub fn Chuck_Array4_zero(
            this: *mut Chuck_Array4,
            start: ::std::os::raw::c_ulong,
            end: ::std::os::raw::c_ulong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Array4"]
        pub fn Chuck_Array4_Chuck_Array4(
            this: *mut Chuck_Array4,
            is_obj: ::std::os::raw::c_ulong,
            capacity: ::std::os::raw::c_long,
        );
    }
    impl Default for Chuck_Array4 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Array4 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Array4 {{ m_vector: {:?}, m_map: {:?}, m_is_obj: {:?} }}",
                self.m_vector, self.m_map, self.m_is_obj
            )
        }
    }
    impl Chuck_Array4 {
        #[inline]
        pub unsafe fn addr(&mut self, i: ::std::os::raw::c_long) -> ::std::os::raw::c_ulong {
            Chuck_Array4_addr(self, i)
        }
        #[inline]
        pub unsafe fn addr1(&mut self, key: *const string) -> ::std::os::raw::c_ulong {
            Chuck_Array4_addr1(self, key)
        }
        #[inline]
        pub unsafe fn get(
            &mut self,
            i: ::std::os::raw::c_long,
            val: *mut ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long {
            Chuck_Array4_get(self, i, val)
        }
        #[inline]
        pub unsafe fn get1(
            &mut self,
            key: *const string,
            val: *mut ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long {
            Chuck_Array4_get1(self, key, val)
        }
        #[inline]
        pub unsafe fn set(
            &mut self,
            i: ::std::os::raw::c_long,
            val: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long {
            Chuck_Array4_set(self, i, val)
        }
        #[inline]
        pub unsafe fn set1(
            &mut self,
            key: *const string,
            val: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long {
            Chuck_Array4_set1(self, key, val)
        }
        #[inline]
        pub unsafe fn push_back(&mut self, val: ::std::os::raw::c_ulong) -> ::std::os::raw::c_long {
            Chuck_Array4_push_back(self, val)
        }
        #[inline]
        pub unsafe fn pop_back(&mut self) -> ::std::os::raw::c_long {
            Chuck_Array4_pop_back(self)
        }
        #[inline]
        pub unsafe fn back(&self, val: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_long {
            Chuck_Array4_back(self, val)
        }
        #[inline]
        pub unsafe fn zero(
            &mut self,
            start: ::std::os::raw::c_ulong,
            end: ::std::os::raw::c_ulong,
        ) {
            Chuck_Array4_zero(self, start, end)
        }
        #[inline]
        pub unsafe fn new(
            is_obj: ::std::os::raw::c_ulong,
            capacity: ::std::os::raw::c_long,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Array4_Chuck_Array4(&mut __bindgen_tmp, is_obj, capacity);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Array4_destructor"]
        pub fn Chuck_Array4_Chuck_Array4_destructor(this: *mut Chuck_Array4);
    }
    extern "C" {
        #[link_name = "\u{1}clear"]
        pub fn Chuck_Array4_clear(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}size"]
        pub fn Chuck_Array4_size(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}capacity"]
        pub fn Chuck_Array4_capacity(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}set_size"]
        pub fn Chuck_Array4_set_size(
            this: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}set_capacity"]
        pub fn Chuck_Array4_set_capacity(
            this: *mut ::std::os::raw::c_void,
            capacity: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}find"]
        pub fn Chuck_Array4_find(
            this: *mut ::std::os::raw::c_void,
            key: *const string,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}erase"]
        pub fn Chuck_Array4_erase(
            this: *mut ::std::os::raw::c_void,
            key: *const string,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}data_type_size"]
        pub fn Chuck_Array4_data_type_size(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}data_type_kind"]
        pub fn Chuck_Array4_data_type_kind(
            this: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long;
    }
    #[repr(C)]
    pub struct Chuck_Event {
        pub _base: Chuck_Object,
        pub m_queue: queue<deque>,
        pub m_queue_lock: XMutex,
    }
    extern "C" {
        #[link_name = "\u{1}our_can_wait"]
        pub static mut Chuck_Event_our_can_wait: ::std::os::raw::c_ulong;
    }
    #[test]
    fn bindgen_test_layout_Chuck_Event() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Event>(),
            192usize,
            concat!("Size of: ", stringify!(Chuck_Event))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Event>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Event))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Event>())).m_queue as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Event),
                "::",
                stringify!(m_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Event>())).m_queue_lock as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Event),
                "::",
                stringify!(m_queue_lock)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}signal"]
        pub fn Chuck_Event_signal(this: *mut Chuck_Event);
    }
    extern "C" {
        #[link_name = "\u{1}broadcast"]
        pub fn Chuck_Event_broadcast(this: *mut Chuck_Event);
    }
    extern "C" {
        #[link_name = "\u{1}wait"]
        pub fn Chuck_Event_wait(
            this: *mut Chuck_Event,
            shred: *mut Chuck_VM_Shred,
            vm: *mut Chuck_VM,
        );
    }
    extern "C" {
        #[link_name = "\u{1}remove"]
        pub fn Chuck_Event_remove(
            this: *mut Chuck_Event,
            shred: *mut Chuck_VM_Shred,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}queue_broadcast"]
        pub fn Chuck_Event_queue_broadcast(
            this: *mut Chuck_Event,
            event_buffer: *mut CBufferSimple,
        );
    }
    impl Default for Chuck_Event {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Event {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Event {{ m_queue: {:?}, m_queue_lock: {:?} }}",
                self.m_queue, self.m_queue_lock
            )
        }
    }
    impl Chuck_Event {
        #[inline]
        pub unsafe fn signal(&mut self) {
            Chuck_Event_signal(self)
        }
        #[inline]
        pub unsafe fn broadcast(&mut self) {
            Chuck_Event_broadcast(self)
        }
        #[inline]
        pub unsafe fn wait(&mut self, shred: *mut Chuck_VM_Shred, vm: *mut Chuck_VM) {
            Chuck_Event_wait(self, shred, vm)
        }
        #[inline]
        pub unsafe fn remove(&mut self, shred: *mut Chuck_VM_Shred) -> ::std::os::raw::c_ulong {
            Chuck_Event_remove(self, shred)
        }
        #[inline]
        pub unsafe fn queue_broadcast(&mut self, event_buffer: *mut CBufferSimple) {
            Chuck_Event_queue_broadcast(self, event_buffer)
        }
    }
    #[repr(C)]
    pub struct Chuck_String {
        pub _base: Chuck_Object,
        pub m_charptr: *const ::std::os::raw::c_char,
        pub m_str: string,
    }
    #[test]
    fn bindgen_test_layout_Chuck_String() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_String>(),
            112usize,
            concat!("Size of: ", stringify!(Chuck_String))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_String>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_String))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_String>())).m_charptr as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_String),
                "::",
                stringify!(m_charptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_String>())).m_str as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_String),
                "::",
                stringify!(m_str)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set"]
        pub fn Chuck_String_set(this: *mut Chuck_String, s: *const string);
    }
    extern "C" {
        #[link_name = "\u{1}str"]
        pub fn Chuck_String_str(this: *mut Chuck_String) -> *const string;
    }
    extern "C" {
        #[link_name = "\u{1}c_str"]
        pub fn Chuck_String_c_str(this: *mut Chuck_String) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_String"]
        pub fn Chuck_String_Chuck_String(this: *mut Chuck_String, s: *const string);
    }
    impl Default for Chuck_String {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_String {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_String {{ m_charptr: {:?}, m_str: {:?} }}",
                self.m_charptr, self.m_str
            )
        }
    }
    impl Chuck_String {
        #[inline]
        pub unsafe fn set(&mut self, s: *const string) {
            Chuck_String_set(self, s)
        }
        #[inline]
        pub unsafe fn str(&mut self) -> *const string {
            Chuck_String_str(self)
        }
        #[inline]
        pub unsafe fn c_str(&mut self) -> *const ::std::os::raw::c_char {
            Chuck_String_c_str(self)
        }
        #[inline]
        pub unsafe fn new(s: *const string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_String_Chuck_String(&mut __bindgen_tmp, s);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_String_destructor"]
        pub fn Chuck_String_Chuck_String_destructor(this: *mut Chuck_String);
    }
    #[repr(C)]
    pub struct Chuck_IO {
        pub _base: Chuck_Event,
        pub m_asyncEvent: *mut Chuck_Event,
        pub m_thread: *mut XThread,
    }
    #[repr(C)]
    pub struct Chuck_IO_async_args {
        pub fileio_obj: *mut Chuck_IO_File,
        pub RETURN: *mut ::std::os::raw::c_void,
        pub intArg: ::std::os::raw::c_long,
        pub floatArg: f64,
        pub stringArg: string,
    }
    #[test]
    fn bindgen_test_layout_Chuck_IO_async_args() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_IO_async_args>(),
            64usize,
            concat!("Size of: ", stringify!(Chuck_IO_async_args))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_IO_async_args>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_IO_async_args))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_IO_async_args>())).fileio_obj as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_async_args),
                "::",
                stringify!(fileio_obj)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_async_args>())).RETURN as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_async_args),
                "::",
                stringify!(RETURN)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_async_args>())).intArg as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_async_args),
                "::",
                stringify!(intArg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_IO_async_args>())).floatArg as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_async_args),
                "::",
                stringify!(floatArg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_IO_async_args>())).stringArg as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_async_args),
                "::",
                stringify!(stringArg)
            )
        );
    }
    impl Default for Chuck_IO_async_args {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_IO_async_args {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_IO_async_args {{ fileio_obj: {:?}, RETURN: {:?}, intArg: {:?}, floatArg: {:?}, stringArg: {:?} }}" , self . fileio_obj , self . RETURN , self . intArg , self . floatArg , self . stringArg )
        }
    }
    extern "C" {
        #[link_name = "\u{1}INT32"]
        pub static Chuck_IO_INT32: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}INT16"]
        pub static Chuck_IO_INT16: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}INT8"]
        pub static Chuck_IO_INT8: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}MODE_SYNC"]
        pub static Chuck_IO_MODE_SYNC: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}MODE_ASYNC"]
        pub static Chuck_IO_MODE_ASYNC: ::std::os::raw::c_long;
    }
    #[test]
    fn bindgen_test_layout_Chuck_IO() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_IO>(),
            208usize,
            concat!("Size of: ", stringify!(Chuck_IO))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_IO>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_IO))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO>())).m_asyncEvent as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO),
                "::",
                stringify!(m_asyncEvent)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO>())).m_thread as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO),
                "::",
                stringify!(m_thread)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO"]
        pub fn Chuck_IO_Chuck_IO(this: *mut Chuck_IO);
    }
    impl Default for Chuck_IO {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_IO {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_IO {{ m_asyncEvent: {:?}, m_thread: {:?} }}",
                self.m_asyncEvent, self.m_thread
            )
        }
    }
    impl Chuck_IO {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_IO_Chuck_IO(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_destructor"]
        pub fn Chuck_IO_Chuck_IO_destructor(this: *mut Chuck_IO);
    }
    #[repr(C)]
    pub struct Chuck_IO_File {
        pub _base: Chuck_IO,
        pub m_flags: ::std::os::raw::c_long,
        pub m_iomode: ::std::os::raw::c_long,
        pub m_io: fstream,
        pub m_dir: *mut DIR,
        pub m_dir_start: ::std::os::raw::c_long,
        pub m_path: string,
        pub m_vmRef: *mut Chuck_VM,
    }
    extern "C" {
        #[link_name = "\u{1}FLAG_READ_WRITE"]
        pub static Chuck_IO_File_FLAG_READ_WRITE: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}FLAG_READONLY"]
        pub static Chuck_IO_File_FLAG_READONLY: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}FLAG_WRITEONLY"]
        pub static Chuck_IO_File_FLAG_WRITEONLY: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}FLAG_APPEND"]
        pub static Chuck_IO_File_FLAG_APPEND: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}TYPE_ASCII"]
        pub static Chuck_IO_File_TYPE_ASCII: ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}TYPE_BINARY"]
        pub static Chuck_IO_File_TYPE_BINARY: ::std::os::raw::c_long;
    }
    #[test]
    fn bindgen_test_layout_Chuck_IO_File() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_IO_File>(),
            808usize,
            concat!("Size of: ", stringify!(Chuck_IO_File))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_IO_File>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_IO_File))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_flags as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_iomode as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_iomode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_io as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_io)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_dir as *const _ as usize },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_dir)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_dir_start as *const _ as usize },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_dir_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_path as *const _ as usize },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_path)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_File>())).m_vmRef as *const _ as usize },
            800usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_File),
                "::",
                stringify!(m_vmRef)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}writeStr_thread"]
        pub fn Chuck_IO_File_writeStr_thread(data: *mut ::std::os::raw::c_void) -> THREAD_RETURN;
    }
    extern "C" {
        #[link_name = "\u{1}writeInt_thread"]
        pub fn Chuck_IO_File_writeInt_thread(data: *mut ::std::os::raw::c_void) -> THREAD_RETURN;
    }
    extern "C" {
        #[link_name = "\u{1}writeFloat_thread"]
        pub fn Chuck_IO_File_writeFloat_thread(data: *mut ::std::os::raw::c_void) -> THREAD_RETURN;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_File"]
        pub fn Chuck_IO_File_Chuck_IO_File(this: *mut Chuck_IO_File, vm: *mut Chuck_VM);
    }
    impl Default for Chuck_IO_File {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_IO_File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_IO_File {{ m_flags: {:?}, m_iomode: {:?}, m_io: {:?}, m_dir: {:?}, m_dir_start: {:?}, m_path: {:?}, m_vmRef: {:?} }}" , self . m_flags , self . m_iomode , self . m_io , self . m_dir , self . m_dir_start , self . m_path , self . m_vmRef )
        }
    }
    impl Chuck_IO_File {
        #[inline]
        pub unsafe fn writeStr_thread(data: *mut ::std::os::raw::c_void) -> THREAD_RETURN {
            Chuck_IO_File_writeStr_thread(data)
        }
        #[inline]
        pub unsafe fn writeInt_thread(data: *mut ::std::os::raw::c_void) -> THREAD_RETURN {
            Chuck_IO_File_writeInt_thread(data)
        }
        #[inline]
        pub unsafe fn writeFloat_thread(data: *mut ::std::os::raw::c_void) -> THREAD_RETURN {
            Chuck_IO_File_writeFloat_thread(data)
        }
        #[inline]
        pub unsafe fn new(vm: *mut Chuck_VM) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_IO_File_Chuck_IO_File(&mut __bindgen_tmp, vm);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_File_destructor"]
        pub fn Chuck_IO_File_Chuck_IO_File_destructor(this: *mut Chuck_IO_File);
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn Chuck_IO_File_open(
            this: *mut ::std::os::raw::c_void,
            path: *const string,
            flags: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}good"]
        pub fn Chuck_IO_File_good(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn Chuck_IO_File_close(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}flush"]
        pub fn Chuck_IO_File_flush(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}mode"]
        pub fn Chuck_IO_File_mode(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}mode"]
        pub fn Chuck_IO_File_mode1(this: *mut ::std::os::raw::c_void, flag: ::std::os::raw::c_long);
    }
    extern "C" {
        #[link_name = "\u{1}size"]
        pub fn Chuck_IO_File_size(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}seek"]
        pub fn Chuck_IO_File_seek(this: *mut ::std::os::raw::c_void, pos: ::std::os::raw::c_long);
    }
    extern "C" {
        #[link_name = "\u{1}tell"]
        pub fn Chuck_IO_File_tell(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}isDir"]
        pub fn Chuck_IO_File_isDir(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}dirList"]
        pub fn Chuck_IO_File_dirList(this: *mut ::std::os::raw::c_void) -> *mut Chuck_Array4;
    }
    extern "C" {
        #[link_name = "\u{1}readLine"]
        pub fn Chuck_IO_File_readLine(this: *mut ::std::os::raw::c_void) -> *mut Chuck_String;
    }
    extern "C" {
        #[link_name = "\u{1}readInt"]
        pub fn Chuck_IO_File_readInt(
            this: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}readFloat"]
        pub fn Chuck_IO_File_readFloat(this: *mut ::std::os::raw::c_void) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}readString"]
        pub fn Chuck_IO_File_readString(
            this: *mut ::std::os::raw::c_void,
            str: *mut string,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}eof"]
        pub fn Chuck_IO_File_eof(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_File_write(this: *mut ::std::os::raw::c_void, val: *const string);
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_File_write1(this: *mut ::std::os::raw::c_void, val: ::std::os::raw::c_long);
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_File_write2(
            this: *mut ::std::os::raw::c_void,
            val: ::std::os::raw::c_long,
            flags: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_File_write3(this: *mut ::std::os::raw::c_void, val: f64);
    }
    #[repr(C)]
    pub struct Chuck_IO_Chout {
        pub _base: Chuck_IO,
        pub m_callback:
            ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
        pub m_buffer: stringstream,
    }
    #[test]
    fn bindgen_test_layout_Chuck_IO_Chout() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_IO_Chout>(),
            608usize,
            concat!("Size of: ", stringify!(Chuck_IO_Chout))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_IO_Chout>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_IO_Chout))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_Chout>())).m_callback as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_Chout),
                "::",
                stringify!(m_callback)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_Chout>())).m_buffer as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_Chout),
                "::",
                stringify!(m_buffer)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set_output_callback"]
        pub fn Chuck_IO_Chout_set_output_callback(
            this: *mut Chuck_IO_Chout,
            fp: ::std::option::Option<
                unsafe extern "C" fn(this: *mut Chuck_IO_Chout, fp: *const ::std::os::raw::c_char),
            >,
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_Chout"]
        pub fn Chuck_IO_Chout_Chuck_IO_Chout(
            this: *mut Chuck_IO_Chout,
            carrier: *mut Chuck_Carrier,
        );
    }
    impl Default for Chuck_IO_Chout {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_IO_Chout {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_IO_Chout {{ m_callback: {:?}, m_buffer: {:?} }}",
                self.m_callback, self.m_buffer
            )
        }
    }
    impl Chuck_IO_Chout {
        #[inline]
        pub unsafe fn set_output_callback(
            &mut self,
            fp: ::std::option::Option<
                unsafe extern "C" fn(this: *mut Chuck_IO_Chout, fp: *const ::std::os::raw::c_char),
            >,
        ) {
            Chuck_IO_Chout_set_output_callback(self, fp)
        }
        #[inline]
        pub unsafe fn new(carrier: *mut Chuck_Carrier) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_IO_Chout_Chuck_IO_Chout(&mut __bindgen_tmp, carrier);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_Chout_destructor"]
        pub fn Chuck_IO_Chout_Chuck_IO_Chout_destructor(this: *mut Chuck_IO_Chout);
    }
    extern "C" {
        #[link_name = "\u{1}good"]
        pub fn Chuck_IO_Chout_good(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn Chuck_IO_Chout_close(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}flush"]
        pub fn Chuck_IO_Chout_flush(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}mode"]
        pub fn Chuck_IO_Chout_mode(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}mode"]
        pub fn Chuck_IO_Chout_mode1(
            this: *mut ::std::os::raw::c_void,
            flag: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}readLine"]
        pub fn Chuck_IO_Chout_readLine(this: *mut ::std::os::raw::c_void) -> *mut Chuck_String;
    }
    extern "C" {
        #[link_name = "\u{1}readInt"]
        pub fn Chuck_IO_Chout_readInt(
            this: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}readFloat"]
        pub fn Chuck_IO_Chout_readFloat(this: *mut ::std::os::raw::c_void) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}readString"]
        pub fn Chuck_IO_Chout_readString(
            this: *mut ::std::os::raw::c_void,
            str: *mut string,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}eof"]
        pub fn Chuck_IO_Chout_eof(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Chout_write(this: *mut ::std::os::raw::c_void, val: *const string);
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Chout_write1(
            this: *mut ::std::os::raw::c_void,
            val: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Chout_write2(
            this: *mut ::std::os::raw::c_void,
            val: ::std::os::raw::c_long,
            flags: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Chout_write3(this: *mut ::std::os::raw::c_void, val: f64);
    }
    #[repr(C)]
    pub struct Chuck_IO_Cherr {
        pub _base: Chuck_IO,
        pub m_callback:
            ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
        pub m_buffer: stringstream,
    }
    #[test]
    fn bindgen_test_layout_Chuck_IO_Cherr() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_IO_Cherr>(),
            608usize,
            concat!("Size of: ", stringify!(Chuck_IO_Cherr))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_IO_Cherr>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_IO_Cherr))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_Cherr>())).m_callback as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_Cherr),
                "::",
                stringify!(m_callback)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_IO_Cherr>())).m_buffer as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_IO_Cherr),
                "::",
                stringify!(m_buffer)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set_output_callback"]
        pub fn Chuck_IO_Cherr_set_output_callback(
            this: *mut Chuck_IO_Cherr,
            fp: ::std::option::Option<
                unsafe extern "C" fn(this: *mut Chuck_IO_Cherr, fp: *const ::std::os::raw::c_char),
            >,
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_Cherr"]
        pub fn Chuck_IO_Cherr_Chuck_IO_Cherr(
            this: *mut Chuck_IO_Cherr,
            carrier: *mut Chuck_Carrier,
        );
    }
    impl Default for Chuck_IO_Cherr {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_IO_Cherr {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_IO_Cherr {{ m_callback: {:?}, m_buffer: {:?} }}",
                self.m_callback, self.m_buffer
            )
        }
    }
    impl Chuck_IO_Cherr {
        #[inline]
        pub unsafe fn set_output_callback(
            &mut self,
            fp: ::std::option::Option<
                unsafe extern "C" fn(this: *mut Chuck_IO_Cherr, fp: *const ::std::os::raw::c_char),
            >,
        ) {
            Chuck_IO_Cherr_set_output_callback(self, fp)
        }
        #[inline]
        pub unsafe fn new(carrier: *mut Chuck_Carrier) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_IO_Cherr_Chuck_IO_Cherr(&mut __bindgen_tmp, carrier);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_IO_Cherr_destructor"]
        pub fn Chuck_IO_Cherr_Chuck_IO_Cherr_destructor(this: *mut Chuck_IO_Cherr);
    }
    extern "C" {
        #[link_name = "\u{1}good"]
        pub fn Chuck_IO_Cherr_good(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn Chuck_IO_Cherr_close(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}flush"]
        pub fn Chuck_IO_Cherr_flush(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}mode"]
        pub fn Chuck_IO_Cherr_mode(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}mode"]
        pub fn Chuck_IO_Cherr_mode1(
            this: *mut ::std::os::raw::c_void,
            flag: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}readLine"]
        pub fn Chuck_IO_Cherr_readLine(this: *mut ::std::os::raw::c_void) -> *mut Chuck_String;
    }
    extern "C" {
        #[link_name = "\u{1}readInt"]
        pub fn Chuck_IO_Cherr_readInt(
            this: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}readFloat"]
        pub fn Chuck_IO_Cherr_readFloat(this: *mut ::std::os::raw::c_void) -> f64;
    }
    extern "C" {
        #[link_name = "\u{1}readString"]
        pub fn Chuck_IO_Cherr_readString(
            this: *mut ::std::os::raw::c_void,
            str: *mut string,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}eof"]
        pub fn Chuck_IO_Cherr_eof(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Cherr_write(this: *mut ::std::os::raw::c_void, val: *const string);
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Cherr_write1(
            this: *mut ::std::os::raw::c_void,
            val: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Cherr_write2(
            this: *mut ::std::os::raw::c_void,
            val: ::std::os::raw::c_long,
            flags: ::std::os::raw::c_long,
        );
    }
    extern "C" {
        #[link_name = "\u{1}write"]
        pub fn Chuck_IO_Cherr_write3(this: *mut ::std::os::raw::c_void, val: f64);
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_UAna {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_UAnaBlobProxy {
        _unused: [u8; 0],
    }
    pub mod Chuck_DL_Api {

        pub type Object = *mut ::std::os::raw::c_void;
        pub type Type = *mut ::std::os::raw::c_void;
        pub type String = *mut ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct Api {
            pub vm: *mut Api_VMApi,
            pub object: *mut Api_ObjectApi,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct Api_VMApi {
            pub get_srate: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    arg2: *mut Chuck_VM_Shred,
                ) -> ::std::os::raw::c_ulong,
            >,
        }
        #[test]
        fn bindgen_test_layout_Api_VMApi() {
            assert_eq!(
                ::std::mem::size_of::<Api_VMApi>(),
                8usize,
                concat!("Size of: ", stringify!(Api_VMApi))
            );
            assert_eq!(
                ::std::mem::align_of::<Api_VMApi>(),
                8usize,
                concat!("Alignment of ", stringify!(Api_VMApi))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Api_VMApi>())).get_srate as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_VMApi),
                    "::",
                    stringify!(get_srate)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}VMApi"]
            pub fn Api_VMApi_VMApi(this: *mut Api_VMApi);
        }
        impl Default for Api_VMApi {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Api_VMApi {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Api_VMApi_VMApi(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct Api_ObjectApi {
            pub get_type: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    arg2: *mut Chuck_VM_Shred,
                    name: *mut string,
                ) -> Type,
            >,
            pub create: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    arg2: *mut Chuck_VM_Shred,
                    type_: Type,
                ) -> Object,
            >,
            pub create_string: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    arg2: *mut Chuck_VM_Shred,
                    value: *mut string,
                ) -> String,
            >,
            pub get_mvar_int: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    object: Object,
                    name: *mut string,
                    value: *mut ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_ulong,
            >,
            pub get_mvar_float: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    object: Object,
                    name: *mut string,
                    value: *mut f64,
                ) -> ::std::os::raw::c_ulong,
            >,
            pub get_mvar_dur: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    object: Object,
                    name: *mut string,
                    value: *mut f64,
                ) -> ::std::os::raw::c_ulong,
            >,
            pub get_mvar_time: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    object: Object,
                    name: *mut string,
                    value: *mut f64,
                ) -> ::std::os::raw::c_ulong,
            >,
            pub get_mvar_string: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    object: Object,
                    name: *mut string,
                    value: *mut String,
                ) -> ::std::os::raw::c_ulong,
            >,
            pub get_mvar_object: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    object: Object,
                    name: *mut string,
                    value: *mut Object,
                ) -> ::std::os::raw::c_ulong,
            >,
            pub set_string: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: CK_DL_API,
                    string: String,
                    value: *mut string,
                ) -> ::std::os::raw::c_ulong,
            >,
        }
        #[test]
        fn bindgen_test_layout_Api_ObjectApi() {
            assert_eq!(
                ::std::mem::size_of::<Api_ObjectApi>(),
                80usize,
                concat!("Size of: ", stringify!(Api_ObjectApi))
            );
            assert_eq!(
                ::std::mem::align_of::<Api_ObjectApi>(),
                8usize,
                concat!("Alignment of ", stringify!(Api_ObjectApi))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Api_ObjectApi>())).get_type as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_type)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Api_ObjectApi>())).create as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(create)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).create_string as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(create_string)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).get_mvar_int as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_mvar_int)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).get_mvar_float as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_mvar_float)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).get_mvar_dur as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_mvar_dur)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).get_mvar_time as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_mvar_time)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).get_mvar_string as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_mvar_string)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).get_mvar_object as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(get_mvar_object)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<Api_ObjectApi>())).set_string as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api_ObjectApi),
                    "::",
                    stringify!(set_string)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}ObjectApi"]
            pub fn Api_ObjectApi_ObjectApi(this: *mut Api_ObjectApi);
        }
        impl Default for Api_ObjectApi {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Api_ObjectApi {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Api_ObjectApi_ObjectApi(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}g_api"]
            pub static mut Api_g_api: Api;
        }
        #[test]
        fn bindgen_test_layout_Api() {
            assert_eq!(
                ::std::mem::size_of::<Api>(),
                16usize,
                concat!("Size of: ", stringify!(Api))
            );
            assert_eq!(
                ::std::mem::align_of::<Api>(),
                8usize,
                concat!("Alignment of ", stringify!(Api))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Api>())).vm as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(Api), "::", stringify!(vm))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Api>())).object as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Api),
                    "::",
                    stringify!(object)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}instance"]
            pub fn Api_instance() -> *const Api;
        }
        extern "C" {
            #[link_name = "\u{1}Api"]
            pub fn Api_Api(this: *mut Api);
        }
        impl Default for Api {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Api {
            #[inline]
            pub unsafe fn instance() -> *const Api {
                Api_instance()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Api_Api(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
    }
    pub type CK_DL_API = *const Api;
    pub type f_alloc = ::std::option::Option<
        unsafe extern "C" fn(
            VM: *mut Chuck_VM,
            SHRED: *mut Chuck_VM_Shred,
            API: CK_DL_API,
        ) -> *mut Chuck_Object,
    >;
    pub type f_tick = ::std::option::Option<
        unsafe extern "C" fn(
            SELF: *mut Chuck_Object,
            in_: f64,
            out: *mut f64,
            API: CK_DL_API,
        ) -> ::std::os::raw::c_ulong,
    >;
    pub type f_tickf = ::std::option::Option<
        unsafe extern "C" fn(
            SELF: *mut Chuck_Object,
            in_: *mut f64,
            out: *mut f64,
            nframes: ::std::os::raw::c_ulong,
            API: CK_DL_API,
        ) -> ::std::os::raw::c_ulong,
    >;
    pub type f_pmsg = ::std::option::Option<
        unsafe extern "C" fn(
            SELF: *mut Chuck_Object,
            MSG: *const ::std::os::raw::c_char,
            ARGS: *mut ::std::os::raw::c_void,
            VM: *mut Chuck_VM,
            SHRED: *mut Chuck_VM_Shred,
            API: CK_DL_API,
        ) -> ::std::os::raw::c_ulong,
    >;
    pub type f_tock = ::std::option::Option<
        unsafe extern "C" fn(
            SELF: *mut Chuck_Object,
            UANA: *mut Chuck_UAna,
            BLOB: *mut Chuck_UAnaBlobProxy,
            API: CK_DL_API,
        ) -> ::std::os::raw::c_ulong,
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum te_Type {
        te_none = 0,
        te_int = 1,
        te_uint = 2,
        te_single = 3,
        te_float = 4,
        te_double = 5,
        te_time = 6,
        te_dur = 7,
        te_complex = 8,
        te_polar = 9,
        te_string = 10,
        te_thread = 11,
        te_shred = 12,
        te_class = 13,
        te_function = 14,
        te_object = 15,
        te_user = 16,
        te_array = 17,
        te_null = 18,
        te_ugen = 19,
        te_uana = 20,
        te_event = 21,
        te_void = 22,
        te_stdout = 23,
        te_stderr = 24,
        te_adc = 25,
        te_dac = 26,
        te_bunghole = 27,
        te_uanablob = 28,
        te_io = 29,
        te_fileio = 30,
        te_chout = 31,
        te_cherr = 32,
        te_multi = 33,
        te_vec3 = 34,
        te_vec4 = 35,
        te_vector = 36,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum te_GlobalType {
        te_globalInt = 0,
        te_globalFloat = 1,
        te_globalEvent = 2,
    }
    #[repr(C)]
    pub struct Chuck_Scope {
        pub scope: vector,
        pub commit_map: map,
    }
    impl Default for Chuck_Scope {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Scope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Scope {{ scope: {:?}, commit_map: {:?} }}",
                self.scope, self.commit_map
            )
        }
    }
    impl ::std::cmp::PartialEq for Chuck_Scope {
        fn eq(&self, other: &Chuck_Scope) -> bool {
            self.scope == other.scope && self.commit_map == other.commit_map
        }
    }
    #[repr(C)]
    pub struct Chuck_Namespace {
        pub _base: Chuck_VM_Object,
        pub type_: Chuck_Scope,
        pub value: Chuck_Scope,
        pub func: Chuck_Scope,
        pub obj_v_table: Chuck_VTable,
        pub class_data: *mut ::std::os::raw::c_uchar,
        pub class_data_size: ::std::os::raw::c_ulong,
        pub name: string,
        pub pre_ctor: *mut Chuck_VM_Code,
        pub dtor: *mut Chuck_VM_Code,
        pub parent: *mut Chuck_Namespace,
        pub offset: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Namespace() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Namespace>(),
            360usize,
            concat!("Size of: ", stringify!(Chuck_Namespace))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Namespace>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Namespace))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).type_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).value as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(value)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).func as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).obj_v_table as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(obj_v_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).class_data as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(class_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Namespace>())).class_data_size as *const _ as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(class_data_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).name as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).pre_ctor as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(pre_ctor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).dtor as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(dtor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).parent as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Namespace>())).offset as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Namespace),
                "::",
                stringify!(offset)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}lookup_type"]
        pub fn Chuck_Namespace_lookup_type(
            this: *mut Chuck_Namespace,
            name: *const string,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Type;
    }
    extern "C" {
        #[link_name = "\u{1}lookup_type"]
        pub fn Chuck_Namespace_lookup_type1(
            this: *mut Chuck_Namespace,
            name: S_Symbol,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Type;
    }
    extern "C" {
        #[link_name = "\u{1}lookup_value"]
        pub fn Chuck_Namespace_lookup_value(
            this: *mut Chuck_Namespace,
            name: *const string,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Value;
    }
    extern "C" {
        #[link_name = "\u{1}lookup_value"]
        pub fn Chuck_Namespace_lookup_value1(
            this: *mut Chuck_Namespace,
            name: S_Symbol,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Value;
    }
    extern "C" {
        #[link_name = "\u{1}lookup_func"]
        pub fn Chuck_Namespace_lookup_func(
            this: *mut Chuck_Namespace,
            name: *const string,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Func;
    }
    extern "C" {
        #[link_name = "\u{1}lookup_func"]
        pub fn Chuck_Namespace_lookup_func1(
            this: *mut Chuck_Namespace,
            name: S_Symbol,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Func;
    }
    extern "C" {
        #[link_name = "\u{1}commit"]
        pub fn Chuck_Namespace_commit(this: *mut Chuck_Namespace);
    }
    extern "C" {
        #[link_name = "\u{1}rollback"]
        pub fn Chuck_Namespace_rollback(this: *mut Chuck_Namespace);
    }
    extern "C" {
        #[link_name = "\u{1}get_types"]
        pub fn Chuck_Namespace_get_types(this: *mut Chuck_Namespace, out: *mut vector);
    }
    extern "C" {
        #[link_name = "\u{1}get_values"]
        pub fn Chuck_Namespace_get_values(this: *mut Chuck_Namespace, out: *mut vector);
    }
    extern "C" {
        #[link_name = "\u{1}get_funcs"]
        pub fn Chuck_Namespace_get_funcs(this: *mut Chuck_Namespace, out: *mut vector);
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Namespace"]
        pub fn Chuck_Namespace_Chuck_Namespace(this: *mut Chuck_Namespace);
    }
    impl Default for Chuck_Namespace {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Namespace {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Namespace {{ type: {:?}, value: {:?}, func: {:?}, obj_v_table: {:?}, class_data: {:?}, class_data_size: {:?}, name: {:?}, pre_ctor: {:?}, dtor: {:?}, parent: {:?}, offset: {:?} }}" , self . type_ , self . value , self . func , self . obj_v_table , self . class_data , self . class_data_size , self . name , self . pre_ctor , self . dtor , self . parent , self . offset )
        }
    }
    impl Chuck_Namespace {
        #[inline]
        pub unsafe fn lookup_type(
            &mut self,
            name: *const string,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Type {
            Chuck_Namespace_lookup_type(self, name, climb)
        }
        #[inline]
        pub unsafe fn lookup_type1(
            &mut self,
            name: S_Symbol,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Type {
            Chuck_Namespace_lookup_type1(self, name, climb)
        }
        #[inline]
        pub unsafe fn lookup_value(
            &mut self,
            name: *const string,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Value {
            Chuck_Namespace_lookup_value(self, name, climb)
        }
        #[inline]
        pub unsafe fn lookup_value1(
            &mut self,
            name: S_Symbol,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Value {
            Chuck_Namespace_lookup_value1(self, name, climb)
        }
        #[inline]
        pub unsafe fn lookup_func(
            &mut self,
            name: *const string,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Func {
            Chuck_Namespace_lookup_func(self, name, climb)
        }
        #[inline]
        pub unsafe fn lookup_func1(
            &mut self,
            name: S_Symbol,
            climb: ::std::os::raw::c_long,
        ) -> *mut Chuck_Func {
            Chuck_Namespace_lookup_func1(self, name, climb)
        }
        #[inline]
        pub unsafe fn commit(&mut self) {
            Chuck_Namespace_commit(self)
        }
        #[inline]
        pub unsafe fn rollback(&mut self) {
            Chuck_Namespace_rollback(self)
        }
        #[inline]
        pub unsafe fn get_types(&mut self, out: *mut vector) {
            Chuck_Namespace_get_types(self, out)
        }
        #[inline]
        pub unsafe fn get_values(&mut self, out: *mut vector) {
            Chuck_Namespace_get_values(self, out)
        }
        #[inline]
        pub unsafe fn get_funcs(&mut self, out: *mut vector) {
            Chuck_Namespace_get_funcs(self, out)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Namespace_Chuck_Namespace(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Namespace_destructor"]
        pub fn Chuck_Namespace_Chuck_Namespace_destructor(this: *mut Chuck_Namespace);
    }
    #[repr(C)]
    pub struct Chuck_Context {
        pub _base: Chuck_VM_Object,
        pub filename: string,
        pub full_path: string,
        pub parse_tree: a_Program,
        pub nspc: *mut Chuck_Namespace,
        pub public_class_def: a_Class_Def,
        pub has_error: ::std::os::raw::c_ulong,
        pub progress: ::std::os::raw::c_ulong,
        pub new_types: vector,
        pub new_values: vector,
        pub new_funcs: vector,
        pub new_nspc: vector,
        pub commit_map: map,
    }
    pub const Chuck_Context_P_NONE: Chuck_Context__bindgen_ty_1 =
        Chuck_Context__bindgen_ty_1::P_NONE;
    pub const Chuck_Context_P_CLASSES_ONLY: Chuck_Context__bindgen_ty_1 =
        Chuck_Context__bindgen_ty_1::P_CLASSES_ONLY;
    pub const Chuck_Context_P_ALL: Chuck_Context__bindgen_ty_1 = Chuck_Context__bindgen_ty_1::P_ALL;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub enum Chuck_Context__bindgen_ty_1 {
        P_NONE = 0,
        P_CLASSES_ONLY = 1,
        P_ALL = 2,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Context() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Context>(),
            288usize,
            concat!("Size of: ", stringify!(Chuck_Context))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Context>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Context))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).filename as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(filename)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).full_path as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(full_path)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).parse_tree as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(parse_tree)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).nspc as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(nspc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Context>())).public_class_def as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(public_class_def)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).has_error as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(has_error)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).progress as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(progress)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).new_types as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(new_types)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).new_values as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(new_values)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).new_funcs as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(new_funcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).new_nspc as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(new_nspc)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Context>())).commit_map as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Context),
                "::",
                stringify!(commit_map)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}add_commit_candidate"]
        pub fn Chuck_Context_add_commit_candidate(
            this: *mut Chuck_Context,
            nspc: *mut Chuck_Namespace,
        );
    }
    extern "C" {
        #[link_name = "\u{1}commit"]
        pub fn Chuck_Context_commit(this: *mut Chuck_Context);
    }
    extern "C" {
        #[link_name = "\u{1}rollback"]
        pub fn Chuck_Context_rollback(this: *mut Chuck_Context);
    }
    extern "C" {
        #[link_name = "\u{1}code"]
        pub fn Chuck_Context_code(this: *mut Chuck_Context) -> *mut Chuck_VM_Code;
    }
    extern "C" {
        #[link_name = "\u{1}new_Chuck_Type"]
        pub fn Chuck_Context_new_Chuck_Type(
            this: *mut Chuck_Context,
            env: *mut Chuck_Env,
        ) -> *mut Chuck_Type;
    }
    extern "C" {
        #[link_name = "\u{1}new_Chuck_Value"]
        pub fn Chuck_Context_new_Chuck_Value(
            this: *mut Chuck_Context,
            t: *mut Chuck_Type,
            name: *const string,
        ) -> *mut Chuck_Value;
    }
    extern "C" {
        #[link_name = "\u{1}new_Chuck_Func"]
        pub fn Chuck_Context_new_Chuck_Func(this: *mut Chuck_Context) -> *mut Chuck_Func;
    }
    extern "C" {
        #[link_name = "\u{1}new_Chuck_Namespace"]
        pub fn Chuck_Context_new_Chuck_Namespace(this: *mut Chuck_Context) -> *mut Chuck_Namespace;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Context"]
        pub fn Chuck_Context_Chuck_Context(this: *mut Chuck_Context);
    }
    impl Default for Chuck_Context {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Context {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Context {{ filename: {:?}, full_path: {:?}, parse_tree: {:?}, nspc: {:?}, public_class_def: {:?}, has_error: {:?}, progress: {:?}, new_types: {:?}, new_values: {:?}, new_funcs: {:?}, new_nspc: {:?}, commit_map: {:?} }}" , self . filename , self . full_path , self . parse_tree , self . nspc , self . public_class_def , self . has_error , self . progress , self . new_types , self . new_values , self . new_funcs , self . new_nspc , self . commit_map )
        }
    }
    impl Chuck_Context {
        #[inline]
        pub unsafe fn add_commit_candidate(&mut self, nspc: *mut Chuck_Namespace) {
            Chuck_Context_add_commit_candidate(self, nspc)
        }
        #[inline]
        pub unsafe fn commit(&mut self) {
            Chuck_Context_commit(self)
        }
        #[inline]
        pub unsafe fn rollback(&mut self) {
            Chuck_Context_rollback(self)
        }
        #[inline]
        pub unsafe fn code(&mut self) -> *mut Chuck_VM_Code {
            Chuck_Context_code(self)
        }
        #[inline]
        pub unsafe fn new_Chuck_Type(&mut self, env: *mut Chuck_Env) -> *mut Chuck_Type {
            Chuck_Context_new_Chuck_Type(self, env)
        }
        #[inline]
        pub unsafe fn new_Chuck_Value(
            &mut self,
            t: *mut Chuck_Type,
            name: *const string,
        ) -> *mut Chuck_Value {
            Chuck_Context_new_Chuck_Value(self, t, name)
        }
        #[inline]
        pub unsafe fn new_Chuck_Func(&mut self) -> *mut Chuck_Func {
            Chuck_Context_new_Chuck_Func(self)
        }
        #[inline]
        pub unsafe fn new_Chuck_Namespace(&mut self) -> *mut Chuck_Namespace {
            Chuck_Context_new_Chuck_Namespace(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Context_Chuck_Context(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Context_destructor"]
        pub fn Chuck_Context_Chuck_Context_destructor(this: *mut Chuck_Context);
    }
    #[repr(C)]
    pub struct Chuck_Env {
        pub _base: Chuck_VM_Object,
        pub m_carrier: *mut Chuck_Carrier,
        pub global_nspc: *mut Chuck_Namespace,
        pub global_context: Chuck_Context,
        pub user_nspc: *mut Chuck_Namespace,
        pub nspc_stack: vector,
        pub curr: *mut Chuck_Namespace,
        pub class_stack: vector,
        pub class_def: *mut Chuck_Type,
        pub func: *mut Chuck_Func,
        pub class_scope: ::std::os::raw::c_ulong,
        pub contexts: vector,
        pub context: *mut Chuck_Context,
        pub breaks: vector,
        pub key_words: map,
        pub key_types: map,
        pub key_values: map,
        pub deprecated: map,
        pub deprecate_level: ::std::os::raw::c_long,
        pub t_void: *mut Chuck_Type,
        pub t_int: *mut Chuck_Type,
        pub t_float: *mut Chuck_Type,
        pub t_time: *mut Chuck_Type,
        pub t_dur: *mut Chuck_Type,
        pub t_complex: *mut Chuck_Type,
        pub t_polar: *mut Chuck_Type,
        pub t_vec3: *mut Chuck_Type,
        pub t_vec4: *mut Chuck_Type,
        pub t_null: *mut Chuck_Type,
        pub t_function: *mut Chuck_Type,
        pub t_object: *mut Chuck_Type,
        pub t_array: *mut Chuck_Type,
        pub t_string: *mut Chuck_Type,
        pub t_event: *mut Chuck_Type,
        pub t_ugen: *mut Chuck_Type,
        pub t_uana: *mut Chuck_Type,
        pub t_uanablob: *mut Chuck_Type,
        pub t_shred: *mut Chuck_Type,
        pub t_io: *mut Chuck_Type,
        pub t_fileio: *mut Chuck_Type,
        pub t_chout: *mut Chuck_Type,
        pub t_cherr: *mut Chuck_Type,
        pub t_thread: *mut Chuck_Type,
        pub t_class: *mut Chuck_Type,
        pub t_dac: *mut Chuck_Type,
        pub t_adc: *mut Chuck_Type,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Env() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Env>(),
            904usize,
            concat!("Size of: ", stringify!(Chuck_Env))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Env>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Env))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).m_carrier as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(m_carrier)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).global_nspc as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(global_nspc)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).global_context as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(global_context)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).user_nspc as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(user_nspc)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).nspc_stack as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(nspc_stack)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).curr as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(curr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).class_stack as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(class_stack)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).class_def as *const _ as usize },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(class_def)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).func as *const _ as usize },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).class_scope as *const _ as usize },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(class_scope)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).contexts as *const _ as usize },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(contexts)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).context as *const _ as usize },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(context)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).breaks as *const _ as usize },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(breaks)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).key_words as *const _ as usize },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(key_words)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).key_types as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(key_types)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).key_values as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(key_values)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).deprecated as *const _ as usize },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(deprecated)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).deprecate_level as *const _ as usize },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(deprecate_level)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_void as *const _ as usize },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_void)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_int as *const _ as usize },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_int)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_float as *const _ as usize },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_float)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_time as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_dur as *const _ as usize },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_dur)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_complex as *const _ as usize },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_complex)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_polar as *const _ as usize },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_polar)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_vec3 as *const _ as usize },
            744usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_vec3)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_vec4 as *const _ as usize },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_vec4)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_null as *const _ as usize },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_null)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_function as *const _ as usize },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_function)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_object as *const _ as usize },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_object)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_array as *const _ as usize },
            784usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_array)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_string as *const _ as usize },
            792usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_string)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_event as *const _ as usize },
            800usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_event)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_ugen as *const _ as usize },
            808usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_ugen)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_uana as *const _ as usize },
            816usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_uana)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_uanablob as *const _ as usize },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_uanablob)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_shred as *const _ as usize },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_shred)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_io as *const _ as usize },
            840usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_io)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_fileio as *const _ as usize },
            848usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_fileio)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_chout as *const _ as usize },
            856usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_chout)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_cherr as *const _ as usize },
            864usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_cherr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_thread as *const _ as usize },
            872usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_thread)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_class as *const _ as usize },
            880usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_class)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_dac as *const _ as usize },
            888usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_dac)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Env>())).t_adc as *const _ as usize },
            896usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Env),
                "::",
                stringify!(t_adc)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set_carrier"]
        pub fn Chuck_Env_set_carrier(this: *mut Chuck_Env, carrier: *mut Chuck_Carrier);
    }
    extern "C" {
        #[link_name = "\u{1}vm"]
        pub fn Chuck_Env_vm(this: *mut Chuck_Env) -> *mut Chuck_VM;
    }
    extern "C" {
        #[link_name = "\u{1}global"]
        pub fn Chuck_Env_global(this: *mut Chuck_Env) -> *mut Chuck_Namespace;
    }
    extern "C" {
        #[link_name = "\u{1}user"]
        pub fn Chuck_Env_user(this: *mut Chuck_Env) -> *mut Chuck_Namespace;
    }
    extern "C" {
        #[link_name = "\u{1}reset"]
        pub fn Chuck_Env_reset(this: *mut Chuck_Env);
    }
    extern "C" {
        #[link_name = "\u{1}load_user_namespace"]
        pub fn Chuck_Env_load_user_namespace(this: *mut Chuck_Env);
    }
    extern "C" {
        #[link_name = "\u{1}clear_user_namespace"]
        pub fn Chuck_Env_clear_user_namespace(this: *mut Chuck_Env);
    }
    extern "C" {
        #[link_name = "\u{1}nspc_top"]
        pub fn Chuck_Env_nspc_top(this: *mut Chuck_Env) -> *mut Chuck_Namespace;
    }
    extern "C" {
        #[link_name = "\u{1}class_top"]
        pub fn Chuck_Env_class_top(this: *mut Chuck_Env) -> *mut Chuck_Type;
    }
    extern "C" {
        #[link_name = "\u{1}is_global"]
        pub fn Chuck_Env_is_global(this: *mut Chuck_Env) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Env"]
        pub fn Chuck_Env_Chuck_Env(this: *mut Chuck_Env);
    }
    impl Default for Chuck_Env {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Env {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Env {{ m_carrier: {:?}, global_nspc: {:?}, global_context: {:?}, user_nspc: {:?}, nspc_stack: {:?}, curr: {:?}, class_stack: {:?}, class_def: {:?}, func: {:?}, class_scope: {:?}, contexts: {:?}, context: {:?}, breaks: {:?}, key_words: {:?}, key_types: {:?}, key_values: {:?}, deprecated: {:?}, deprecate_level: {:?}, t_void: {:?}, t_int: {:?}, t_float: {:?}, t_time: {:?}, t_dur: {:?}, t_complex: {:?}, t_polar: {:?}, t_vec3: {:?}, t_vec4: {:?}, t_null: {:?}, t_function: {:?}, t_object: {:?}, t_array: {:?}, t_string: {:?}, t_event: {:?}, t_ugen: {:?}, t_uana: {:?}, t_uanablob: {:?}, t_shred: {:?}, t_io: {:?}, t_fileio: {:?}, t_chout: {:?}, t_cherr: {:?}, t_thread: {:?}, t_class: {:?}, t_dac: {:?}, t_adc: {:?} }}" , self . m_carrier , self . global_nspc , self . global_context , self . user_nspc , self . nspc_stack , self . curr , self . class_stack , self . class_def , self . func , self . class_scope , self . contexts , self . context , self . breaks , self . key_words , self . key_types , self . key_values , self . deprecated , self . deprecate_level , self . t_void , self . t_int , self . t_float , self . t_time , self . t_dur , self . t_complex , self . t_polar , self . t_vec3 , self . t_vec4 , self . t_null , self . t_function , self . t_object , self . t_array , self . t_string , self . t_event , self . t_ugen , self . t_uana , self . t_uanablob , self . t_shred , self . t_io , self . t_fileio , self . t_chout , self . t_cherr , self . t_thread , self . t_class , self . t_dac , self . t_adc )
        }
    }
    impl Chuck_Env {
        #[inline]
        pub unsafe fn set_carrier(&mut self, carrier: *mut Chuck_Carrier) {
            Chuck_Env_set_carrier(self, carrier)
        }
        #[inline]
        pub unsafe fn vm(&mut self) -> *mut Chuck_VM {
            Chuck_Env_vm(self)
        }
        #[inline]
        pub unsafe fn global(&mut self) -> *mut Chuck_Namespace {
            Chuck_Env_global(self)
        }
        #[inline]
        pub unsafe fn user(&mut self) -> *mut Chuck_Namespace {
            Chuck_Env_user(self)
        }
        #[inline]
        pub unsafe fn reset(&mut self) {
            Chuck_Env_reset(self)
        }
        #[inline]
        pub unsafe fn load_user_namespace(&mut self) {
            Chuck_Env_load_user_namespace(self)
        }
        #[inline]
        pub unsafe fn clear_user_namespace(&mut self) {
            Chuck_Env_clear_user_namespace(self)
        }
        #[inline]
        pub unsafe fn nspc_top(&mut self) -> *mut Chuck_Namespace {
            Chuck_Env_nspc_top(self)
        }
        #[inline]
        pub unsafe fn class_top(&mut self) -> *mut Chuck_Type {
            Chuck_Env_class_top(self)
        }
        #[inline]
        pub unsafe fn is_global(&mut self) -> ::std::os::raw::c_ulong {
            Chuck_Env_is_global(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Env_Chuck_Env(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Env_destructor"]
        pub fn Chuck_Env_Chuck_Env_destructor(this: *mut Chuck_Env);
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_UGen_Info {
        pub _base: Chuck_VM_Object,
        pub tick: f_tick,
        pub tickf: f_tickf,
        pub pmsg: f_pmsg,
        pub num_ins: ::std::os::raw::c_ulong,
        pub num_outs: ::std::os::raw::c_ulong,
        pub tock: f_tock,
        pub num_ins_ana: ::std::os::raw::c_ulong,
        pub num_outs_ana: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_UGen_Info() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_UGen_Info>(),
            104usize,
            concat!("Size of: ", stringify!(Chuck_UGen_Info))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_UGen_Info>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_UGen_Info))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).tick as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(tick)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).tickf as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(tickf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).pmsg as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(pmsg)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).num_ins as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(num_ins)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).num_outs as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(num_outs)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).tock as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(tock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_UGen_Info>())).num_ins_ana as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(num_ins_ana)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_UGen_Info>())).num_outs_ana as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_UGen_Info),
                "::",
                stringify!(num_outs_ana)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_UGen_Info"]
        pub fn Chuck_UGen_Info_Chuck_UGen_Info(this: *mut Chuck_UGen_Info);
    }
    impl Default for Chuck_UGen_Info {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_UGen_Info {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_UGen_Info_Chuck_UGen_Info(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    pub struct Chuck_Type {
        pub _base: Chuck_VM_Object,
        pub xid: te_Type,
        pub name: string,
        pub parent: *mut Chuck_Type,
        pub size: ::std::os::raw::c_ulong,
        pub owner: *mut Chuck_Namespace,
        pub __bindgen_anon_1: Chuck_Type__bindgen_ty_1,
        pub array_depth: ::std::os::raw::c_ulong,
        pub obj_size: ::std::os::raw::c_ulong,
        pub info: *mut Chuck_Namespace,
        pub func: *mut Chuck_Func,
        pub def: a_Class_Def,
        pub ugen_info: *mut Chuck_UGen_Info,
        pub is_copy: ::std::os::raw::c_ulong,
        pub is_complete: ::std::os::raw::c_ulong,
        pub has_constructor: ::std::os::raw::c_ulong,
        pub has_destructor: ::std::os::raw::c_ulong,
        pub allocator: f_alloc,
        pub doc: string,
        pub examples: vector,
        pub ret: string,
        pub m_env: *mut Chuck_Env,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Chuck_Type__bindgen_ty_1 {
        pub array_type: *mut Chuck_Type,
        pub actual_type: *mut Chuck_Type,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Type__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Type__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(Chuck_Type__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Type__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Type__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Type__bindgen_ty_1>())).array_type as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type__bindgen_ty_1),
                "::",
                stringify!(array_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Type__bindgen_ty_1>())).actual_type as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type__bindgen_ty_1),
                "::",
                stringify!(actual_type)
            )
        );
    }
    impl Default for Chuck_Type__bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Type__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "Chuck_Type__bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout_Chuck_Type() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Type>(),
            296usize,
            concat!("Size of: ", stringify!(Chuck_Type))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Type>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Type))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).xid as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(xid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).name as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).parent as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).size as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).owner as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).array_depth as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(array_depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).obj_size as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(obj_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).info as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(info)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).func as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(func)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).def as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(def)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).ugen_info as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(ugen_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).is_copy as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(is_copy)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).is_complete as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(is_complete)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).has_constructor as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(has_constructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).has_destructor as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(has_destructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).allocator as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(allocator)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).doc as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(doc)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).examples as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(examples)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).ret as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(ret)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Type>())).m_env as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Type),
                "::",
                stringify!(m_env)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}reset"]
        pub fn Chuck_Type_reset(this: *mut Chuck_Type);
    }
    extern "C" {
        #[link_name = "\u{1}copy"]
        pub fn Chuck_Type_copy(this: *const Chuck_Type, env: *mut Chuck_Env) -> *mut Chuck_Type;
    }
    extern "C" {
        #[link_name = "\u{1}str"]
        pub fn Chuck_Type_str(this: *mut Chuck_Type) -> *const string;
    }
    extern "C" {
        #[link_name = "\u{1}c_name"]
        pub fn Chuck_Type_c_name(this: *mut Chuck_Type) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Type"]
        pub fn Chuck_Type_Chuck_Type(
            this: *mut Chuck_Type,
            env: *mut Chuck_Env,
            _id: te_Type,
            _n: *const string,
            _p: *mut Chuck_Type,
            _s: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Type {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Type {{ xid: {:?}, name: {:?}, parent: {:?}, size: {:?}, owner: {:?}, __bindgen_anon_1: {:?}, array_depth: {:?}, obj_size: {:?}, info: {:?}, func: {:?}, def: {:?}, ugen_info: {:?}, is_copy: {:?}, is_complete: {:?}, has_constructor: {:?}, has_destructor: {:?}, allocator: {:?}, doc: {:?}, examples: {:?}, ret: {:?}, m_env: {:?} }}" , self . xid , self . name , self . parent , self . size , self . owner , self . __bindgen_anon_1 , self . array_depth , self . obj_size , self . info , self . func , self . def , self . ugen_info , self . is_copy , self . is_complete , self . has_constructor , self . has_destructor , self . allocator , self . doc , self . examples , self . ret , self . m_env )
        }
    }
    impl Chuck_Type {
        #[inline]
        pub unsafe fn reset(&mut self) {
            Chuck_Type_reset(self)
        }
        #[inline]
        pub unsafe fn copy(&self, env: *mut Chuck_Env) -> *mut Chuck_Type {
            Chuck_Type_copy(self, env)
        }
        #[inline]
        pub unsafe fn str(&mut self) -> *const string {
            Chuck_Type_str(self)
        }
        #[inline]
        pub unsafe fn c_name(&mut self) -> *const ::std::os::raw::c_char {
            Chuck_Type_c_name(self)
        }
        #[inline]
        pub unsafe fn new(
            env: *mut Chuck_Env,
            _id: te_Type,
            _n: *const string,
            _p: *mut Chuck_Type,
            _s: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Type_Chuck_Type(&mut __bindgen_tmp, env, _id, _n, _p, _s);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Type_destructor"]
        pub fn Chuck_Type_Chuck_Type_destructor(this: *mut Chuck_Type);
    }
    #[repr(C)]
    pub struct Chuck_Value {
        pub _base: Chuck_VM_Object,
        pub type_: *mut Chuck_Type,
        pub name: string,
        pub offset: ::std::os::raw::c_ulong,
        pub addr: *mut ::std::os::raw::c_void,
        pub is_const: ::std::os::raw::c_ulong,
        pub is_member: ::std::os::raw::c_ulong,
        pub is_static: ::std::os::raw::c_ulong,
        pub is_context_global: ::std::os::raw::c_ulong,
        pub is_decl_checked: ::std::os::raw::c_ulong,
        pub is_global: ::std::os::raw::c_ulong,
        pub access: ::std::os::raw::c_ulong,
        pub owner: *mut Chuck_Namespace,
        pub owner_class: *mut Chuck_Type,
        pub func_ref: *mut Chuck_Func,
        pub func_num_overloads: ::std::os::raw::c_long,
        pub doc: string,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Value() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Value>(),
            216usize,
            concat!("Size of: ", stringify!(Chuck_Value))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Value>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Value))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).type_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).name as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).offset as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).addr as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).is_const as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(is_const)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).is_member as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(is_member)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).is_static as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(is_static)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Value>())).is_context_global as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(is_context_global)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).is_decl_checked as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(is_decl_checked)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).is_global as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(is_global)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).access as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(access)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).owner as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).owner_class as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(owner_class)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).func_ref as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(func_ref)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Value>())).func_num_overloads as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(func_num_overloads)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Value>())).doc as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Value),
                "::",
                stringify!(doc)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Value"]
        pub fn Chuck_Value_Chuck_Value(
            this: *mut Chuck_Value,
            t: *mut Chuck_Type,
            n: *const string,
            a: *mut ::std::os::raw::c_void,
            c: ::std::os::raw::c_ulong,
            acc: ::std::os::raw::c_ulong,
            o: *mut Chuck_Namespace,
            oc: *mut Chuck_Type,
            s: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Value {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Value {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Value {{ type: {:?}, name: {:?}, offset: {:?}, addr: {:?}, is_const: {:?}, is_member: {:?}, is_static: {:?}, is_context_global: {:?}, is_decl_checked: {:?}, is_global: {:?}, access: {:?}, owner: {:?}, owner_class: {:?}, func_ref: {:?}, func_num_overloads: {:?}, doc: {:?} }}" , self . type_ , self . name , self . offset , self . addr , self . is_const , self . is_member , self . is_static , self . is_context_global , self . is_decl_checked , self . is_global , self . access , self . owner , self . owner_class , self . func_ref , self . func_num_overloads , self . doc )
        }
    }
    impl Chuck_Value {
        #[inline]
        pub unsafe fn new(
            t: *mut Chuck_Type,
            n: *const string,
            a: *mut ::std::os::raw::c_void,
            c: ::std::os::raw::c_ulong,
            acc: ::std::os::raw::c_ulong,
            o: *mut Chuck_Namespace,
            oc: *mut Chuck_Type,
            s: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Value_Chuck_Value(&mut __bindgen_tmp, t, n, a, c, acc, o, oc, s);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Value_destructor"]
        pub fn Chuck_Value_Chuck_Value_destructor(this: *mut Chuck_Value);
    }
    #[repr(C)]
    pub struct Chuck_Func {
        pub _base: Chuck_VM_Object,
        pub name: string,
        pub def: a_Func_Def,
        pub code: *mut Chuck_VM_Code,
        pub is_member: ::std::os::raw::c_ulong,
        pub vt_index: ::std::os::raw::c_ulong,
        pub value_ref: *mut Chuck_Value,
        pub next: *mut Chuck_Func,
        pub up: *mut Chuck_Value,
        pub doc: string,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Func() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Func>(),
            160usize,
            concat!("Size of: ", stringify!(Chuck_Func))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Func>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Func))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).name as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).def as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(def)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).code as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(code)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).is_member as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(is_member)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).vt_index as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(vt_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).value_ref as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(value_ref)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).next as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).up as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(up)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Func>())).doc as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Func),
                "::",
                stringify!(doc)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Func"]
        pub fn Chuck_Func_Chuck_Func(this: *mut Chuck_Func);
    }
    impl Default for Chuck_Func {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Func {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Func {{ name: {:?}, def: {:?}, code: {:?}, is_member: {:?}, vt_index: {:?}, value_ref: {:?}, next: {:?}, up: {:?}, doc: {:?} }}" , self . name , self . def , self . code , self . is_member , self . vt_index , self . value_ref , self . next , self . up , self . doc )
        }
    }
    impl Chuck_Func {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Func_Chuck_Func(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Func_destructor"]
        pub fn Chuck_Func_Chuck_Func_destructor(this: *mut Chuck_Func);
    }
    #[repr(C)]
    pub struct Chuck_Instr__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr {
        pub vtable_: *const Chuck_Instr__bindgen_vtable,
        pub m_linepos: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Instr>())).m_linepos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr),
                "::",
                stringify!(m_linepos)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set_linepos"]
        pub fn Chuck_Instr_set_linepos(this: *mut Chuck_Instr, linepos: ::std::os::raw::c_ulong);
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr"]
        pub fn Chuck_Instr_Chuck_Instr(this: *mut Chuck_Instr);
    }
    impl Default for Chuck_Instr {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr {
        #[inline]
        pub unsafe fn set_linepos(&mut self, linepos: ::std::os::raw::c_ulong) {
            Chuck_Instr_set_linepos(self, linepos)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Chuck_Instr(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_destructor"]
        pub fn Chuck_Instr_Chuck_Instr_destructor(this: *mut Chuck_Instr);
    }
    extern "C" {
        #[link_name = "\u{1}name"]
        pub fn Chuck_Instr_name(this: *mut ::std::os::raw::c_void)
            -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Op {
        pub _base: Chuck_Instr,
        pub m_jmp: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Op() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Op>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Op))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Op>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Op))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Instr_Branch_Op>())).m_jmp as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Branch_Op),
                "::",
                stringify!(m_jmp)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set"]
        pub fn Chuck_Instr_Branch_Op_set(
            this: *mut Chuck_Instr_Branch_Op,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Op {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Op {
        #[inline]
        pub unsafe fn set(&mut self, jmp: ::std::os::raw::c_ulong) {
            Chuck_Instr_Branch_Op_set(self, jmp)
        }
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Branch_Op_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Unary_Op {
        pub _base: Chuck_Instr,
        pub m_val: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Unary_Op() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Unary_Op>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Unary_Op))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Unary_Op>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Unary_Op))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Instr_Unary_Op>())).m_val as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Unary_Op),
                "::",
                stringify!(m_val)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set"]
        pub fn Chuck_Instr_Unary_Op_set(
            this: *mut Chuck_Instr_Unary_Op,
            val: ::std::os::raw::c_ulong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}get"]
        pub fn Chuck_Instr_Unary_Op_get(this: *mut Chuck_Instr_Unary_Op)
            -> ::std::os::raw::c_ulong;
    }
    impl Default for Chuck_Instr_Unary_Op {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Unary_Op {
        #[inline]
        pub unsafe fn set(&mut self, val: ::std::os::raw::c_ulong) {
            Chuck_Instr_Unary_Op_set(self, val)
        }
        #[inline]
        pub unsafe fn get(&mut self) -> ::std::os::raw::c_ulong {
            Chuck_Instr_Unary_Op_get(self)
        }
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Unary_Op_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, PartialOrd, PartialEq)]
    pub struct Chuck_Instr_Unary_Op2 {
        pub _base: Chuck_Instr,
        pub m_val: f64,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Unary_Op2() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Unary_Op2>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Unary_Op2))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Unary_Op2>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Unary_Op2))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Instr_Unary_Op2>())).m_val as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Unary_Op2),
                "::",
                stringify!(m_val)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set"]
        pub fn Chuck_Instr_Unary_Op2_set(this: *mut Chuck_Instr_Unary_Op2, val: f64);
    }
    extern "C" {
        #[link_name = "\u{1}get"]
        pub fn Chuck_Instr_Unary_Op2_get(this: *mut Chuck_Instr_Unary_Op2) -> f64;
    }
    impl Default for Chuck_Instr_Unary_Op2 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Unary_Op2 {
        #[inline]
        pub unsafe fn set(&mut self, val: f64) {
            Chuck_Instr_Unary_Op2_set(self, val)
        }
        #[inline]
        pub unsafe fn get(&mut self) -> f64 {
            Chuck_Instr_Unary_Op2_get(self)
        }
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Unary_Op2_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Op {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Op() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Op>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Op))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Op>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Op))
        );
    }
    impl Default for Chuck_Instr_Binary_Op {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_int))
        );
    }
    impl Default for Chuck_Instr_Add_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_PreInc_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_PreInc_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_PreInc_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_PreInc_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_PreInc_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_PreInc_int))
        );
    }
    impl Default for Chuck_Instr_PreInc_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_PreInc_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_PostInc_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_PostInc_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_PostInc_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_PostInc_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_PostInc_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_PostInc_int))
        );
    }
    impl Default for Chuck_Instr_PostInc_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_PostInc_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_PreDec_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_PreDec_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_PreDec_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_PreDec_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_PreDec_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_PreDec_int))
        );
    }
    impl Default for Chuck_Instr_PreDec_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_PreDec_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_PostDec_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_PostDec_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_PostDec_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_PostDec_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_PostDec_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_PostDec_int))
        );
    }
    impl Default for Chuck_Instr_PostDec_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_PostDec_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dec_int_Addr {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dec_int_Addr() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dec_int_Addr>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dec_int_Addr))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dec_int_Addr>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dec_int_Addr))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dec_int_Addr"]
        pub fn Chuck_Instr_Dec_int_Addr_Chuck_Instr_Dec_int_Addr(
            this: *mut Chuck_Instr_Dec_int_Addr,
            src: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dec_int_Addr {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dec_int_Addr {
        #[inline]
        pub unsafe fn new(src: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dec_int_Addr_Chuck_Instr_Dec_int_Addr(&mut __bindgen_tmp, src);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dec_int_Addr_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Complement_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Complement_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Complement_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Complement_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Complement_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Complement_int))
        );
    }
    impl Default for Chuck_Instr_Complement_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Complement_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mod_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mod_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mod_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mod_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mod_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mod_int))
        );
    }
    impl Default for Chuck_Instr_Mod_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mod_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mod_int_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mod_int_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mod_int_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mod_int_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mod_int_Reverse>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mod_int_Reverse))
        );
    }
    impl Default for Chuck_Instr_Mod_int_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mod_int_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_int))
        );
    }
    impl Default for Chuck_Instr_Minus_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_int_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_int_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_int_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_int_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_int_Reverse>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_int_Reverse))
        );
    }
    impl Default for Chuck_Instr_Minus_int_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_int_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_int))
        );
    }
    impl Default for Chuck_Instr_Times_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_int))
        );
    }
    impl Default for Chuck_Instr_Divide_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_int_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_int_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_int_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_int_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_int_Reverse>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_int_Reverse))
        );
    }
    impl Default for Chuck_Instr_Divide_int_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_int_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_double))
        );
    }
    impl Default for Chuck_Instr_Add_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_double))
        );
    }
    impl Default for Chuck_Instr_Minus_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_double_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_double_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_double_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_double_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_double_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Minus_double_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Minus_double_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_double_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_double))
        );
    }
    impl Default for Chuck_Instr_Times_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_double))
        );
    }
    impl Default for Chuck_Instr_Divide_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_double_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_double_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_double_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_double_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_double_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Divide_double_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Divide_double_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_double_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mod_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mod_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mod_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mod_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mod_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mod_double))
        );
    }
    impl Default for Chuck_Instr_Mod_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mod_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mod_double_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mod_double_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mod_double_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mod_double_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mod_double_Reverse>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mod_double_Reverse))
        );
    }
    impl Default for Chuck_Instr_Mod_double_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mod_double_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_complex {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_complex() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_complex>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_complex))
        );
    }
    impl Default for Chuck_Instr_Add_complex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_complex_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_complex {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_complex() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_complex>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_complex))
        );
    }
    impl Default for Chuck_Instr_Minus_complex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_complex_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_complex_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_complex_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_complex_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_complex_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_complex_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Minus_complex_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Minus_complex_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_complex_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_complex {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_complex() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_complex>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_complex))
        );
    }
    impl Default for Chuck_Instr_Times_complex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_complex_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_complex {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_complex() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_complex>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_complex))
        );
    }
    impl Default for Chuck_Instr_Divide_complex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_complex_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_complex_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_complex_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_complex_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_complex_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_complex_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Divide_complex_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Divide_complex_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_complex_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_polar {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_polar() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_polar>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_polar))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_polar>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_polar))
        );
    }
    impl Default for Chuck_Instr_Add_polar {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_polar_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_polar {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_polar() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_polar>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_polar))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_polar>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_polar))
        );
    }
    impl Default for Chuck_Instr_Minus_polar {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_polar_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_polar_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_polar_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_polar_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_polar_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_polar_Reverse>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_polar_Reverse))
        );
    }
    impl Default for Chuck_Instr_Minus_polar_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_polar_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_polar {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_polar() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_polar>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_polar))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_polar>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_polar))
        );
    }
    impl Default for Chuck_Instr_Times_polar {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_polar_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_polar {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_polar() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_polar>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_polar))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_polar>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_polar))
        );
    }
    impl Default for Chuck_Instr_Divide_polar {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_polar_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_polar_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_polar_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_polar_Reverse>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_polar_Reverse))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_polar_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Divide_polar_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Divide_polar_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_polar_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_vec3 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_vec3() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_vec3>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_vec3))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_vec3>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_vec3))
        );
    }
    impl Default for Chuck_Instr_Add_vec3 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_vec3_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_vec3 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_vec3() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_vec3>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_vec3))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_vec3>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_vec3))
        );
    }
    impl Default for Chuck_Instr_Minus_vec3 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_vec3_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_vec4 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_vec4() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_vec4>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_vec4))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_vec4>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_vec4))
        );
    }
    impl Default for Chuck_Instr_Add_vec4 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_vec4_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_vec4 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_vec4() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_vec4>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_vec4))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_vec4>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_vec4))
        );
    }
    impl Default for Chuck_Instr_Minus_vec4 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_vec4_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_XProduct_vec4 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_XProduct_vec4() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_XProduct_vec4>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_XProduct_vec4))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_XProduct_vec4>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_XProduct_vec4))
        );
    }
    impl Default for Chuck_Instr_XProduct_vec4 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_XProduct_vec4_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_float_Times_vec3 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_float_Times_vec3() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_float_Times_vec3>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_float_Times_vec3))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_float_Times_vec3>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_float_Times_vec3))
        );
    }
    impl Default for Chuck_Instr_float_Times_vec3 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_float_Times_vec3_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_vec3_Times_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_vec3_Times_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_vec3_Times_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_vec3_Times_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_vec3_Times_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_vec3_Times_float))
        );
    }
    impl Default for Chuck_Instr_vec3_Times_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_vec3_Times_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_vec3_Divide_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_vec3_Divide_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_vec3_Divide_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_vec3_Divide_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_vec3_Divide_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_vec3_Divide_float))
        );
    }
    impl Default for Chuck_Instr_vec3_Divide_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_vec3_Divide_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_float_Times_vec4 {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_float_Times_vec4() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_float_Times_vec4>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_float_Times_vec4))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_float_Times_vec4>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_float_Times_vec4))
        );
    }
    impl Default for Chuck_Instr_float_Times_vec4 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_float_Times_vec4_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_vec4_Times_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_vec4_Times_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_vec4_Times_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_vec4_Times_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_vec4_Times_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_vec4_Times_float))
        );
    }
    impl Default for Chuck_Instr_vec4_Times_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_vec4_Times_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_vec4_Divide_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_vec4_Divide_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_vec4_Divide_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_vec4_Divide_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_vec4_Divide_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_vec4_Divide_float))
        );
    }
    impl Default for Chuck_Instr_vec4_Divide_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_vec4_Divide_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_int_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_int_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_int_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_int_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_int_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_int_Assign))
        );
    }
    impl Default for Chuck_Instr_Add_int_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_int_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mod_int_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mod_int_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mod_int_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mod_int_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mod_int_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mod_int_Assign))
        );
    }
    impl Default for Chuck_Instr_Mod_int_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mod_int_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_int_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_int_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_int_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_int_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_int_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_int_Assign))
        );
    }
    impl Default for Chuck_Instr_Minus_int_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_int_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_int_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_int_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_int_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_int_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_int_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_int_Assign))
        );
    }
    impl Default for Chuck_Instr_Times_int_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_int_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_int_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_int_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_int_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_int_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_int_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_int_Assign))
        );
    }
    impl Default for Chuck_Instr_Divide_int_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_int_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_double_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_double_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_double_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_double_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_double_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_double_Assign))
        );
    }
    impl Default for Chuck_Instr_Add_double_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_double_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_double_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_double_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_double_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_double_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_double_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_double_Assign))
        );
    }
    impl Default for Chuck_Instr_Minus_double_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_double_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_double_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_double_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_double_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_double_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_double_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_double_Assign))
        );
    }
    impl Default for Chuck_Instr_Times_double_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_double_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_double_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_double_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_double_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_double_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_double_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Divide_double_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Divide_double_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_double_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mod_double_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mod_double_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mod_double_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mod_double_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mod_double_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mod_double_Assign))
        );
    }
    impl Default for Chuck_Instr_Mod_double_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mod_double_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_complex_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_complex_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_complex_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_complex_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_complex_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_complex_Assign))
        );
    }
    impl Default for Chuck_Instr_Add_complex_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_complex_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_complex_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_complex_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_complex_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_complex_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_complex_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Minus_complex_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Minus_complex_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_complex_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_complex_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_complex_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_complex_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_complex_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_complex_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Times_complex_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Times_complex_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_complex_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_complex_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_complex_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_complex_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_complex_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_complex_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Divide_complex_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Divide_complex_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_complex_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_polar_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_polar_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_polar_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_polar_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_polar_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_polar_Assign))
        );
    }
    impl Default for Chuck_Instr_Add_polar_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_polar_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Minus_polar_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Minus_polar_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Minus_polar_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Minus_polar_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Minus_polar_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Minus_polar_Assign))
        );
    }
    impl Default for Chuck_Instr_Minus_polar_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Minus_polar_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Times_polar_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Times_polar_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Times_polar_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Times_polar_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Times_polar_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Times_polar_Assign))
        );
    }
    impl Default for Chuck_Instr_Times_polar_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Times_polar_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Divide_polar_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Divide_polar_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Divide_polar_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Divide_polar_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Divide_polar_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Divide_polar_Assign))
        );
    }
    impl Default for Chuck_Instr_Divide_polar_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Divide_polar_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_string {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_string() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_string>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_string))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_string>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_string))
        );
    }
    impl Default for Chuck_Instr_Add_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_string_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_string_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_string_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_string_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_string_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_string_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_string_Assign))
        );
    }
    impl Default for Chuck_Instr_Add_string_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_string_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_string_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_string_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_string_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_string_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_string_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_string_int))
        );
    }
    impl Default for Chuck_Instr_Add_string_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_string_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_string_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_string_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_string_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_string_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_string_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_string_float))
        );
    }
    impl Default for Chuck_Instr_Add_string_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_string_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_int_string {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_int_string() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_int_string>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_int_string))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_int_string>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_int_string))
        );
    }
    impl Default for Chuck_Instr_Add_int_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_int_string_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_float_string {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_float_string() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_float_string>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_float_string))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_float_string>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Add_float_string))
        );
    }
    impl Default for Chuck_Instr_Add_float_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_float_string_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_int_string_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_int_string_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_int_string_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_int_string_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_int_string_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Add_int_string_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Add_int_string_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_int_string_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Add_float_string_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Add_float_string_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Add_float_string_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Add_float_string_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Add_float_string_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Add_float_string_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Add_float_string_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Add_float_string_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Lt_int {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Lt_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Lt_int>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Lt_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Lt_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Lt_int))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Lt_int"]
        pub fn Chuck_Instr_Branch_Lt_int_Chuck_Instr_Branch_Lt_int(
            this: *mut Chuck_Instr_Branch_Lt_int,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Lt_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Lt_int {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Lt_int_Chuck_Instr_Branch_Lt_int(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Lt_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Gt_int {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Gt_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Gt_int>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Gt_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Gt_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Gt_int))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Gt_int"]
        pub fn Chuck_Instr_Branch_Gt_int_Chuck_Instr_Branch_Gt_int(
            this: *mut Chuck_Instr_Branch_Gt_int,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Gt_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Gt_int {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Gt_int_Chuck_Instr_Branch_Gt_int(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Gt_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Le_int {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Le_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Le_int>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Le_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Le_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Le_int))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Le_int"]
        pub fn Chuck_Instr_Branch_Le_int_Chuck_Instr_Branch_Le_int(
            this: *mut Chuck_Instr_Branch_Le_int,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Le_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Le_int {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Le_int_Chuck_Instr_Branch_Le_int(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Le_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Ge_int {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Ge_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Ge_int>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Ge_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Ge_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Ge_int))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Ge_int"]
        pub fn Chuck_Instr_Branch_Ge_int_Chuck_Instr_Branch_Ge_int(
            this: *mut Chuck_Instr_Branch_Ge_int,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Ge_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Ge_int {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Ge_int_Chuck_Instr_Branch_Ge_int(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Ge_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Eq_int {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Eq_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Eq_int>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Eq_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Eq_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Eq_int))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Eq_int"]
        pub fn Chuck_Instr_Branch_Eq_int_Chuck_Instr_Branch_Eq_int(
            this: *mut Chuck_Instr_Branch_Eq_int,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Eq_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Eq_int {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Eq_int_Chuck_Instr_Branch_Eq_int(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Eq_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Neq_int {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Neq_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Neq_int>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Neq_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Neq_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Neq_int))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Neq_int"]
        pub fn Chuck_Instr_Branch_Neq_int_Chuck_Instr_Branch_Neq_int(
            this: *mut Chuck_Instr_Branch_Neq_int,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Neq_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Neq_int {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Neq_int_Chuck_Instr_Branch_Neq_int(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Neq_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Lt_double {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Lt_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Lt_double>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Lt_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Lt_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Lt_double))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Lt_double"]
        pub fn Chuck_Instr_Branch_Lt_double_Chuck_Instr_Branch_Lt_double(
            this: *mut Chuck_Instr_Branch_Lt_double,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Lt_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Lt_double {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Lt_double_Chuck_Instr_Branch_Lt_double(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Lt_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Gt_double {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Gt_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Gt_double>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Gt_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Gt_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Gt_double))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Gt_double"]
        pub fn Chuck_Instr_Branch_Gt_double_Chuck_Instr_Branch_Gt_double(
            this: *mut Chuck_Instr_Branch_Gt_double,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Gt_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Gt_double {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Gt_double_Chuck_Instr_Branch_Gt_double(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Gt_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Le_double {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Le_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Le_double>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Le_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Le_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Le_double))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Le_double"]
        pub fn Chuck_Instr_Branch_Le_double_Chuck_Instr_Branch_Le_double(
            this: *mut Chuck_Instr_Branch_Le_double,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Le_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Le_double {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Le_double_Chuck_Instr_Branch_Le_double(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Le_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Ge_double {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Ge_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Ge_double>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Ge_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Ge_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Ge_double))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Ge_double"]
        pub fn Chuck_Instr_Branch_Ge_double_Chuck_Instr_Branch_Ge_double(
            this: *mut Chuck_Instr_Branch_Ge_double,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Ge_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Ge_double {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Ge_double_Chuck_Instr_Branch_Ge_double(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Ge_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Eq_double {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Eq_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Eq_double>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Eq_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Eq_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Eq_double))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Eq_double"]
        pub fn Chuck_Instr_Branch_Eq_double_Chuck_Instr_Branch_Eq_double(
            this: *mut Chuck_Instr_Branch_Eq_double,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Eq_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Eq_double {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Eq_double_Chuck_Instr_Branch_Eq_double(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Eq_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Neq_double {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Neq_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Neq_double>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Neq_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Neq_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Branch_Neq_double))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Neq_double"]
        pub fn Chuck_Instr_Branch_Neq_double_Chuck_Instr_Branch_Neq_double(
            this: *mut Chuck_Instr_Branch_Neq_double,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Neq_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Neq_double {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Neq_double_Chuck_Instr_Branch_Neq_double(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Neq_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Eq_int_IO_good {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Eq_int_IO_good() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Eq_int_IO_good>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Eq_int_IO_good))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Eq_int_IO_good>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Branch_Eq_int_IO_good)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Eq_int_IO_good"]
        pub fn Chuck_Instr_Branch_Eq_int_IO_good_Chuck_Instr_Branch_Eq_int_IO_good(
            this: *mut Chuck_Instr_Branch_Eq_int_IO_good,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Eq_int_IO_good {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Eq_int_IO_good {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Eq_int_IO_good_Chuck_Instr_Branch_Eq_int_IO_good(
                &mut __bindgen_tmp,
                jmp,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Eq_int_IO_good_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Branch_Neq_int_IO_good {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Branch_Neq_int_IO_good() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Branch_Neq_int_IO_good>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Branch_Neq_int_IO_good))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Branch_Neq_int_IO_good>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Branch_Neq_int_IO_good)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Branch_Neq_int_IO_good"]
        pub fn Chuck_Instr_Branch_Neq_int_IO_good_Chuck_Instr_Branch_Neq_int_IO_good(
            this: *mut Chuck_Instr_Branch_Neq_int_IO_good,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Branch_Neq_int_IO_good {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Branch_Neq_int_IO_good {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Branch_Neq_int_IO_good_Chuck_Instr_Branch_Neq_int_IO_good(
                &mut __bindgen_tmp,
                jmp,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Branch_Neq_int_IO_good_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Lt_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Lt_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Lt_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Lt_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Lt_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Lt_int))
        );
    }
    impl Default for Chuck_Instr_Lt_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Lt_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Gt_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Gt_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Gt_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Gt_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Gt_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Gt_int))
        );
    }
    impl Default for Chuck_Instr_Gt_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Gt_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Le_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Le_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Le_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Le_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Le_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Le_int))
        );
    }
    impl Default for Chuck_Instr_Le_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Le_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Ge_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Ge_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Ge_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Ge_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Ge_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Ge_int))
        );
    }
    impl Default for Chuck_Instr_Ge_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Ge_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Eq_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Eq_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Eq_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Eq_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Eq_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Eq_int))
        );
    }
    impl Default for Chuck_Instr_Eq_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Eq_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Neq_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Neq_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Neq_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Neq_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Neq_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Neq_int))
        );
    }
    impl Default for Chuck_Instr_Neq_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Neq_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Not_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Not_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Not_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Not_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Not_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Not_int))
        );
    }
    impl Default for Chuck_Instr_Not_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Not_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Negate_int {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Negate_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Negate_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Negate_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Negate_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Negate_int))
        );
    }
    impl Default for Chuck_Instr_Negate_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Negate_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Negate_double {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Negate_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Negate_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Negate_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Negate_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Negate_double))
        );
    }
    impl Default for Chuck_Instr_Negate_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Negate_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Lt_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Lt_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Lt_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Lt_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Lt_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Lt_double))
        );
    }
    impl Default for Chuck_Instr_Lt_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Lt_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Gt_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Gt_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Gt_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Gt_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Gt_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Gt_double))
        );
    }
    impl Default for Chuck_Instr_Gt_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Gt_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Le_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Le_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Le_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Le_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Le_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Le_double))
        );
    }
    impl Default for Chuck_Instr_Le_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Le_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Ge_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Ge_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Ge_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Ge_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Ge_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Ge_double))
        );
    }
    impl Default for Chuck_Instr_Ge_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Ge_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Eq_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Eq_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Eq_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Eq_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Eq_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Eq_double))
        );
    }
    impl Default for Chuck_Instr_Eq_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Eq_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Neq_double {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Neq_double() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Neq_double>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Neq_double))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Neq_double>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Neq_double))
        );
    }
    impl Default for Chuck_Instr_Neq_double {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Neq_double_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Eq_complex {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Eq_complex() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Eq_complex>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Eq_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Eq_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Eq_complex))
        );
    }
    impl Default for Chuck_Instr_Eq_complex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Eq_complex_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Neq_complex {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Neq_complex() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Neq_complex>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Neq_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Neq_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Neq_complex))
        );
    }
    impl Default for Chuck_Instr_Neq_complex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Neq_complex_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_And {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_And() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_And>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_And))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_And>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_And))
        );
    }
    impl Default for Chuck_Instr_Binary_And {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_And_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Or {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Or() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Or>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Or))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Or>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Or))
        );
    }
    impl Default for Chuck_Instr_Binary_Or {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Or_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Xor {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Xor() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Xor>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Xor))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Xor>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Xor))
        );
    }
    impl Default for Chuck_Instr_Binary_Xor {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Xor_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Shift_Right {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Shift_Right() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Shift_Right>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Shift_Right))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Shift_Right>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Shift_Right))
        );
    }
    impl Default for Chuck_Instr_Binary_Shift_Right {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Shift_Right_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Shift_Right_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Shift_Right_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Shift_Right_Reverse>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(Chuck_Instr_Binary_Shift_Right_Reverse)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Shift_Right_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Binary_Shift_Right_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Binary_Shift_Right_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Shift_Right_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Shift_Left {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Shift_Left() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Shift_Left>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Shift_Left))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Shift_Left>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Shift_Left))
        );
    }
    impl Default for Chuck_Instr_Binary_Shift_Left {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Shift_Left_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Shift_Left_Reverse {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Shift_Left_Reverse() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Shift_Left_Reverse>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(Chuck_Instr_Binary_Shift_Left_Reverse)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Shift_Left_Reverse>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Binary_Shift_Left_Reverse)
            )
        );
    }
    impl Default for Chuck_Instr_Binary_Shift_Left_Reverse {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Shift_Left_Reverse_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_And_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_And_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_And_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_And_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_And_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_And_Assign))
        );
    }
    impl Default for Chuck_Instr_Binary_And_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_And_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Or_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Or_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Or_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Or_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Or_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Or_Assign))
        );
    }
    impl Default for Chuck_Instr_Binary_Or_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Or_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Xor_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Xor_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Xor_Assign>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Binary_Xor_Assign))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Xor_Assign>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Binary_Xor_Assign))
        );
    }
    impl Default for Chuck_Instr_Binary_Xor_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Xor_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Shift_Right_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Shift_Right_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Shift_Right_Assign>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(Chuck_Instr_Binary_Shift_Right_Assign)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Shift_Right_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Binary_Shift_Right_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Binary_Shift_Right_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Shift_Right_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Binary_Shift_Left_Assign {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Binary_Shift_Left_Assign() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Binary_Shift_Left_Assign>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(Chuck_Instr_Binary_Shift_Left_Assign)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Binary_Shift_Left_Assign>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Binary_Shift_Left_Assign)
            )
        );
    }
    impl Default for Chuck_Instr_Binary_Shift_Left_Assign {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Binary_Shift_Left_Assign_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_And {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_And() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_And>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_And))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_And>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_And))
        );
    }
    impl Default for Chuck_Instr_And {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_And_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Or {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Or() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Or>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Or))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Or>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Or))
        );
    }
    impl Default for Chuck_Instr_Or {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Or_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Goto {
        pub _base: Chuck_Instr_Branch_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Goto() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Goto>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Goto))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Goto>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Goto))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Goto"]
        pub fn Chuck_Instr_Goto_Chuck_Instr_Goto(
            this: *mut Chuck_Instr_Goto,
            jmp: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Goto {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Goto {
        #[inline]
        pub unsafe fn new(jmp: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Goto_Chuck_Instr_Goto(&mut __bindgen_tmp, jmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Goto_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Pop_Word {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Pop_Word() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Pop_Word>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Pop_Word))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Pop_Word>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Pop_Word))
        );
    }
    impl Default for Chuck_Instr_Reg_Pop_Word {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Pop_Word_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Pop_Mem {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Pop_Mem() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Pop_Mem>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Pop_Mem))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Pop_Mem>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Pop_Mem))
        );
    }
    impl Default for Chuck_Instr_Reg_Pop_Mem {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Pop_Mem_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Imm {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Imm() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Imm>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Imm))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Imm>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Imm))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Push_Imm"]
        pub fn Chuck_Instr_Reg_Push_Imm_Chuck_Instr_Reg_Push_Imm(
            this: *mut Chuck_Instr_Reg_Push_Imm,
            val: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Imm {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Reg_Push_Imm {
        #[inline]
        pub unsafe fn new(val: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Push_Imm_Chuck_Instr_Reg_Push_Imm(&mut __bindgen_tmp, val);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Imm_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Dup_Last {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Dup_Last() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Dup_Last>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Dup_Last))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Dup_Last>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Dup_Last))
        );
    }
    impl Default for Chuck_Instr_Reg_Dup_Last {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Dup_Last_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Dup_Last_As_Pointer {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Dup_Last_As_Pointer() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Dup_Last_As_Pointer>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Dup_Last_As_Pointer))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Dup_Last_As_Pointer>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Reg_Dup_Last_As_Pointer)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Dup_Last_As_Pointer"]
        pub fn Chuck_Instr_Reg_Dup_Last_As_Pointer_Chuck_Instr_Reg_Dup_Last_As_Pointer(
            this: *mut Chuck_Instr_Reg_Dup_Last_As_Pointer,
            sizeInWords: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Reg_Dup_Last_As_Pointer {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Reg_Dup_Last_As_Pointer {
        #[inline]
        pub unsafe fn new(sizeInWords: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Dup_Last_As_Pointer_Chuck_Instr_Reg_Dup_Last_As_Pointer(
                &mut __bindgen_tmp,
                sizeInWords,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Dup_Last_As_Pointer_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Now {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Now() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Now>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Now))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Now>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Now))
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Now {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Now_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Me {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Me() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Me>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Me))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Me>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Me))
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Me {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Me_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_This {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_This() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_This>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_This))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_This>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_This))
        );
    }
    impl Default for Chuck_Instr_Reg_Push_This {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_This_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Start {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Start() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Start>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Start))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Start>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Start))
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Start {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Start_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Maybe {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Maybe() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Maybe>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Maybe))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Maybe>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Maybe))
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Maybe {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Maybe_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Mem {
        pub _base: Chuck_Instr_Unary_Op,
        pub base: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Mem() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Mem>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Mem))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Mem>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Mem))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Reg_Push_Mem>())).base as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Reg_Push_Mem),
                "::",
                stringify!(base)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Push_Mem"]
        pub fn Chuck_Instr_Reg_Push_Mem_Chuck_Instr_Reg_Push_Mem(
            this: *mut Chuck_Instr_Reg_Push_Mem,
            src: ::std::os::raw::c_ulong,
            use_base: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Mem {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Reg_Push_Mem {
        #[inline]
        pub unsafe fn new(src: ::std::os::raw::c_ulong, use_base: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Push_Mem_Chuck_Instr_Reg_Push_Mem(&mut __bindgen_tmp, src, use_base);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Mem_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Reg_Push_Mem_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    pub struct Chuck_Instr_Reg_Push_Global {
        pub _base: Chuck_Instr_Unary_Op,
        pub m_name: string,
        pub m_type: te_GlobalType,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Global() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Global>(),
            64usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Global))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Global>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Global))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Reg_Push_Global>())).m_name as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Reg_Push_Global),
                "::",
                stringify!(m_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Reg_Push_Global>())).m_type as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Reg_Push_Global),
                "::",
                stringify!(m_type)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Push_Global"]
        pub fn Chuck_Instr_Reg_Push_Global_Chuck_Instr_Reg_Push_Global(
            this: *mut Chuck_Instr_Reg_Push_Global,
            name: string,
            type_: te_GlobalType,
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Global {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Instr_Reg_Push_Global {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Instr_Reg_Push_Global {{ m_name: {:?}, m_type: {:?} }}",
                self.m_name, self.m_type
            )
        }
    }
    impl Chuck_Instr_Reg_Push_Global {
        #[inline]
        pub unsafe fn new(name: string, type_: te_GlobalType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Push_Global_Chuck_Instr_Reg_Push_Global(
                &mut __bindgen_tmp,
                name,
                type_,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Global_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Reg_Push_Global_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Mem_Addr {
        pub _base: Chuck_Instr_Unary_Op,
        pub base: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Mem_Addr() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Mem_Addr>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Mem_Addr))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Mem_Addr>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Mem_Addr))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Reg_Push_Mem_Addr>())).base as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Reg_Push_Mem_Addr),
                "::",
                stringify!(base)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Push_Mem_Addr"]
        pub fn Chuck_Instr_Reg_Push_Mem_Addr_Chuck_Instr_Reg_Push_Mem_Addr(
            this: *mut Chuck_Instr_Reg_Push_Mem_Addr,
            src: ::std::os::raw::c_ulong,
            use_base: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Mem_Addr {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Reg_Push_Mem_Addr {
        #[inline]
        pub unsafe fn new(src: ::std::os::raw::c_ulong, use_base: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Push_Mem_Addr_Chuck_Instr_Reg_Push_Mem_Addr(
                &mut __bindgen_tmp,
                src,
                use_base,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Mem_Addr_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Reg_Push_Mem_Addr_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    pub struct Chuck_Instr_Reg_Push_Global_Addr {
        pub _base: Chuck_Instr_Unary_Op,
        pub m_name: string,
        pub m_type: te_GlobalType,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Global_Addr() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Global_Addr>(),
            64usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Global_Addr))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Global_Addr>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Reg_Push_Global_Addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Reg_Push_Global_Addr>())).m_name as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Reg_Push_Global_Addr),
                "::",
                stringify!(m_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Reg_Push_Global_Addr>())).m_type as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Reg_Push_Global_Addr),
                "::",
                stringify!(m_type)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Push_Global_Addr"]
        pub fn Chuck_Instr_Reg_Push_Global_Addr_Chuck_Instr_Reg_Push_Global_Addr(
            this: *mut Chuck_Instr_Reg_Push_Global_Addr,
            name: string,
            type_: te_GlobalType,
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Global_Addr {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Instr_Reg_Push_Global_Addr {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Instr_Reg_Push_Global_Addr {{ m_name: {:?}, m_type: {:?} }}",
                self.m_name, self.m_type
            )
        }
    }
    impl Chuck_Instr_Reg_Push_Global_Addr {
        #[inline]
        pub unsafe fn new(name: string, type_: te_GlobalType) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Push_Global_Addr_Chuck_Instr_Reg_Push_Global_Addr(
                &mut __bindgen_tmp,
                name,
                type_,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Global_Addr_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Reg_Push_Global_Addr_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Deref {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Deref() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Deref>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Reg_Push_Deref))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Deref>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Reg_Push_Deref))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Reg_Push_Deref"]
        pub fn Chuck_Instr_Reg_Push_Deref_Chuck_Instr_Reg_Push_Deref(
            this: *mut Chuck_Instr_Reg_Push_Deref,
            src: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Deref {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Reg_Push_Deref {
        #[inline]
        pub unsafe fn new(src: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Reg_Push_Deref_Chuck_Instr_Reg_Push_Deref(&mut __bindgen_tmp, src);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Deref_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mem_Set_Imm {
        pub _base: Chuck_Instr,
        pub m_offset: ::std::os::raw::c_ulong,
        pub m_val: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mem_Set_Imm() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mem_Set_Imm>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mem_Set_Imm))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mem_Set_Imm>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mem_Set_Imm))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Mem_Set_Imm>())).m_offset as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Mem_Set_Imm),
                "::",
                stringify!(m_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Mem_Set_Imm>())).m_val as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Mem_Set_Imm),
                "::",
                stringify!(m_val)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Mem_Set_Imm"]
        pub fn Chuck_Instr_Mem_Set_Imm_Chuck_Instr_Mem_Set_Imm(
            this: *mut Chuck_Instr_Mem_Set_Imm,
            offset: ::std::os::raw::c_ulong,
            val: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Mem_Set_Imm {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Mem_Set_Imm {
        #[inline]
        pub unsafe fn new(offset: ::std::os::raw::c_ulong, val: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Mem_Set_Imm_Chuck_Instr_Mem_Set_Imm(&mut __bindgen_tmp, offset, val);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mem_Set_Imm_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Mem_Set_Imm_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mem_Push_Imm {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mem_Push_Imm() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mem_Push_Imm>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mem_Push_Imm))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mem_Push_Imm>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mem_Push_Imm))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Mem_Push_Imm"]
        pub fn Chuck_Instr_Mem_Push_Imm_Chuck_Instr_Mem_Push_Imm(
            this: *mut Chuck_Instr_Mem_Push_Imm,
            src: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Mem_Push_Imm {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Mem_Push_Imm {
        #[inline]
        pub unsafe fn new(src: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Mem_Push_Imm_Chuck_Instr_Mem_Push_Imm(&mut __bindgen_tmp, src);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mem_Push_Imm_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Mem_Pop_Word {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Mem_Pop_Word() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Mem_Pop_Word>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Mem_Pop_Word))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Mem_Pop_Word>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Mem_Pop_Word))
        );
    }
    impl Default for Chuck_Instr_Mem_Pop_Word {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Mem_Pop_Word_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Nop {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Nop() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Nop>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Nop))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Nop>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Nop))
        );
    }
    impl Default for Chuck_Instr_Nop {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Nop_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_EOC {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_EOC() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_EOC>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_EOC))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_EOC>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_EOC))
        );
    }
    impl Default for Chuck_Instr_EOC {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_EOC_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Alloc_Word {
        pub _base: Chuck_Instr_Unary_Op,
        pub m_is_object: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Alloc_Word() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Alloc_Word>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Alloc_Word))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Alloc_Word>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Alloc_Word))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Alloc_Word>())).m_is_object as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Alloc_Word),
                "::",
                stringify!(m_is_object)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Alloc_Word"]
        pub fn Chuck_Instr_Alloc_Word_Chuck_Instr_Alloc_Word(
            this: *mut Chuck_Instr_Alloc_Word,
            offset: ::std::os::raw::c_ulong,
            is_object: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Alloc_Word {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Alloc_Word {
        #[inline]
        pub unsafe fn new(
            offset: ::std::os::raw::c_ulong,
            is_object: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Alloc_Word_Chuck_Instr_Alloc_Word(&mut __bindgen_tmp, offset, is_object);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Alloc_Word_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Alloc_Member_Word {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Alloc_Member_Word() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Alloc_Member_Word>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Alloc_Member_Word))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Alloc_Member_Word>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Alloc_Member_Word))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Alloc_Member_Word"]
        pub fn Chuck_Instr_Alloc_Member_Word_Chuck_Instr_Alloc_Member_Word(
            this: *mut Chuck_Instr_Alloc_Member_Word,
            offset: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Alloc_Member_Word {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Alloc_Member_Word {
        #[inline]
        pub unsafe fn new(offset: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Alloc_Member_Word_Chuck_Instr_Alloc_Member_Word(&mut __bindgen_tmp, offset);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Alloc_Member_Word_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    pub struct Chuck_Instr_Alloc_Word_Global {
        pub _base: Chuck_Instr_Unary_Op,
        pub m_name: string,
        pub m_type: te_GlobalType,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Alloc_Word_Global() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Alloc_Word_Global>(),
            64usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Alloc_Word_Global))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Alloc_Word_Global>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Alloc_Word_Global))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Alloc_Word_Global>())).m_name as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Alloc_Word_Global),
                "::",
                stringify!(m_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Alloc_Word_Global>())).m_type as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Alloc_Word_Global),
                "::",
                stringify!(m_type)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Alloc_Word_Global"]
        pub fn Chuck_Instr_Alloc_Word_Global_Chuck_Instr_Alloc_Word_Global(
            this: *mut Chuck_Instr_Alloc_Word_Global,
        );
    }
    impl Default for Chuck_Instr_Alloc_Word_Global {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Instr_Alloc_Word_Global {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Instr_Alloc_Word_Global {{ m_name: {:?}, m_type: {:?} }}",
                self.m_name, self.m_type
            )
        }
    }
    impl Chuck_Instr_Alloc_Word_Global {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Alloc_Word_Global_Chuck_Instr_Alloc_Word_Global(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Alloc_Word_Global_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Alloc_Word_Global_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Instantiate_Object {
        pub _base: Chuck_Instr,
        pub type_: *mut Chuck_Type,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Instantiate_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Instantiate_Object>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Instantiate_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Instantiate_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Instantiate_Object))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Instantiate_Object>())).type_ as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Instantiate_Object),
                "::",
                stringify!(type_)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Instantiate_Object"]
        pub fn Chuck_Instr_Instantiate_Object_Chuck_Instr_Instantiate_Object(
            this: *mut Chuck_Instr_Instantiate_Object,
            t: *mut Chuck_Type,
        );
    }
    impl Default for Chuck_Instr_Instantiate_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Instantiate_Object {
        #[inline]
        pub unsafe fn new(t: *mut Chuck_Type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Instantiate_Object_Chuck_Instr_Instantiate_Object(&mut __bindgen_tmp, t);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Instantiate_Object_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Instantiate_Object_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Pre_Constructor {
        pub _base: Chuck_Instr,
        pub pre_ctor: *mut Chuck_VM_Code,
        pub stack_offset: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Pre_Constructor() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Pre_Constructor>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Pre_Constructor))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Pre_Constructor>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Pre_Constructor))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Pre_Constructor>())).pre_ctor as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Pre_Constructor),
                "::",
                stringify!(pre_ctor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Pre_Constructor>())).stack_offset as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Pre_Constructor),
                "::",
                stringify!(stack_offset)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Pre_Constructor"]
        pub fn Chuck_Instr_Pre_Constructor_Chuck_Instr_Pre_Constructor(
            this: *mut Chuck_Instr_Pre_Constructor,
            pre: *mut Chuck_VM_Code,
            offset: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Pre_Constructor {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Pre_Constructor {
        #[inline]
        pub unsafe fn new(pre: *mut Chuck_VM_Code, offset: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Pre_Constructor_Chuck_Instr_Pre_Constructor(
                &mut __bindgen_tmp,
                pre,
                offset,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Pre_Constructor_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Pre_Ctor_Array_Top {
        pub _base: Chuck_Instr_Unary_Op,
        pub type_: *mut Chuck_Type,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Pre_Ctor_Array_Top() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Pre_Ctor_Array_Top>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Pre_Ctor_Array_Top))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Pre_Ctor_Array_Top>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Pre_Ctor_Array_Top))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Pre_Ctor_Array_Top>())).type_ as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Pre_Ctor_Array_Top),
                "::",
                stringify!(type_)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Pre_Ctor_Array_Top"]
        pub fn Chuck_Instr_Pre_Ctor_Array_Top_Chuck_Instr_Pre_Ctor_Array_Top(
            this: *mut Chuck_Instr_Pre_Ctor_Array_Top,
            t: *mut Chuck_Type,
        );
    }
    impl Default for Chuck_Instr_Pre_Ctor_Array_Top {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Pre_Ctor_Array_Top {
        #[inline]
        pub unsafe fn new(t: *mut Chuck_Type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Pre_Ctor_Array_Top_Chuck_Instr_Pre_Ctor_Array_Top(&mut __bindgen_tmp, t);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Pre_Ctor_Array_Top_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Pre_Ctor_Array_Top_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Pre_Ctor_Array_Bottom {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Pre_Ctor_Array_Bottom() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Pre_Ctor_Array_Bottom>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Pre_Ctor_Array_Bottom))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Pre_Ctor_Array_Bottom>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Pre_Ctor_Array_Bottom)
            )
        );
    }
    impl Default for Chuck_Instr_Pre_Ctor_Array_Bottom {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Pre_Ctor_Array_Bottom_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Pre_Ctor_Array_Post {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Pre_Ctor_Array_Post() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Pre_Ctor_Array_Post>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Pre_Ctor_Array_Post))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Pre_Ctor_Array_Post>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Pre_Ctor_Array_Post))
        );
    }
    impl Default for Chuck_Instr_Pre_Ctor_Array_Post {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Pre_Ctor_Array_Post_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Array_Prepend {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Prepend() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Prepend>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Prepend))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Prepend>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Prepend))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Prepend"]
        pub fn Chuck_Instr_Array_Prepend_Chuck_Instr_Array_Prepend(
            this: *mut Chuck_Instr_Array_Prepend,
            size: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Array_Prepend {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Array_Prepend {
        #[inline]
        pub unsafe fn new(size: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Prepend_Chuck_Instr_Array_Prepend(&mut __bindgen_tmp, size);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Prepend_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Array_Append {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Append() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Append>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Append))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Append>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Append))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Append"]
        pub fn Chuck_Instr_Array_Append_Chuck_Instr_Array_Append(
            this: *mut Chuck_Instr_Array_Append,
            size: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Array_Append {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Array_Append {
        #[inline]
        pub unsafe fn new(size: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Append_Chuck_Instr_Array_Append(&mut __bindgen_tmp, size);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Append_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Assign_String {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Assign_String() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Assign_String>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Assign_String))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Assign_String>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Assign_String))
        );
    }
    impl Default for Chuck_Instr_Assign_String {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Assign_String_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Assign_Primitive {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Assign_Primitive() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Assign_Primitive>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Assign_Primitive))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Assign_Primitive>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Assign_Primitive))
        );
    }
    impl Default for Chuck_Instr_Assign_Primitive {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Assign_Primitive_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Assign_Object {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Assign_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Assign_Object>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Assign_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Assign_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Assign_Object))
        );
    }
    impl Default for Chuck_Instr_Assign_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Assign_Object_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Assign_Object_To_Map {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Assign_Object_To_Map() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Assign_Object_To_Map>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Assign_Object_To_Map))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Assign_Object_To_Map>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Assign_Object_To_Map)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Assign_Object_To_Map"]
        pub fn Chuck_Instr_Assign_Object_To_Map_Chuck_Instr_Assign_Object_To_Map(
            this: *mut Chuck_Instr_Assign_Object_To_Map,
            size: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Assign_Object_To_Map {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Assign_Object_To_Map {
        #[inline]
        pub unsafe fn new(size: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Assign_Object_To_Map_Chuck_Instr_Assign_Object_To_Map(
                &mut __bindgen_tmp,
                size,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Assign_Object_To_Map_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_AddRef_Object {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_AddRef_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_AddRef_Object>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_AddRef_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_AddRef_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_AddRef_Object))
        );
    }
    impl Default for Chuck_Instr_AddRef_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_AddRef_Object_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Release_Object {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Release_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Release_Object>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Release_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Release_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Release_Object))
        );
    }
    impl Default for Chuck_Instr_Release_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Release_Object_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Func_To_Code {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Func_To_Code() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Func_To_Code>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Func_To_Code))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Func_To_Code>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Func_To_Code))
        );
    }
    impl Default for Chuck_Instr_Func_To_Code {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Func_To_Code_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Func_Call {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Func_Call() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Func_Call>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Func_Call))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Func_Call>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Func_Call))
        );
    }
    impl Default for Chuck_Instr_Func_Call {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Func_Call_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Func_Call_Member {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Func_Call_Member() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Func_Call_Member>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Func_Call_Member))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Func_Call_Member>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Func_Call_Member))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Func_Call_Member"]
        pub fn Chuck_Instr_Func_Call_Member_Chuck_Instr_Func_Call_Member(
            this: *mut Chuck_Instr_Func_Call_Member,
            ret_size: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Func_Call_Member {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Func_Call_Member {
        #[inline]
        pub unsafe fn new(ret_size: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Func_Call_Member_Chuck_Instr_Func_Call_Member(&mut __bindgen_tmp, ret_size);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Func_Call_Member_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Func_Call_Static {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Func_Call_Static() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Func_Call_Static>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Func_Call_Static))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Func_Call_Static>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Func_Call_Static))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Func_Call_Static"]
        pub fn Chuck_Instr_Func_Call_Static_Chuck_Instr_Func_Call_Static(
            this: *mut Chuck_Instr_Func_Call_Static,
            ret_size: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Func_Call_Static {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Func_Call_Static {
        #[inline]
        pub unsafe fn new(ret_size: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Func_Call_Static_Chuck_Instr_Func_Call_Static(&mut __bindgen_tmp, ret_size);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Func_Call_Static_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Func_Return {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Func_Return() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Func_Return>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Func_Return))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Func_Return>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Func_Return))
        );
    }
    impl Default for Chuck_Instr_Func_Return {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Func_Return_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Spork {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Spork() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Spork>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Spork))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Spork>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Spork))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Spork"]
        pub fn Chuck_Instr_Spork_Chuck_Instr_Spork(
            this: *mut Chuck_Instr_Spork,
            v: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Spork {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Spork {
        #[inline]
        pub unsafe fn new(v: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Spork_Chuck_Instr_Spork(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Spork_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Time_Advance {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Time_Advance() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Time_Advance>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Time_Advance))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Time_Advance>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Time_Advance))
        );
    }
    impl Default for Chuck_Instr_Time_Advance {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Time_Advance_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Event_Wait {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Event_Wait() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Event_Wait>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Event_Wait))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Event_Wait>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Event_Wait))
        );
    }
    impl Default for Chuck_Instr_Event_Wait {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Event_Wait_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Array_Init {
        pub _base: Chuck_Instr,
        pub m_type_ref: *mut Chuck_Type,
        pub m_length: ::std::os::raw::c_long,
        pub m_is_obj: ::std::os::raw::c_ulong,
        pub m_param_str: *mut ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Init() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Init>(),
            48usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Init))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Init>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Init))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Init>())).m_type_ref as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Init),
                "::",
                stringify!(m_type_ref)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Init>())).m_length as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Init),
                "::",
                stringify!(m_length)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Init>())).m_is_obj as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Init),
                "::",
                stringify!(m_is_obj)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Init>())).m_param_str as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Init),
                "::",
                stringify!(m_param_str)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Init"]
        pub fn Chuck_Instr_Array_Init_Chuck_Instr_Array_Init(
            this: *mut Chuck_Instr_Array_Init,
            env: *mut Chuck_Env,
            the_type: *mut Chuck_Type,
            length: ::std::os::raw::c_long,
        );
    }
    impl Default for Chuck_Instr_Array_Init {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Array_Init {
        #[inline]
        pub unsafe fn new(
            env: *mut Chuck_Env,
            the_type: *mut Chuck_Type,
            length: ::std::os::raw::c_long,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Init_Chuck_Instr_Array_Init(
                &mut __bindgen_tmp,
                env,
                the_type,
                length,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Init_destructor"]
        pub fn Chuck_Instr_Array_Init_Chuck_Instr_Array_Init_destructor(
            this: *mut Chuck_Instr_Array_Init,
        );
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Init_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Array_Init_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Array_Alloc {
        pub _base: Chuck_Instr,
        pub m_depth: ::std::os::raw::c_ulong,
        pub m_type_ref: *mut Chuck_Type,
        pub m_is_obj: ::std::os::raw::c_ulong,
        pub m_param_str: *mut ::std::os::raw::c_char,
        pub m_stack_offset: ::std::os::raw::c_ulong,
        pub m_is_ref: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Alloc() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Alloc>(),
            64usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Alloc))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Alloc>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Alloc))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Alloc>())).m_depth as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Alloc),
                "::",
                stringify!(m_depth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Alloc>())).m_type_ref as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Alloc),
                "::",
                stringify!(m_type_ref)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Alloc>())).m_is_obj as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Alloc),
                "::",
                stringify!(m_is_obj)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Alloc>())).m_param_str as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Alloc),
                "::",
                stringify!(m_param_str)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Alloc>())).m_stack_offset as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Alloc),
                "::",
                stringify!(m_stack_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Alloc>())).m_is_ref as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Alloc),
                "::",
                stringify!(m_is_ref)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Alloc"]
        pub fn Chuck_Instr_Array_Alloc_Chuck_Instr_Array_Alloc(
            this: *mut Chuck_Instr_Array_Alloc,
            env: *mut Chuck_Env,
            depth: ::std::os::raw::c_ulong,
            the_type: *mut Chuck_Type,
            offset: ::std::os::raw::c_ulong,
            ref_: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Array_Alloc {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Array_Alloc {
        #[inline]
        pub unsafe fn new(
            env: *mut Chuck_Env,
            depth: ::std::os::raw::c_ulong,
            the_type: *mut Chuck_Type,
            offset: ::std::os::raw::c_ulong,
            ref_: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Alloc_Chuck_Instr_Array_Alloc(
                &mut __bindgen_tmp,
                env,
                depth,
                the_type,
                offset,
                ref_,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Alloc_destructor"]
        pub fn Chuck_Instr_Array_Alloc_Chuck_Instr_Array_Alloc_destructor(
            this: *mut Chuck_Instr_Array_Alloc,
        );
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Alloc_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Array_Alloc_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Array_Access {
        pub _base: Chuck_Instr,
        pub m_kind: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
        pub m_istr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Access() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Access>(),
            40usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Access))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Access>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Access))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access>())).m_kind as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access),
                "::",
                stringify!(m_kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access>())).m_emit_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access),
                "::",
                stringify!(m_emit_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access>())).m_istr as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access),
                "::",
                stringify!(m_istr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Access"]
        pub fn Chuck_Instr_Array_Access_Chuck_Instr_Array_Access(
            this: *mut Chuck_Instr_Array_Access,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
            istr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Array_Access {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Array_Access {
        #[inline]
        pub unsafe fn new(
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
            istr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Access_Chuck_Instr_Array_Access(
                &mut __bindgen_tmp,
                kind,
                emit_addr,
                istr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Access_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Array_Access_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Array_Map_Access {
        pub _base: Chuck_Instr,
        pub m_kind: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Map_Access() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Map_Access>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Map_Access))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Map_Access>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Map_Access))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Map_Access>())).m_kind as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Map_Access),
                "::",
                stringify!(m_kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Map_Access>())).m_emit_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Map_Access),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Map_Access"]
        pub fn Chuck_Instr_Array_Map_Access_Chuck_Instr_Array_Map_Access(
            this: *mut Chuck_Instr_Array_Map_Access,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Array_Map_Access {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Array_Map_Access {
        #[inline]
        pub unsafe fn new(
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Map_Access_Chuck_Instr_Array_Map_Access(
                &mut __bindgen_tmp,
                kind,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Map_Access_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Array_Map_Access_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    pub struct Chuck_Instr_Array_Access_Multi {
        pub _base: Chuck_Instr,
        pub m_depth: ::std::os::raw::c_ulong,
        pub m_kind: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
        pub m_indexIsAssociative: vector,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Array_Access_Multi() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Array_Access_Multi>(),
            64usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Array_Access_Multi))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Array_Access_Multi>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Array_Access_Multi))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access_Multi>())).m_depth as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access_Multi),
                "::",
                stringify!(m_depth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access_Multi>())).m_kind as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access_Multi),
                "::",
                stringify!(m_kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access_Multi>())).m_emit_addr as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access_Multi),
                "::",
                stringify!(m_emit_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Array_Access_Multi>())).m_indexIsAssociative
                    as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Array_Access_Multi),
                "::",
                stringify!(m_indexIsAssociative)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}indexIsAssociative"]
        pub fn Chuck_Instr_Array_Access_Multi_indexIsAssociative(
            this: *mut Chuck_Instr_Array_Access_Multi,
        ) -> *mut vector;
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Array_Access_Multi"]
        pub fn Chuck_Instr_Array_Access_Multi_Chuck_Instr_Array_Access_Multi(
            this: *mut Chuck_Instr_Array_Access_Multi,
            depth: ::std::os::raw::c_ulong,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Array_Access_Multi {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Instr_Array_Access_Multi {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "Chuck_Instr_Array_Access_Multi {{ m_depth: {:?}, m_kind: {:?}, m_emit_addr: {:?}, m_indexIsAssociative: {:?} }}" , self . m_depth , self . m_kind , self . m_emit_addr , self . m_indexIsAssociative )
        }
    }
    impl ::std::cmp::PartialEq for Chuck_Instr_Array_Access_Multi {
        fn eq(&self, other: &Chuck_Instr_Array_Access_Multi) -> bool {
            self._base == other._base
                && self.m_depth == other.m_depth
                && self.m_kind == other.m_kind
                && self.m_emit_addr == other.m_emit_addr
                && self.m_indexIsAssociative == other.m_indexIsAssociative
        }
    }
    impl Chuck_Instr_Array_Access_Multi {
        #[inline]
        pub unsafe fn indexIsAssociative(&mut self) -> *mut vector {
            Chuck_Instr_Array_Access_Multi_indexIsAssociative(self)
        }
        #[inline]
        pub unsafe fn new(
            depth: ::std::os::raw::c_ulong,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Array_Access_Multi_Chuck_Instr_Array_Access_Multi(
                &mut __bindgen_tmp,
                depth,
                kind,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Array_Access_Multi_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Array_Access_Multi_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Member_Data {
        pub _base: Chuck_Instr,
        pub m_offset: ::std::os::raw::c_ulong,
        pub m_kind: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Member_Data() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Member_Data>(),
            40usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Member_Data))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Member_Data>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Member_Data))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Member_Data>())).m_offset as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Member_Data),
                "::",
                stringify!(m_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Member_Data>())).m_kind as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Member_Data),
                "::",
                stringify!(m_kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Member_Data>())).m_emit_addr as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Member_Data),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Member_Data"]
        pub fn Chuck_Instr_Dot_Member_Data_Chuck_Instr_Dot_Member_Data(
            this: *mut Chuck_Instr_Dot_Member_Data,
            offset: ::std::os::raw::c_ulong,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Member_Data {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Member_Data {
        #[inline]
        pub unsafe fn new(
            offset: ::std::os::raw::c_ulong,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Member_Data_Chuck_Instr_Dot_Member_Data(
                &mut __bindgen_tmp,
                offset,
                kind,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Member_Data_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Member_Data_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Member_Func {
        pub _base: Chuck_Instr,
        pub m_offset: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Member_Func() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Member_Func>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Member_Func))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Member_Func>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Member_Func))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Member_Func>())).m_offset as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Member_Func),
                "::",
                stringify!(m_offset)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Member_Func"]
        pub fn Chuck_Instr_Dot_Member_Func_Chuck_Instr_Dot_Member_Func(
            this: *mut Chuck_Instr_Dot_Member_Func,
            offset: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Member_Func {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Member_Func {
        #[inline]
        pub unsafe fn new(offset: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Member_Func_Chuck_Instr_Dot_Member_Func(&mut __bindgen_tmp, offset);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Member_Func_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Member_Func_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Primitive_Func {
        pub _base: Chuck_Instr,
        pub m_native_func: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Primitive_Func() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Primitive_Func>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Primitive_Func))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Primitive_Func>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Primitive_Func))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Primitive_Func>())).m_native_func as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Primitive_Func),
                "::",
                stringify!(m_native_func)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Primitive_Func"]
        pub fn Chuck_Instr_Dot_Primitive_Func_Chuck_Instr_Dot_Primitive_Func(
            this: *mut Chuck_Instr_Dot_Primitive_Func,
            native_func: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Primitive_Func {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Primitive_Func {
        #[inline]
        pub unsafe fn new(native_func: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Primitive_Func_Chuck_Instr_Dot_Primitive_Func(
                &mut __bindgen_tmp,
                native_func,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Primitive_Func_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Primitive_Func_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Static_Data {
        pub _base: Chuck_Instr,
        pub m_offset: ::std::os::raw::c_ulong,
        pub m_size: ::std::os::raw::c_ulong,
        pub m_kind: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Static_Data() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Static_Data>(),
            48usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Static_Data))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Static_Data>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Static_Data))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Data>())).m_offset as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Data),
                "::",
                stringify!(m_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Data>())).m_size as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Data),
                "::",
                stringify!(m_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Data>())).m_kind as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Data),
                "::",
                stringify!(m_kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Data>())).m_emit_addr as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Data),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Static_Data"]
        pub fn Chuck_Instr_Dot_Static_Data_Chuck_Instr_Dot_Static_Data(
            this: *mut Chuck_Instr_Dot_Static_Data,
            offset: ::std::os::raw::c_ulong,
            size: ::std::os::raw::c_ulong,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Static_Data {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Static_Data {
        #[inline]
        pub unsafe fn new(
            offset: ::std::os::raw::c_ulong,
            size: ::std::os::raw::c_ulong,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Static_Data_Chuck_Instr_Dot_Static_Data(
                &mut __bindgen_tmp,
                offset,
                size,
                kind,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Static_Data_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Static_Data_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Static_Import_Data {
        pub _base: Chuck_Instr,
        pub m_addr: *mut ::std::os::raw::c_void,
        pub m_kind: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Static_Import_Data() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Static_Import_Data>(),
            40usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Static_Import_Data))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Static_Import_Data>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Dot_Static_Import_Data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Import_Data>())).m_addr as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Import_Data),
                "::",
                stringify!(m_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Import_Data>())).m_kind as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Import_Data),
                "::",
                stringify!(m_kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Import_Data>())).m_emit_addr
                    as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Import_Data),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Static_Import_Data"]
        pub fn Chuck_Instr_Dot_Static_Import_Data_Chuck_Instr_Dot_Static_Import_Data(
            this: *mut Chuck_Instr_Dot_Static_Import_Data,
            addr: *mut ::std::os::raw::c_void,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Static_Import_Data {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Static_Import_Data {
        #[inline]
        pub unsafe fn new(
            addr: *mut ::std::os::raw::c_void,
            kind: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Static_Import_Data_Chuck_Instr_Dot_Static_Import_Data(
                &mut __bindgen_tmp,
                addr,
                kind,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Static_Import_Data_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Static_Import_Data_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Static_Func {
        pub _base: Chuck_Instr,
        pub m_func: *mut Chuck_Func,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Static_Func() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Static_Func>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Static_Func))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Static_Func>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Static_Func))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Static_Func>())).m_func as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Static_Func),
                "::",
                stringify!(m_func)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Static_Func"]
        pub fn Chuck_Instr_Dot_Static_Func_Chuck_Instr_Dot_Static_Func(
            this: *mut Chuck_Instr_Dot_Static_Func,
            func: *mut Chuck_Func,
        );
    }
    impl Default for Chuck_Instr_Dot_Static_Func {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Static_Func {
        #[inline]
        pub unsafe fn new(func: *mut Chuck_Func) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Static_Func_Chuck_Instr_Dot_Static_Func(&mut __bindgen_tmp, func);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Static_Func_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Static_Func_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Cmp_First {
        pub _base: Chuck_Instr,
        pub m_is_mem: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Cmp_First() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Cmp_First>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Cmp_First))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Cmp_First>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Cmp_First))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_First>())).m_is_mem as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_First),
                "::",
                stringify!(m_is_mem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_First>())).m_emit_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_First),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Cmp_First"]
        pub fn Chuck_Instr_Dot_Cmp_First_Chuck_Instr_Dot_Cmp_First(
            this: *mut Chuck_Instr_Dot_Cmp_First,
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Cmp_First {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Cmp_First {
        #[inline]
        pub unsafe fn new(
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Cmp_First_Chuck_Instr_Dot_Cmp_First(
                &mut __bindgen_tmp,
                is_mem,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Cmp_First_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Cmp_First_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Cmp_Second {
        pub _base: Chuck_Instr,
        pub m_is_mem: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Cmp_Second() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Cmp_Second>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Cmp_Second))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Cmp_Second>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Cmp_Second))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_Second>())).m_is_mem as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_Second),
                "::",
                stringify!(m_is_mem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_Second>())).m_emit_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_Second),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Cmp_Second"]
        pub fn Chuck_Instr_Dot_Cmp_Second_Chuck_Instr_Dot_Cmp_Second(
            this: *mut Chuck_Instr_Dot_Cmp_Second,
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Cmp_Second {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Cmp_Second {
        #[inline]
        pub unsafe fn new(
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Cmp_Second_Chuck_Instr_Dot_Cmp_Second(
                &mut __bindgen_tmp,
                is_mem,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Cmp_Second_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Cmp_Second_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Cmp_Third {
        pub _base: Chuck_Instr,
        pub m_is_mem: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Cmp_Third() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Cmp_Third>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Cmp_Third))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Cmp_Third>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Cmp_Third))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_Third>())).m_is_mem as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_Third),
                "::",
                stringify!(m_is_mem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_Third>())).m_emit_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_Third),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Cmp_Third"]
        pub fn Chuck_Instr_Dot_Cmp_Third_Chuck_Instr_Dot_Cmp_Third(
            this: *mut Chuck_Instr_Dot_Cmp_Third,
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Cmp_Third {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Cmp_Third {
        #[inline]
        pub unsafe fn new(
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Cmp_Third_Chuck_Instr_Dot_Cmp_Third(
                &mut __bindgen_tmp,
                is_mem,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Cmp_Third_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Cmp_Third_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dot_Cmp_Fourth {
        pub _base: Chuck_Instr,
        pub m_is_mem: ::std::os::raw::c_ulong,
        pub m_emit_addr: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dot_Cmp_Fourth() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dot_Cmp_Fourth>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dot_Cmp_Fourth))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dot_Cmp_Fourth>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dot_Cmp_Fourth))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_Fourth>())).m_is_mem as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_Fourth),
                "::",
                stringify!(m_is_mem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Dot_Cmp_Fourth>())).m_emit_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Dot_Cmp_Fourth),
                "::",
                stringify!(m_emit_addr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Dot_Cmp_Fourth"]
        pub fn Chuck_Instr_Dot_Cmp_Fourth_Chuck_Instr_Dot_Cmp_Fourth(
            this: *mut Chuck_Instr_Dot_Cmp_Fourth,
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Dot_Cmp_Fourth {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Dot_Cmp_Fourth {
        #[inline]
        pub unsafe fn new(
            is_mem: ::std::os::raw::c_ulong,
            emit_addr: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Dot_Cmp_Fourth_Chuck_Instr_Dot_Cmp_Fourth(
                &mut __bindgen_tmp,
                is_mem,
                emit_addr,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dot_Cmp_Fourth_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Dot_Cmp_Fourth_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_ADC {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_ADC() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_ADC>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_ADC))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_ADC>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_ADC))
        );
    }
    impl Default for Chuck_Instr_ADC {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_ADC_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_DAC {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_DAC() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_DAC>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_DAC))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_DAC>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_DAC))
        );
    }
    impl Default for Chuck_Instr_DAC {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_DAC_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Bunghole {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Bunghole() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Bunghole>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Bunghole))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Bunghole>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Bunghole))
        );
    }
    impl Default for Chuck_Instr_Bunghole {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Bunghole_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Chout {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Chout() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Chout>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Chout))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Chout>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Chout))
        );
    }
    impl Default for Chuck_Instr_Chout {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Chout_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Cherr {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Cherr() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Cherr>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Cherr))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Cherr>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Cherr))
        );
    }
    impl Default for Chuck_Instr_Cherr {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Cherr_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_UGen_Link {
        pub _base: Chuck_Instr,
        pub m_isUpChuck: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_UGen_Link() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_UGen_Link>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_UGen_Link))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_UGen_Link>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_UGen_Link))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_UGen_Link>())).m_isUpChuck as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_UGen_Link),
                "::",
                stringify!(m_isUpChuck)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_UGen_Link"]
        pub fn Chuck_Instr_UGen_Link_Chuck_Instr_UGen_Link(
            this: *mut Chuck_Instr_UGen_Link,
            isUpChuck: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_UGen_Link {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_UGen_Link {
        #[inline]
        pub unsafe fn new(isUpChuck: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_UGen_Link_Chuck_Instr_UGen_Link(&mut __bindgen_tmp, isUpChuck);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_UGen_Link_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_UGen_Array_Link {
        pub _base: Chuck_Instr,
        pub m_srcIsArray: ::std::os::raw::c_ulong,
        pub m_dstIsArray: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_UGen_Array_Link() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_UGen_Array_Link>(),
            32usize,
            concat!("Size of: ", stringify!(Chuck_Instr_UGen_Array_Link))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_UGen_Array_Link>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_UGen_Array_Link))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_UGen_Array_Link>())).m_srcIsArray as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_UGen_Array_Link),
                "::",
                stringify!(m_srcIsArray)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_UGen_Array_Link>())).m_dstIsArray as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_UGen_Array_Link),
                "::",
                stringify!(m_dstIsArray)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_UGen_Array_Link"]
        pub fn Chuck_Instr_UGen_Array_Link_Chuck_Instr_UGen_Array_Link(
            this: *mut Chuck_Instr_UGen_Array_Link,
            srcIsArray: ::std::os::raw::c_ulong,
            dstIsArray: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_UGen_Array_Link {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_UGen_Array_Link {
        #[inline]
        pub unsafe fn new(
            srcIsArray: ::std::os::raw::c_ulong,
            dstIsArray: ::std::os::raw::c_ulong,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_UGen_Array_Link_Chuck_Instr_UGen_Array_Link(
                &mut __bindgen_tmp,
                srcIsArray,
                dstIsArray,
            );
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_UGen_Array_Link_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_UGen_UnLink {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_UGen_UnLink() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_UGen_UnLink>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_UGen_UnLink))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_UGen_UnLink>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_UGen_UnLink))
        );
    }
    impl Default for Chuck_Instr_UGen_UnLink {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_UGen_UnLink_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_UGen_Ctrl {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_UGen_Ctrl() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_UGen_Ctrl>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_UGen_Ctrl))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_UGen_Ctrl>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_UGen_Ctrl))
        );
    }
    impl Default for Chuck_Instr_UGen_Ctrl {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_UGen_Ctrl_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_UGen_CGet {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_UGen_CGet() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_UGen_CGet>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_UGen_CGet))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_UGen_CGet>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_UGen_CGet))
        );
    }
    impl Default for Chuck_Instr_UGen_CGet {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_UGen_CGet_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_UGen_PMsg {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_UGen_PMsg() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_UGen_PMsg>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_UGen_PMsg))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_UGen_PMsg>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_UGen_PMsg))
        );
    }
    impl Default for Chuck_Instr_UGen_PMsg {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_UGen_PMsg_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Op_string {
        pub _base: Chuck_Instr_Unary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Op_string() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Op_string>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Op_string))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Op_string>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Op_string))
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Op_string"]
        pub fn Chuck_Instr_Op_string_Chuck_Instr_Op_string(
            this: *mut Chuck_Instr_Op_string,
            v: ::std::os::raw::c_ulong,
        );
    }
    impl Default for Chuck_Instr_Op_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Op_string {
        #[inline]
        pub unsafe fn new(v: ::std::os::raw::c_ulong) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Op_string_Chuck_Instr_Op_string(&mut __bindgen_tmp, v);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Op_string_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Init_Loop_Counter {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Init_Loop_Counter() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Init_Loop_Counter>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Init_Loop_Counter))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Init_Loop_Counter>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Init_Loop_Counter))
        );
    }
    impl Default for Chuck_Instr_Init_Loop_Counter {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Init_Loop_Counter_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Reg_Push_Loop_Counter_Deref {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Reg_Push_Loop_Counter_Deref() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Reg_Push_Loop_Counter_Deref>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(Chuck_Instr_Reg_Push_Loop_Counter_Deref)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Reg_Push_Loop_Counter_Deref>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(Chuck_Instr_Reg_Push_Loop_Counter_Deref)
            )
        );
    }
    impl Default for Chuck_Instr_Reg_Push_Loop_Counter_Deref {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Reg_Push_Loop_Counter_Deref_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Dec_Loop_Counter {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Dec_Loop_Counter() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Dec_Loop_Counter>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Dec_Loop_Counter))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Dec_Loop_Counter>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Dec_Loop_Counter))
        );
    }
    impl Default for Chuck_Instr_Dec_Loop_Counter {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Dec_Loop_Counter_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Pop_Loop_Counter {
        pub _base: Chuck_Instr,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Pop_Loop_Counter() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Pop_Loop_Counter>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Pop_Loop_Counter))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Pop_Loop_Counter>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Pop_Loop_Counter))
        );
    }
    impl Default for Chuck_Instr_Pop_Loop_Counter {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Pop_Loop_Counter_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_IO_in_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_IO_in_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_IO_in_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_IO_in_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_IO_in_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_IO_in_int))
        );
    }
    impl Default for Chuck_Instr_IO_in_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_IO_in_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_IO_in_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_IO_in_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_IO_in_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_IO_in_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_IO_in_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_IO_in_float))
        );
    }
    impl Default for Chuck_Instr_IO_in_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_IO_in_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_IO_in_string {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_IO_in_string() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_IO_in_string>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_IO_in_string))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_IO_in_string>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_IO_in_string))
        );
    }
    impl Default for Chuck_Instr_IO_in_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_IO_in_string_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_IO_out_int {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_IO_out_int() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_IO_out_int>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_IO_out_int))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_IO_out_int>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_IO_out_int))
        );
    }
    impl Default for Chuck_Instr_IO_out_int {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_IO_out_int_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_IO_out_float {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_IO_out_float() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_IO_out_float>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_IO_out_float))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_IO_out_float>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_IO_out_float))
        );
    }
    impl Default for Chuck_Instr_IO_out_float {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_IO_out_float_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_IO_out_string {
        pub _base: Chuck_Instr_Binary_Op,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_IO_out_string() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_IO_out_string>(),
            16usize,
            concat!("Size of: ", stringify!(Chuck_Instr_IO_out_string))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_IO_out_string>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_IO_out_string))
        );
    }
    impl Default for Chuck_Instr_IO_out_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_IO_out_string_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Instr_Hack {
        pub _base: Chuck_Instr,
        pub m_type_ref: *mut Chuck_Type,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Hack() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Hack>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Hack))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Hack>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Hack))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Instr_Hack>())).m_type_ref as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Hack),
                "::",
                stringify!(m_type_ref)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Hack"]
        pub fn Chuck_Instr_Hack_Chuck_Instr_Hack(
            this: *mut Chuck_Instr_Hack,
            type_: *mut Chuck_Type,
        );
    }
    impl Default for Chuck_Instr_Hack {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Instr_Hack {
        #[inline]
        pub unsafe fn new(type_: *mut Chuck_Type) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Hack_Chuck_Instr_Hack(&mut __bindgen_tmp, type_);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Hack_destructor"]
        pub fn Chuck_Instr_Hack_Chuck_Instr_Hack_destructor(this: *mut Chuck_Instr_Hack);
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Hack_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Hack_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    pub struct Chuck_Instr_Gack {
        pub _base: Chuck_Instr,
        pub m_type_refs: vector,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Instr_Gack() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Instr_Gack>(),
            40usize,
            concat!("Size of: ", stringify!(Chuck_Instr_Gack))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Instr_Gack>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Instr_Gack))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<Chuck_Instr_Gack>())).m_type_refs as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Instr_Gack),
                "::",
                stringify!(m_type_refs)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Gack"]
        pub fn Chuck_Instr_Gack_Chuck_Instr_Gack(this: *mut Chuck_Instr_Gack, types: *const vector);
    }
    impl Default for Chuck_Instr_Gack {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Instr_Gack {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Instr_Gack {{ m_type_refs: {:?} }}",
                self.m_type_refs
            )
        }
    }
    impl ::std::cmp::PartialEq for Chuck_Instr_Gack {
        fn eq(&self, other: &Chuck_Instr_Gack) -> bool {
            self._base == other._base && self.m_type_refs == other.m_type_refs
        }
    }
    impl Chuck_Instr_Gack {
        #[inline]
        pub unsafe fn new(types: *const vector) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Instr_Gack_Chuck_Instr_Gack(&mut __bindgen_tmp, types);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Instr_Gack_destructor"]
        pub fn Chuck_Instr_Gack_Chuck_Instr_Gack_destructor(this: *mut Chuck_Instr_Gack);
    }
    extern "C" {
        #[link_name = "\u{1}execute"]
        pub fn Chuck_Instr_Gack_execute(
            this: *mut ::std::os::raw::c_void,
            vm: *mut Chuck_VM,
            shred: *mut Chuck_VM_Shred,
        );
    }
    extern "C" {
        #[link_name = "\u{1}params"]
        pub fn Chuck_Instr_Gack_params(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __locale_data {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_stringstream_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_stringstream<::std::os::raw::c_char>>(),
            392usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_stringstream<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_stringstream<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_stringstream<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_fstream_open0_char_char_traits_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_fstream<::std::os::raw::c_char>>(),
            528usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_fstream<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_fstream<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_fstream<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_ptr_WvOut_ptr_WvOut__bindgen_ty_id_55893_open1_ptr_WvOut_close1_allocator_open1_pair_open2_ptr_WvOut_ptr_WvOut_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_WvOut_ptr_WvOut_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_ptr_WvOut_ptr_WvOut_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<pair<*mut WvOut, *mut WvOut>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(pair<*mut WvOut, *mut WvOut>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<pair<*mut WvOut, *mut WvOut>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(pair<*mut WvOut, *mut WvOut>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_iterator_open0_output_iterator_tag_void_void_void_void_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<iterator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(iterator))
        );
        assert_eq!(
            ::std::mem::align_of::<iterator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(iterator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout___basic_file_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<__basic_file>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(__basic_file)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<__basic_file>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(__basic_file)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_VM_Object_allocator_open1_ptr_Chuck_VM_Object_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Object_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Func_allocator_open1_ptr_Chuck_Func_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Func_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_unsigned_long_allocator_open1_unsigned_long_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_unsigned_long_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_string_unsigned_long_less_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_allocator_open1_pair_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_unsigned_long_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_less_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<less>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(less))
        );
        assert_eq!(
            ::std::mem::align_of::<less>(),
            1usize,
            concat!("Alignment of template specialization: ", stringify!(less))
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_unsigned_long_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_queue_open0_ptr_Chuck_VM_Shred_deque_open1_ptr_Chuck_VM_Shred_allocator_open2_ptr_Chuck_VM_Shred_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<queue<deque>>(),
            80usize,
            concat!(
                "Size of template specialization: ",
                stringify!(queue<deque>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<queue<deque>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(queue<deque>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_deque_open0_ptr_Chuck_VM_Shred_allocator_open1_ptr_Chuck_VM_Shred_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<deque>(),
            80usize,
            concat!("Size of template specialization: ", stringify!(deque))
        );
        assert_eq!(
            ::std::mem::align_of::<deque>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(deque))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Shred_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_map_allocator_open1_ptr_map_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_S_Symbol_ptr_Chuck_VM_Object__bindgen_ty_id_59156_open1_ptr_S_Symbol__close1_allocator_open1_pair_open2_ptr_S_Symbol__ptr_Chuck_VM_Object_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_S_Symbol__ptr_Chuck_VM_Object_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_ptr_S_Symbol__ptr_Chuck_VM_Object_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<pair<*mut S_Symbol_, *mut Chuck_VM_Object>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(pair<*mut S_Symbol_, *mut Chuck_VM_Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<pair<*mut S_Symbol_, *mut Chuck_VM_Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(pair<*mut S_Symbol_, *mut Chuck_VM_Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_map_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_ptr_S_Symbol__ptr_Chuck_VM_Object__bindgen_ty_id_59176_open1_ptr_S_Symbol__close1_allocator_open1_pair_open2_ptr_S_Symbol__ptr_Chuck_VM_Object_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_S_Symbol__ptr_Chuck_VM_Object_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_ptr_S_Symbol__ptr_Chuck_VM_Object_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<pair<*mut S_Symbol_, *mut Chuck_VM_Object>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(pair<*mut S_Symbol_, *mut Chuck_VM_Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<pair<*mut S_Symbol_, *mut Chuck_VM_Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(pair<*mut S_Symbol_, *mut Chuck_VM_Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_S_Symbol_ptr_Chuck_VM_Object__bindgen_ty_id_59195_open1_ptr_S_Symbol__close1_allocator_open1_pair_open2_ptr_S_Symbol__ptr_Chuck_VM_Object_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_S_Symbol__ptr_Chuck_VM_Object_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_ptr_S_Symbol__ptr_Chuck_VM_Object_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<pair<*mut S_Symbol_, *mut Chuck_VM_Object>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(pair<*mut S_Symbol_, *mut Chuck_VM_Object>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<pair<*mut S_Symbol_, *mut Chuck_VM_Object>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(pair<*mut S_Symbol_, *mut Chuck_VM_Object>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Chuck_Scope_open0_ptr_Chuck_Type_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Scope>(),
            72usize,
            concat!("Size of template specialization: ", stringify!(Chuck_Scope))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Scope>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(Chuck_Scope)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Chuck_Scope_open0_ptr_Chuck_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Scope>(),
            72usize,
            concat!("Size of template specialization: ", stringify!(Chuck_Scope))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Scope>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(Chuck_Scope)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Chuck_Scope_open0_ptr_Chuck_Func_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Scope>(),
            72usize,
            concat!("Size of template specialization: ", stringify!(Chuck_Scope))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Scope>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(Chuck_Scope)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Type_allocator_open1_ptr_Chuck_Type_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Type_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Func_allocator_open1_ptr_Chuck_Func_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Func_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_VM_Object_allocator_open1_ptr_Chuck_VM_Object_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Object_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_VM_Object_allocator_open1_ptr_Chuck_VM_Object_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Object_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_VM_Object_allocator_open1_ptr_Chuck_VM_Object_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Object_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_VM_Object_allocator_open1_ptr_Chuck_VM_Object_close1_close0_instantiation_4(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Object_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_ptr_Chuck_Namespace_ptr_Chuck_Namespace__bindgen_ty_id_59316_open1_ptr_Chuck_Namespace_close1_allocator_open1_pair_open2_ptr_Chuck_Namespace_ptr_Chuck_Namespace_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_ptr_Chuck_Namespace_ptr_Chuck_Namespace_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_pair_open0_ptr_Chuck_Namespace_ptr_Chuck_Namespace_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<pair<*mut Chuck_Namespace, *mut Chuck_Namespace>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(pair<*mut Chuck_Namespace, *mut Chuck_Namespace>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<pair<*mut Chuck_Namespace, *mut Chuck_Namespace>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(pair<*mut Chuck_Namespace, *mut Chuck_Namespace>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Namespace_allocator_open1_ptr_Chuck_Namespace_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Namespace_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Type_allocator_open1_ptr_Chuck_Type_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Type_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Context_allocator_open1_ptr_Chuck_Context_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Context_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_a_Stmt_allocator_open1_ptr_a_Stmt__close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_a_Stmt__close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_string_unsigned_long_less_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_allocator_open1_pair_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_unsigned_long_close2_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_less_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<less>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(less))
        );
        assert_eq!(
            ::std::mem::align_of::<less>(),
            1usize,
            concat!("Alignment of template specialization: ", stringify!(less))
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_unsigned_long_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_4(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_string_unsigned_long_less_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_allocator_open1_pair_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_unsigned_long_close2_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_less_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<less>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(less))
        );
        assert_eq!(
            ::std::mem::align_of::<less>(),
            1usize,
            concat!("Alignment of template specialization: ", stringify!(less))
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_5(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_unsigned_long_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_6(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_string_unsigned_long_less_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_allocator_open1_pair_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_unsigned_long_close2_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_less_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<less>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(less))
        );
        assert_eq!(
            ::std::mem::align_of::<less>(),
            1usize,
            concat!("Alignment of template specialization: ", stringify!(less))
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_7(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_unsigned_long_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_8(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_map_open0_string_string_less_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_allocator_open1_pair_open2_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_basic_string_open3_char_char_traits_open4_char_close4_allocator_open4_char_close4_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<map>(),
            48usize,
            concat!("Size of template specialization: ", stringify!(map))
        );
        assert_eq!(
            ::std::mem::align_of::<map>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(map))
        );
    }
    #[test]
    fn __bindgen_test_layout_less_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation_4(
    ) {
        assert_eq!(
            ::std::mem::size_of::<less>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(less))
        );
        assert_eq!(
            ::std::mem::align_of::<less>(),
            1usize,
            concat!("Alignment of template specialization: ", stringify!(less))
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_9(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_10(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_11(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_string_allocator_open1_basic_string_open2_char_char_traits_open3_char_close3_allocator_open3_char_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation_12(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_unsigned_long_allocator_open1_unsigned_long_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_unsigned_long_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_unsigned_long_allocator_open1_unsigned_long_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_unsigned_long_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Type_allocator_open1_ptr_Chuck_Type_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Type_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Type_allocator_open1_ptr_Chuck_Type_close1_close0_instantiation_3(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Type_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
}
