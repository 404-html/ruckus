/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}

    pub mod std {

        pub mod __cxx11 {

            pub type string = basic_string<::std::os::raw::c_char>;
            #[repr(C)]
            pub struct basic_string<_CharT> {
                pub _M_dataplus: basic_string__Alloc_hider,
                pub _M_string_length: basic_string_size_type,
                pub __bindgen_anon_1: basic_string__bindgen_ty_2<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_string__Char_alloc_type = [u8; 0usize];
            pub type basic_string__Alloc_traits = __alloc_traits;
            pub type basic_string_traits_type<_Traits> = _Traits;
            pub type basic_string_value_type = [u8; 0usize];
            pub type basic_string_allocator_type = basic_string__Char_alloc_type;
            pub type basic_string_size_type = [u8; 0usize];
            pub type basic_string_difference_type = [u8; 0usize];
            pub type basic_string_reference = [u8; 0usize];
            pub type basic_string_const_reference = [u8; 0usize];
            pub type basic_string_pointer = [u8; 0usize];
            pub type basic_string_const_pointer = [u8; 0usize];
            pub type basic_string_iterator = __normal_iterator<basic_string_pointer>;
            pub type basic_string_const_iterator = __normal_iterator<basic_string_const_pointer>;
            pub type basic_string_const_reverse_iterator =
                reverse_iterator<basic_string_const_iterator>;
            pub type basic_string_reverse_iterator = reverse_iterator<basic_string_iterator>;
            pub type basic_string___const_iterator = basic_string_const_iterator;
            pub type basic_string___sv_type<_CharT> = basic_string_view<_CharT>;
            pub type basic_string__If_sv = enable_if_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
            pub struct basic_string___sv_wrapper<_CharT> {
                pub _M_sv: basic_string___sv_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string___sv_wrapper<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            #[repr(C)]
            pub struct basic_string__Alloc_hider {
                pub _M_p: basic_string_pointer,
            }
            impl Default for basic_string__Alloc_hider {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl ::std::fmt::Debug for basic_string__Alloc_hider {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__Alloc_hider {{  }}")
                }
            }
            impl ::std::cmp::PartialEq for basic_string__Alloc_hider {
                fn eq(&self, other: &basic_string__Alloc_hider) -> bool {
                    self._M_p == other._M_p
                }
            }
            pub const basic_string__S_local_capacity: basic_string__bindgen_ty_1 =
                basic_string__bindgen_ty_1::_S_local_capacity;
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
            pub enum basic_string__bindgen_ty_1 {
                _S_local_capacity = 0,
            }
            #[repr(C)]
            pub struct basic_string__bindgen_ty_2<_CharT> {
                pub _M_local_buf: crate::core::hid::hid::root::__BindgenUnionField<*mut _CharT>,
                pub _M_allocated_capacity:
                    crate::core::hid::hid::root::__BindgenUnionField<basic_string_size_type>,
                pub bindgen_union_field: u64,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string__bindgen_ty_2<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string__bindgen_ty_2<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__bindgen_ty_2 {{ union }}")
                }
            }
            impl<_CharT> Default for basic_string<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_string {{ _M_dataplus: {:?}, __bindgen_anon_1: {:?} }}",
                        self._M_dataplus, self.__bindgen_anon_1
                    )
                }
            }
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Tp> = _Tp;
        pub type remove_reference_t = remove_reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut ::std::os::raw::c_uchar,
            pub __align: aligned_storage_type__bindgen_ty_1,
            _bindgen_union_align: u64,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_aligned_storage_type() {
            assert_eq!(
                ::std::mem::size_of::<aligned_storage_type>(),
                8usize,
                concat!("Size of: ", stringify!(aligned_storage_type))
            );
            assert_eq!(
                ::std::mem::align_of::<aligned_storage_type>(),
                8usize,
                concat!("Alignment of ", stringify!(aligned_storage_type))
            );
        }
        impl Default for aligned_storage_type {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for aligned_storage_type {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "aligned_storage_type {{ union }}")
            }
        }
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = __detector;
        pub type __detected_or_t = __detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __pair_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        impl<_T1, _T2> Default for pair<_T1, _T2> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_random_access_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(random_access_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(random_access_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = __undefined;
        pub type __get_first_arg_t = __get_first_arg;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = __detected_or_t;
        pub type pointer_traits_difference_type = __detected_or_t;
        pub type pointer_traits_rebind = pointer_traits___rebind;
        pub type __ptr_rebind = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = reverse_iterator___traits_type;
        pub type reverse_iterator_reference = reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_base = new_allocator;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = allocator;
        pub type allocator_propagate_on_container_move_assignment = true_type;
        pub type allocator_is_always_equal = true_type;
        impl Default for allocator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Select1st {
            pub _address: u8,
        }
        impl Default for _Select1st {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = __allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = __detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = __detected_or_t;
        pub type allocator_traits_is_always_equal = __detected_or_t;
        pub type allocator_traits_rebind_alloc = __alloc_rebind;
        pub type allocator_traits_rebind_traits = allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = allocator_traits___construct_helper;
        pub type streamoff = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct fpos<_StateT> {
            pub _M_off: streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        impl<_StateT> Default for fpos<_StateT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type streampos = fpos<mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        impl Default for char_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: usize,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_const_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_iterator<_CharT> = *const _CharT;
        pub type basic_string_view_iterator<_CharT> = basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            reverse_iterator<basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        impl<_CharT> Default for basic_string_view<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub mod literals {}
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional__Base = u8;
        pub type optional_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_handle_common {
            pub _M_ptr: _Node_handle_common__AllocTraits,
            pub _M_alloc: optional,
        }
        pub type _Node_handle_common__AllocTraits = allocator_traits;
        pub type _Node_handle_common_allocator_type = __alloc_rebind;
        impl Default for _Node_handle_common {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_handle {
            pub _base: _Node_handle_common,
            pub _M_pkey: _Node_handle___pointer,
            pub _M_pmapped: _Node_handle___pointer,
        }
        pub type _Node_handle_key_type<_Key> = _Key;
        pub type _Node_handle_mapped_type = [u8; 0usize];
        pub type _Node_handle__AllocTraits = allocator_traits;
        pub type _Node_handle___pointer = __ptr_rebind;
        impl Default for _Node_handle {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Node_insert_return<_Iterator, _NodeHandle> {
            pub position: _Iterator,
            pub inserted: bool,
            pub node: _NodeHandle,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeHandle>>,
        }
        impl<_Iterator, _NodeHandle> Default for _Node_insert_return<_Iterator, _NodeHandle> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Rb_tree_color {
            _S_red = 0,
            _S_black = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_node_base {
            pub _M_color: _Rb_tree_color,
            pub _M_parent: _Rb_tree_node_base__Base_ptr,
            pub _M_left: _Rb_tree_node_base__Base_ptr,
            pub _M_right: _Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr = *mut _Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr = *const _Rb_tree_node_base;
        #[test]
        fn bindgen_test_layout__Rb_tree_node_base() {
            assert_eq!(
                ::std::mem::size_of::<_Rb_tree_node_base>(),
                32usize,
                concat!("Size of: ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                ::std::mem::align_of::<_Rb_tree_node_base>(),
                8usize,
                concat!("Alignment of ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_color as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_color)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_parent as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_parent)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_left as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_left)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_right as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_right)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_minimum"]
            pub fn _Rb_tree_node_base__S_minimum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_minimum"]
            pub fn _Rb_tree_node_base__S_minimum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_maximum"]
            pub fn _Rb_tree_node_base__S_maximum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_S_maximum"]
            pub fn _Rb_tree_node_base__S_maximum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr;
        }
        impl Default for _Rb_tree_node_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl _Rb_tree_node_base {
            #[inline]
            pub unsafe fn _S_minimum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_minimum(__x)
            }
            #[inline]
            pub unsafe fn _S_minimum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_minimum1(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum(
                __x: _Rb_tree_node_base__Base_ptr,
            ) -> _Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_maximum(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum1(
                __x: _Rb_tree_node_base__Const_Base_ptr,
            ) -> _Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_maximum1(__x)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_key_compare<_Key_compare> {
            pub _M_key_compare: _Key_compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key_compare>>,
        }
        impl<_Key_compare> Default for _Rb_tree_key_compare<_Key_compare> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_node {
            pub _base: _Rb_tree_node_base,
            pub _M_storage: __aligned_membuf,
        }
        pub type _Rb_tree_node__Link_type = *mut _Rb_tree_node;
        impl Default for _Rb_tree_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_iterator {
            pub _M_node: _Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category = bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = _Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr = _Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut _Rb_tree_node;
        impl Default for _Rb_tree_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: _Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_iterator = _Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category = bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self = _Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr = _Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type = *const _Rb_tree_node;
        impl Default for _Rb_tree_const_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = [u8; 0usize];
        pub type _Rb_tree__Alloc_traits = __alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut _Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr = *const _Rb_tree_node_base;
        pub type _Rb_tree__Link_type = *mut _Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const _Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree__Reuse_or_alloc_node {
            pub _M_root: _Rb_tree__Base_ptr,
            pub _M_nodes: _Rb_tree__Base_ptr,
            pub _M_t: *mut _Rb_tree,
        }
        impl Default for _Rb_tree__Reuse_or_alloc_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Rb_tree__Alloc_node {
            pub _M_t: *mut _Rb_tree,
        }
        impl Default for _Rb_tree__Alloc_node {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> = *mut _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> = *const _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> = *mut _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> = *const _Rb_tree_value_type<_Val>;
        pub type _Rb_tree_size_type = usize;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator = reverse_iterator<_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator = reverse_iterator<_Rb_tree_const_iterator>;
        pub type _Rb_tree_node_type = _Node_handle;
        pub type _Rb_tree_insert_return_type = _Node_insert_return<_Iterator, _NodeHandle>;
        pub type _Rb_tree__Compatible_tree = _Rb_tree;
        pub type _Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
            _Rb_tree_key_compare<_Key_compare>;
        #[repr(C)]
        pub struct map {
            pub _M_t: map__Rep_type,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> = pair<_Key, _Tp>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct map_value_compare<_Compare> {
            pub comp: _Compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
        }
        impl<_Compare> Default for map_value_compare<_Compare> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type map__Pair_alloc_type = [u8; 0usize];
        pub type map__Rep_type = _Rb_tree;
        pub type map__Alloc_traits = __alloc_traits;
        pub type map_pointer = [u8; 0usize];
        pub type map_const_pointer = [u8; 0usize];
        pub type map_reference = [u8; 0usize];
        pub type map_const_reference = [u8; 0usize];
        pub type map_iterator = [u8; 0usize];
        pub type map_const_iterator = [u8; 0usize];
        pub type map_size_type = [u8; 0usize];
        pub type map_difference_type = [u8; 0usize];
        pub type map_reverse_iterator = [u8; 0usize];
        pub type map_const_reverse_iterator = [u8; 0usize];
        pub type map_node_type = [u8; 0usize];
        pub type map_insert_return_type = [u8; 0usize];
        impl Default for map {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for map {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "map {{ _M_t: {:?} }}", self._M_t)
            }
        }
        impl ::std::cmp::PartialEq for map {
            fn eq(&self, other: &map) -> bool {
                self._M_t == other._M_t
            }
        }
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: _Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: _Vector_base_pointer,
            pub _M_finish: _Vector_base_pointer,
            pub _M_end_of_storage: _Vector_base_pointer,
        }
        impl Default for _Vector_base__Vector_impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Vector_base__Vector_impl {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base__Vector_impl {{  }}")
            }
        }
        impl ::std::cmp::PartialEq for _Vector_base__Vector_impl {
            fn eq(&self, other: &_Vector_base__Vector_impl) -> bool {
                self._M_start == other._M_start
                    && self._M_finish == other._M_finish
                    && self._M_end_of_storage == other._M_end_of_storage
            }
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        impl Default for _Vector_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Vector_base {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        impl ::std::cmp::PartialEq for _Vector_base {
            fn eq(&self, other: &_Vector_base) -> bool {
                self._M_impl == other._M_impl
            }
        }
        #[repr(C)]
        pub struct vector {
            pub _base: _Vector_base,
        }
        pub type vector__Base = _Vector_base;
        pub type vector__Tp_alloc_type = vector__Base;
        pub type vector__Alloc_traits = __alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = vector__Base;
        pub type vector_const_pointer = vector__Alloc_traits;
        pub type vector_reference = vector__Alloc_traits;
        pub type vector_const_reference = vector__Alloc_traits;
        pub type vector_iterator = __normal_iterator<vector_pointer>;
        pub type vector_const_iterator = __normal_iterator<vector_const_pointer>;
        pub type vector_const_reverse_iterator = reverse_iterator<vector_const_iterator>;
        pub type vector_reverse_iterator = reverse_iterator<vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut vector,
            pub __buf: u8,
        }
        impl Default for vector__Temporary_value {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Default for vector {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for vector {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "vector {{  }}")
            }
        }
        impl ::std::cmp::PartialEq for vector {
            fn eq(&self, other: &vector) -> bool {
                self._base == other._base
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Deque_iterator {
            pub _M_cur: _Deque_iterator__Elt_pointer,
            pub _M_first: _Deque_iterator__Elt_pointer,
            pub _M_last: _Deque_iterator__Elt_pointer,
            pub _M_node: _Deque_iterator__Map_pointer,
        }
        pub type _Deque_iterator___ptr_to = pointer_traits;
        pub type _Deque_iterator___iter = _Deque_iterator;
        pub type _Deque_iterator_iterator = _Deque_iterator___iter;
        pub type _Deque_iterator_const_iterator = _Deque_iterator___iter;
        pub type _Deque_iterator__Elt_pointer = _Deque_iterator___ptr_to;
        pub type _Deque_iterator__Map_pointer = _Deque_iterator___ptr_to;
        pub type _Deque_iterator_iterator_category = random_access_iterator_tag;
        pub type _Deque_iterator_value_type<_Tp> = _Tp;
        pub type _Deque_iterator_pointer<_Ptr> = _Ptr;
        pub type _Deque_iterator_reference<_Ref> = _Ref;
        pub type _Deque_iterator_size_type = usize;
        pub type _Deque_iterator_difference_type = isize;
        pub type _Deque_iterator__Self = _Deque_iterator;
        impl Default for _Deque_iterator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct _Deque_base {
            pub _M_impl: _Deque_base__Deque_impl,
        }
        pub type _Deque_base__Tp_alloc_type = [u8; 0usize];
        pub type _Deque_base__Alloc_traits = __alloc_traits;
        pub type _Deque_base__Ptr = [u8; 0usize];
        pub type _Deque_base__Ptr_const = [u8; 0usize];
        pub type _Deque_base__Map_alloc_type = [u8; 0usize];
        pub type _Deque_base__Map_alloc_traits = __alloc_traits;
        pub type _Deque_base_allocator_type<_Alloc> = _Alloc;
        pub type _Deque_base_size_type = [u8; 0usize];
        pub type _Deque_base_iterator = _Deque_iterator;
        pub type _Deque_base_const_iterator = _Deque_iterator;
        pub type _Deque_base__Map_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Deque_base__Deque_impl {
            pub _M_map: _Deque_base__Map_pointer,
            pub _M_map_size: usize,
            pub _M_start: _Deque_base_iterator,
            pub _M_finish: _Deque_base_iterator,
        }
        impl Default for _Deque_base__Deque_impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Deque_base__Deque_impl {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! ( f , "_Deque_base__Deque_impl {{ _M_map_size: {:?}, _M_start: {:?}, _M_finish: {:?} }}" , self . _M_map_size , self . _M_start , self . _M_finish )
            }
        }
        impl ::std::cmp::PartialEq for _Deque_base__Deque_impl {
            fn eq(&self, other: &_Deque_base__Deque_impl) -> bool {
                self._M_map == other._M_map
                    && self._M_map_size == other._M_map_size
                    && self._M_start == other._M_start
                    && self._M_finish == other._M_finish
            }
        }
        pub const _Deque_base__S_initial_map_size: _Deque_base__bindgen_ty_1 =
            _Deque_base__bindgen_ty_1::_S_initial_map_size;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Deque_base__bindgen_ty_1 {
            _S_initial_map_size = 0,
        }
        impl Default for _Deque_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for _Deque_base {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Deque_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        impl ::std::cmp::PartialEq for _Deque_base {
            fn eq(&self, other: &_Deque_base) -> bool {
                self._M_impl == other._M_impl
            }
        }
        #[repr(C)]
        pub struct deque {
            pub _base: _Deque_base,
        }
        pub type deque__Base = _Deque_base;
        pub type deque__Tp_alloc_type = deque__Base;
        pub type deque__Alloc_traits = deque__Base;
        pub type deque__Map_pointer = deque__Base;
        pub type deque_value_type<_Tp> = _Tp;
        pub type deque_pointer = deque__Alloc_traits;
        pub type deque_const_pointer = deque__Alloc_traits;
        pub type deque_reference = deque__Alloc_traits;
        pub type deque_const_reference = deque__Alloc_traits;
        pub type deque_iterator = deque__Base;
        pub type deque_const_iterator = deque__Base;
        pub type deque_const_reverse_iterator = reverse_iterator<deque_const_iterator>;
        pub type deque_reverse_iterator = reverse_iterator<deque_iterator>;
        pub type deque_size_type = usize;
        pub type deque_difference_type = isize;
        pub type deque_allocator_type<_Alloc> = _Alloc;
        impl Default for deque {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for deque {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "deque {{  }}")
            }
        }
        impl ::std::cmp::PartialEq for deque {
            fn eq(&self, other: &deque) -> bool {
                self._base == other._base
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct queue<_Sequence> {
            pub c: _Sequence,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sequence>>,
        }
        pub type queue__Uses = u8;
        pub type queue_value_type = [u8; 0usize];
        pub type queue_reference = [u8; 0usize];
        pub type queue_const_reference = [u8; 0usize];
        pub type queue_size_type = [u8; 0usize];
        pub type queue_container_type<_Sequence> = _Sequence;
        impl<_Sequence> Default for queue<_Sequence> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
    }
    pub mod __gnu_cxx {

        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category = __normal_iterator___traits_type;
        pub type __normal_iterator_value_type = __normal_iterator___traits_type;
        pub type __normal_iterator_difference_type = __normal_iterator___traits_type;
        pub type __normal_iterator_reference = __normal_iterator___traits_type;
        pub type __normal_iterator_pointer = __normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = allocator_traits;
        pub type __alloc_traits_value_type = __alloc_traits__Base_type;
        pub type __alloc_traits_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_size_type = __alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = __alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut __alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const __alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = __and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = __alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __aligned_membuf {
            pub _M_storage: *mut ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __aligned_membuf__Tp2<_Tp> {
            pub _M_t: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        impl<_Tp> Default for __aligned_membuf__Tp2<_Tp> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl Default for __aligned_membuf {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = streampos;
        pub type _Char_types_off_type = streamoff;
        pub type _Char_types_state_type = mbstate_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = _Char_types;
        pub type char_traits_pos_type = _Char_types;
        pub type char_traits_off_type = _Char_types;
        pub type char_traits_state_type = _Char_types;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[test]
    fn bindgen_test_layout___pthread_internal_list() {
        assert_eq!(
            ::std::mem::size_of::<__pthread_internal_list>(),
            16usize,
            concat!("Size of: ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            ::std::mem::align_of::<__pthread_internal_list>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    impl Default for __pthread_internal_list {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type __pthread_list_t = __pthread_internal_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __pthread_mutex_s {
        pub __lock: ::std::os::raw::c_int,
        pub __count: ::std::os::raw::c_uint,
        pub __owner: ::std::os::raw::c_int,
        pub __nusers: ::std::os::raw::c_uint,
        pub __kind: ::std::os::raw::c_int,
        pub __spins: ::std::os::raw::c_short,
        pub __elision: ::std::os::raw::c_short,
        pub __list: __pthread_list_t,
    }
    #[test]
    fn bindgen_test_layout___pthread_mutex_s() {
        assert_eq!(
            ::std::mem::size_of::<__pthread_mutex_s>(),
            40usize,
            concat!("Size of: ", stringify!(__pthread_mutex_s))
        );
        assert_eq!(
            ::std::mem::align_of::<__pthread_mutex_s>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_mutex_s))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    impl Default for __pthread_mutex_s {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type pthread_t = ::std::os::raw::c_ulong;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [::std::os::raw::c_char; 40usize],
        pub __align: ::std::os::raw::c_long,
        _bindgen_union_align: [u64; 5usize],
    }
    #[test]
    fn bindgen_test_layout_pthread_mutex_t() {
        assert_eq!(
            ::std::mem::size_of::<pthread_mutex_t>(),
            40usize,
            concat!("Size of: ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            ::std::mem::align_of::<pthread_mutex_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    impl Default for pthread_mutex_t {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for pthread_mutex_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "pthread_mutex_t {{ union }}")
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: __mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    impl Default for __mbstate_t__bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    impl Default for __mbstate_t {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
                self.__count, self.__value
            )
        }
    }
    pub type THREAD_HANDLE = pthread_t;
    pub type THREAD_FUNCTION = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >;
    pub type MUTEX = pthread_mutex_t;
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct XThread {
        pub thread: THREAD_HANDLE,
    }
    #[test]
    fn bindgen_test_layout_XThread() {
        assert_eq!(
            ::std::mem::size_of::<XThread>(),
            8usize,
            concat!("Size of: ", stringify!(XThread))
        );
        assert_eq!(
            ::std::mem::align_of::<XThread>(),
            8usize,
            concat!("Alignment of ", stringify!(XThread))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XThread>())).thread as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XThread),
                "::",
                stringify!(thread)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}start"]
        pub fn XThread_start(
            this: *mut XThread,
            routine: THREAD_FUNCTION,
            ptr: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}wait"]
        pub fn XThread_wait(
            this: *mut XThread,
            milliseconds: ::std::os::raw::c_long,
            cancel: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}test"]
        pub fn XThread_test();
    }
    extern "C" {
        #[link_name = "\u{1}clear"]
        pub fn XThread_clear(this: *mut XThread);
    }
    extern "C" {
        #[link_name = "\u{1}XThread"]
        pub fn XThread_XThread(this: *mut XThread);
    }
    extern "C" {
        #[link_name = "\u{1}XThread_destructor"]
        pub fn XThread_XThread_destructor(this: *mut XThread);
    }
    impl XThread {
        #[inline]
        pub unsafe fn start(
            &mut self,
            routine: THREAD_FUNCTION,
            ptr: *mut ::std::os::raw::c_void,
        ) -> bool {
            XThread_start(self, routine, ptr)
        }
        #[inline]
        pub unsafe fn wait(&mut self, milliseconds: ::std::os::raw::c_long, cancel: bool) -> bool {
            XThread_wait(self, milliseconds, cancel)
        }
        #[inline]
        pub unsafe fn test() {
            XThread_test()
        }
        #[inline]
        pub unsafe fn clear(&mut self) {
            XThread_clear(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XThread_XThread(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            XThread_XThread_destructor(self)
        }
    }
    #[repr(C)]
    pub struct XMutex {
        pub mutex: MUTEX,
    }
    #[test]
    fn bindgen_test_layout_XMutex() {
        assert_eq!(
            ::std::mem::size_of::<XMutex>(),
            40usize,
            concat!("Size of: ", stringify!(XMutex))
        );
        assert_eq!(
            ::std::mem::align_of::<XMutex>(),
            8usize,
            concat!("Alignment of ", stringify!(XMutex))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<XMutex>())).mutex as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(XMutex),
                "::",
                stringify!(mutex)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}acquire"]
        pub fn XMutex_acquire(this: *mut XMutex);
    }
    extern "C" {
        #[link_name = "\u{1}release"]
        pub fn XMutex_release(this: *mut XMutex);
    }
    extern "C" {
        #[link_name = "\u{1}XMutex"]
        pub fn XMutex_XMutex(this: *mut XMutex);
    }
    extern "C" {
        #[link_name = "\u{1}XMutex_destructor"]
        pub fn XMutex_XMutex_destructor(this: *mut XMutex);
    }
    impl Default for XMutex {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for XMutex {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "XMutex {{ mutex: {:?} }}", self.mutex)
        }
    }
    impl XMutex {
        #[inline]
        pub unsafe fn acquire(&mut self) {
            XMutex_acquire(self)
        }
        #[inline]
        pub unsafe fn release(&mut self) {
            XMutex_release(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            XMutex_XMutex(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            XMutex_XMutex_destructor(self)
        }
    }
    pub type mbstate_t = __mbstate_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_VM {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_Type {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_Func {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Chuck_VM_Shred {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct Chuck_VM_Object__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_VM_Object {
        pub vtable_: *const Chuck_VM_Object__bindgen_vtable,
        pub m_ref_count: ::std::os::raw::c_ulong,
        pub m_pooled: ::std::os::raw::c_ulong,
        pub m_locked: ::std::os::raw::c_ulong,
        pub m_v_ref: *mut vector,
    }
    extern "C" {
        #[link_name = "\u{1}our_locks_in_effect"]
        pub static mut Chuck_VM_Object_our_locks_in_effect: ::std::os::raw::c_ulong;
    }
    #[test]
    fn bindgen_test_layout_Chuck_VM_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_VM_Object>(),
            40usize,
            concat!("Size of: ", stringify!(Chuck_VM_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_VM_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_VM_Object))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_ref_count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_ref_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_pooled as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_pooled)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_locked as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_locked)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VM_Object>())).m_v_ref as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VM_Object),
                "::",
                stringify!(m_v_ref)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}lock_all"]
        pub fn Chuck_VM_Object_lock_all();
    }
    extern "C" {
        #[link_name = "\u{1}unlock_all"]
        pub fn Chuck_VM_Object_unlock_all();
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_VM_Object"]
        pub fn Chuck_VM_Object_Chuck_VM_Object(this: *mut Chuck_VM_Object);
    }
    impl Default for Chuck_VM_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_VM_Object {
        #[inline]
        pub unsafe fn lock_all() {
            Chuck_VM_Object_lock_all()
        }
        #[inline]
        pub unsafe fn unlock_all() {
            Chuck_VM_Object_unlock_all()
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_VM_Object_Chuck_VM_Object(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_VM_Object_destructor"]
        pub fn Chuck_VM_Object_Chuck_VM_Object_destructor(this: *mut Chuck_VM_Object);
    }
    extern "C" {
        #[link_name = "\u{1}add_ref"]
        pub fn Chuck_VM_Object_add_ref(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}release"]
        pub fn Chuck_VM_Object_release(this: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}lock"]
        pub fn Chuck_VM_Object_lock(this: *mut ::std::os::raw::c_void);
    }
    #[repr(C)]
    pub struct Chuck_VTable {
        pub funcs: vector,
    }
    #[test]
    fn bindgen_test_layout_Chuck_VTable() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_VTable>(),
            24usize,
            concat!("Size of: ", stringify!(Chuck_VTable))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_VTable>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_VTable))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_VTable>())).funcs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_VTable),
                "::",
                stringify!(funcs)
            )
        );
    }
    impl Default for Chuck_VTable {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_VTable {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "Chuck_VTable {{ funcs: {:?} }}", self.funcs)
        }
    }
    impl ::std::cmp::PartialEq for Chuck_VTable {
        fn eq(&self, other: &Chuck_VTable) -> bool {
            self.funcs == other.funcs
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct Chuck_Object {
        pub _base: Chuck_VM_Object,
        pub vtable: *mut Chuck_VTable,
        pub type_ref: *mut Chuck_Type,
        pub size: ::std::os::raw::c_ulong,
        pub data: *mut ::std::os::raw::c_uchar,
    }
    #[test]
    fn bindgen_test_layout_Chuck_Object() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Object>(),
            72usize,
            concat!("Size of: ", stringify!(Chuck_Object))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Object>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Object))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).vtable as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(vtable)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).type_ref as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(type_ref)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).size as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Object>())).data as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Object),
                "::",
                stringify!(data)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Object"]
        pub fn Chuck_Object_Chuck_Object(this: *mut Chuck_Object);
    }
    impl Default for Chuck_Object {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl Chuck_Object {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            Chuck_Object_Chuck_Object(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}Chuck_Object_destructor"]
        pub fn Chuck_Object_Chuck_Object_destructor(this: *mut Chuck_Object);
    }
    #[repr(C)]
    pub struct Chuck_Event {
        pub _base: Chuck_Object,
        pub m_queue: queue<deque>,
        pub m_queue_lock: XMutex,
    }
    extern "C" {
        #[link_name = "\u{1}our_can_wait"]
        pub static mut Chuck_Event_our_can_wait: ::std::os::raw::c_ulong;
    }
    #[test]
    fn bindgen_test_layout_Chuck_Event() {
        assert_eq!(
            ::std::mem::size_of::<Chuck_Event>(),
            192usize,
            concat!("Size of: ", stringify!(Chuck_Event))
        );
        assert_eq!(
            ::std::mem::align_of::<Chuck_Event>(),
            8usize,
            concat!("Alignment of ", stringify!(Chuck_Event))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Event>())).m_queue as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Event),
                "::",
                stringify!(m_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Chuck_Event>())).m_queue_lock as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(Chuck_Event),
                "::",
                stringify!(m_queue_lock)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}signal"]
        pub fn Chuck_Event_signal(this: *mut Chuck_Event);
    }
    extern "C" {
        #[link_name = "\u{1}broadcast"]
        pub fn Chuck_Event_broadcast(this: *mut Chuck_Event);
    }
    extern "C" {
        #[link_name = "\u{1}wait"]
        pub fn Chuck_Event_wait(
            this: *mut Chuck_Event,
            shred: *mut Chuck_VM_Shred,
            vm: *mut Chuck_VM,
        );
    }
    extern "C" {
        #[link_name = "\u{1}remove"]
        pub fn Chuck_Event_remove(
            this: *mut Chuck_Event,
            shred: *mut Chuck_VM_Shred,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}queue_broadcast"]
        pub fn Chuck_Event_queue_broadcast(
            this: *mut Chuck_Event,
            event_buffer: *mut CBufferSimple,
        );
    }
    impl Default for Chuck_Event {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for Chuck_Event {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "Chuck_Event {{ m_queue: {:?}, m_queue_lock: {:?} }}",
                self.m_queue, self.m_queue_lock
            )
        }
    }
    impl Chuck_Event {
        #[inline]
        pub unsafe fn signal(&mut self) {
            Chuck_Event_signal(self)
        }
        #[inline]
        pub unsafe fn broadcast(&mut self) {
            Chuck_Event_broadcast(self)
        }
        #[inline]
        pub unsafe fn wait(&mut self, shred: *mut Chuck_VM_Shred, vm: *mut Chuck_VM) {
            Chuck_Event_wait(self, shred, vm)
        }
        #[inline]
        pub unsafe fn remove(&mut self, shred: *mut Chuck_VM_Shred) -> ::std::os::raw::c_ulong {
            Chuck_Event_remove(self, shred)
        }
        #[inline]
        pub unsafe fn queue_broadcast(&mut self, event_buffer: *mut CBufferSimple) {
            Chuck_Event_queue_broadcast(self, event_buffer)
        }
    }
    #[repr(C)]
    pub struct CBufferAdvance {
        pub m_data: *mut ::std::os::raw::c_uchar,
        pub m_data_width: ::std::os::raw::c_ulong,
        pub m_read_offsets: vector,
        pub m_free: queue<deque>,
        pub m_write_offset: ::std::os::raw::c_long,
        pub m_max_elem: ::std::os::raw::c_long,
        pub m_mutex: XMutex,
        pub m_event_buffer: *mut CBufferSimple,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct CBufferAdvance_ReadOffset {
        pub read_offset: ::std::os::raw::c_long,
        pub event: *mut Chuck_Event,
    }
    #[test]
    fn bindgen_test_layout_CBufferAdvance_ReadOffset() {
        assert_eq!(
            ::std::mem::size_of::<CBufferAdvance_ReadOffset>(),
            16usize,
            concat!("Size of: ", stringify!(CBufferAdvance_ReadOffset))
        );
        assert_eq!(
            ::std::mem::align_of::<CBufferAdvance_ReadOffset>(),
            8usize,
            concat!("Alignment of ", stringify!(CBufferAdvance_ReadOffset))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<CBufferAdvance_ReadOffset>())).read_offset as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance_ReadOffset),
                "::",
                stringify!(read_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<CBufferAdvance_ReadOffset>())).event as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance_ReadOffset),
                "::",
                stringify!(event)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}ReadOffset"]
        pub fn CBufferAdvance_ReadOffset_ReadOffset(
            this: *mut CBufferAdvance_ReadOffset,
            ro: ::std::os::raw::c_long,
            e: *mut Chuck_Event,
        );
    }
    impl Default for CBufferAdvance_ReadOffset {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl CBufferAdvance_ReadOffset {
        #[inline]
        pub unsafe fn new(ro: ::std::os::raw::c_long, e: *mut Chuck_Event) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            CBufferAdvance_ReadOffset_ReadOffset(&mut __bindgen_tmp, ro, e);
            __bindgen_tmp
        }
    }
    #[test]
    fn bindgen_test_layout_CBufferAdvance() {
        assert_eq!(
            ::std::mem::size_of::<CBufferAdvance>(),
            184usize,
            concat!("Size of: ", stringify!(CBufferAdvance))
        );
        assert_eq!(
            ::std::mem::align_of::<CBufferAdvance>(),
            8usize,
            concat!("Alignment of ", stringify!(CBufferAdvance))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferAdvance>())).m_data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferAdvance>())).m_data_width as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_data_width)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<CBufferAdvance>())).m_read_offsets as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_read_offsets)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferAdvance>())).m_free as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_free)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<CBufferAdvance>())).m_write_offset as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_write_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferAdvance>())).m_max_elem as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_max_elem)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferAdvance>())).m_mutex as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<CBufferAdvance>())).m_event_buffer as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferAdvance),
                "::",
                stringify!(m_event_buffer)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}initialize"]
        pub fn CBufferAdvance_initialize(
            this: *mut CBufferAdvance,
            num_elem: ::std::os::raw::c_ulong,
            width: ::std::os::raw::c_ulong,
            event_buffer: *mut CBufferSimple,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}cleanup"]
        pub fn CBufferAdvance_cleanup(this: *mut CBufferAdvance);
    }
    extern "C" {
        #[link_name = "\u{1}get"]
        pub fn CBufferAdvance_get(
            this: *mut CBufferAdvance,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
            read_offset_index: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}put"]
        pub fn CBufferAdvance_put(
            this: *mut CBufferAdvance,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}empty"]
        pub fn CBufferAdvance_empty(
            this: *mut CBufferAdvance,
            read_offset_index: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}join"]
        pub fn CBufferAdvance_join(
            this: *mut CBufferAdvance,
            event: *mut Chuck_Event,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}resign"]
        pub fn CBufferAdvance_resign(
            this: *mut CBufferAdvance,
            read_offset_index: ::std::os::raw::c_ulong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}CBufferAdvance"]
        pub fn CBufferAdvance_CBufferAdvance(this: *mut CBufferAdvance);
    }
    extern "C" {
        #[link_name = "\u{1}CBufferAdvance_destructor"]
        pub fn CBufferAdvance_CBufferAdvance_destructor(this: *mut CBufferAdvance);
    }
    impl Default for CBufferAdvance {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for CBufferAdvance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "CBufferAdvance {{ m_data: {:?}, m_data_width: {:?}, m_read_offsets: {:?}, m_free: {:?}, m_write_offset: {:?}, m_max_elem: {:?}, m_mutex: {:?}, m_event_buffer: {:?} }}" , self . m_data , self . m_data_width , self . m_read_offsets , self . m_free , self . m_write_offset , self . m_max_elem , self . m_mutex , self . m_event_buffer )
        }
    }
    impl CBufferAdvance {
        #[inline]
        pub unsafe fn initialize(
            &mut self,
            num_elem: ::std::os::raw::c_ulong,
            width: ::std::os::raw::c_ulong,
            event_buffer: *mut CBufferSimple,
        ) -> ::std::os::raw::c_ulong {
            CBufferAdvance_initialize(self, num_elem, width, event_buffer)
        }
        #[inline]
        pub unsafe fn cleanup(&mut self) {
            CBufferAdvance_cleanup(self)
        }
        #[inline]
        pub unsafe fn get(
            &mut self,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
            read_offset_index: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong {
            CBufferAdvance_get(self, data, num_elem, read_offset_index)
        }
        #[inline]
        pub unsafe fn put(
            &mut self,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
        ) {
            CBufferAdvance_put(self, data, num_elem)
        }
        #[inline]
        pub unsafe fn empty(
            &mut self,
            read_offset_index: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong {
            CBufferAdvance_empty(self, read_offset_index)
        }
        #[inline]
        pub unsafe fn join(&mut self, event: *mut Chuck_Event) -> ::std::os::raw::c_ulong {
            CBufferAdvance_join(self, event)
        }
        #[inline]
        pub unsafe fn resign(&mut self, read_offset_index: ::std::os::raw::c_ulong) {
            CBufferAdvance_resign(self, read_offset_index)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            CBufferAdvance_CBufferAdvance(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            CBufferAdvance_CBufferAdvance_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct CBufferSimple {
        pub m_data: *mut ::std::os::raw::c_uchar,
        pub m_data_width: ::std::os::raw::c_ulong,
        pub m_read_offset: ::std::os::raw::c_ulong,
        pub m_write_offset: ::std::os::raw::c_ulong,
        pub m_max_elem: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_CBufferSimple() {
        assert_eq!(
            ::std::mem::size_of::<CBufferSimple>(),
            40usize,
            concat!("Size of: ", stringify!(CBufferSimple))
        );
        assert_eq!(
            ::std::mem::align_of::<CBufferSimple>(),
            8usize,
            concat!("Alignment of ", stringify!(CBufferSimple))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferSimple>())).m_data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferSimple),
                "::",
                stringify!(m_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferSimple>())).m_data_width as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferSimple),
                "::",
                stringify!(m_data_width)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferSimple>())).m_read_offset as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferSimple),
                "::",
                stringify!(m_read_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<CBufferSimple>())).m_write_offset as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferSimple),
                "::",
                stringify!(m_write_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<CBufferSimple>())).m_max_elem as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CBufferSimple),
                "::",
                stringify!(m_max_elem)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}initialize"]
        pub fn CBufferSimple_initialize(
            this: *mut CBufferSimple,
            num_elem: ::std::os::raw::c_ulong,
            width: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}cleanup"]
        pub fn CBufferSimple_cleanup(this: *mut CBufferSimple);
    }
    extern "C" {
        #[link_name = "\u{1}get"]
        pub fn CBufferSimple_get(
            this: *mut CBufferSimple,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}put"]
        pub fn CBufferSimple_put(
            this: *mut CBufferSimple,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
        );
    }
    extern "C" {
        #[link_name = "\u{1}CBufferSimple"]
        pub fn CBufferSimple_CBufferSimple(this: *mut CBufferSimple);
    }
    extern "C" {
        #[link_name = "\u{1}CBufferSimple_destructor"]
        pub fn CBufferSimple_CBufferSimple_destructor(this: *mut CBufferSimple);
    }
    impl Default for CBufferSimple {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl CBufferSimple {
        #[inline]
        pub unsafe fn initialize(
            &mut self,
            num_elem: ::std::os::raw::c_ulong,
            width: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong {
            CBufferSimple_initialize(self, num_elem, width)
        }
        #[inline]
        pub unsafe fn cleanup(&mut self) {
            CBufferSimple_cleanup(self)
        }
        #[inline]
        pub unsafe fn get(
            &mut self,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong {
            CBufferSimple_get(self, data, num_elem)
        }
        #[inline]
        pub unsafe fn put(
            &mut self,
            data: *mut ::std::os::raw::c_void,
            num_elem: ::std::os::raw::c_ulong,
        ) {
            CBufferSimple_put(self, data, num_elem)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            CBufferSimple_CBufferSimple(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            CBufferSimple_CBufferSimple_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
    pub struct HidMsg {
        pub device_type: ::std::os::raw::c_long,
        pub device_num: ::std::os::raw::c_long,
        pub type_: ::std::os::raw::c_long,
        pub eid: ::std::os::raw::c_long,
        pub idata: [::std::os::raw::c_long; 4usize],
        pub fdata: [f64; 4usize],
    }
    #[test]
    fn bindgen_test_layout_HidMsg() {
        assert_eq!(
            ::std::mem::size_of::<HidMsg>(),
            96usize,
            concat!("Size of: ", stringify!(HidMsg))
        );
        assert_eq!(
            ::std::mem::align_of::<HidMsg>(),
            8usize,
            concat!("Alignment of ", stringify!(HidMsg))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidMsg>())).device_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HidMsg),
                "::",
                stringify!(device_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidMsg>())).device_num as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(HidMsg),
                "::",
                stringify!(device_num)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidMsg>())).type_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(HidMsg),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidMsg>())).eid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(HidMsg),
                "::",
                stringify!(eid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidMsg>())).idata as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(HidMsg),
                "::",
                stringify!(idata)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidMsg>())).fdata as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(HidMsg),
                "::",
                stringify!(fdata)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}clear"]
        pub fn HidMsg_clear(this: *mut HidMsg);
    }
    extern "C" {
        #[link_name = "\u{1}HidMsg"]
        pub fn HidMsg_HidMsg(this: *mut HidMsg);
    }
    impl HidMsg {
        #[inline]
        pub unsafe fn clear(&mut self) {
            HidMsg_clear(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            HidMsg_HidMsg(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Chuck_Hid_Driver {
        pub init: ::std::option::Option<unsafe extern "C" fn()>,
        pub quit: ::std::option::Option<unsafe extern "C" fn()>,
        pub poll: ::std::option::Option<unsafe extern "C" fn()>,
        pub probe: ::std::option::Option<unsafe extern "C" fn()>,
        pub count: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
        pub count_elements: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        pub open: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        >,
        pub open_async: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        >,
        pub close: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        >,
        pub send: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *const HidMsg,
            ) -> ::std::os::raw::c_int,
        >,
        pub read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: *mut HidMsg,
            ) -> ::std::os::raw::c_int,
        >,
        pub name: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        >,
        pub driver_name: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout__Chuck_Hid_Driver() {
        assert_eq!(
            ::std::mem::size_of::<_Chuck_Hid_Driver>(),
            104usize,
            concat!("Size of: ", stringify!(_Chuck_Hid_Driver))
        );
        assert_eq!(
            ::std::mem::align_of::<_Chuck_Hid_Driver>(),
            8usize,
            concat!("Alignment of ", stringify!(_Chuck_Hid_Driver))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).init as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(init)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).quit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(quit)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).poll as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(poll)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).probe as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(probe)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).count as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).count_elements as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(count_elements)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).open as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(open)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).open_async as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(open_async)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).close as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(close)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).send as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(send)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).read as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(read)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).name as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<_Chuck_Hid_Driver>())).driver_name as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_Chuck_Hid_Driver),
                "::",
                stringify!(driver_name)
            )
        );
    }
    impl Default for _Chuck_Hid_Driver {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type Chuck_Hid_Driver = _Chuck_Hid_Driver;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PhyHidDevIn {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PhyHidDevOut {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct HidOut {
        pub phout: *mut PhyHidDevOut,
        pub m_msg: vector,
        pub m_device_num: ::std::os::raw::c_ulong,
        pub m_valid: ::std::os::raw::c_ulong,
        pub m_suppress_output: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_HidOut() {
        assert_eq!(
            ::std::mem::size_of::<HidOut>(),
            56usize,
            concat!("Size of: ", stringify!(HidOut))
        );
        assert_eq!(
            ::std::mem::align_of::<HidOut>(),
            8usize,
            concat!("Alignment of ", stringify!(HidOut))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidOut>())).phout as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HidOut),
                "::",
                stringify!(phout)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidOut>())).m_msg as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(HidOut),
                "::",
                stringify!(m_msg)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidOut>())).m_device_num as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(HidOut),
                "::",
                stringify!(m_device_num)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidOut>())).m_valid as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(HidOut),
                "::",
                stringify!(m_valid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidOut>())).m_suppress_output as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(HidOut),
                "::",
                stringify!(m_suppress_output)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn HidOut_open(
            this: *mut HidOut,
            device_num: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn HidOut_close(this: *mut HidOut) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}good"]
        pub fn HidOut_good(this: *mut HidOut) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}num"]
        pub fn HidOut_num(this: *mut HidOut) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}set_suppress"]
        pub fn HidOut_set_suppress(this: *mut HidOut, print_or_not: ::std::os::raw::c_ulong);
    }
    extern "C" {
        #[link_name = "\u{1}get_suppress"]
        pub fn HidOut_get_suppress(this: *mut HidOut) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}send"]
        pub fn HidOut_send(this: *mut HidOut, msg: *const HidMsg) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}HidOut"]
        pub fn HidOut_HidOut(this: *mut HidOut);
    }
    extern "C" {
        #[link_name = "\u{1}HidOut_destructor"]
        pub fn HidOut_HidOut_destructor(this: *mut HidOut);
    }
    impl Default for HidOut {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for HidOut {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "HidOut {{ phout: {:?}, m_msg: {:?}, m_device_num: {:?}, m_valid: {:?}, m_suppress_output: {:?} }}" , self . phout , self . m_msg , self . m_device_num , self . m_valid , self . m_suppress_output )
        }
    }
    impl ::std::cmp::PartialEq for HidOut {
        fn eq(&self, other: &HidOut) -> bool {
            self.phout == other.phout
                && self.m_msg == other.m_msg
                && self.m_device_num == other.m_device_num
                && self.m_valid == other.m_valid
                && self.m_suppress_output == other.m_suppress_output
        }
    }
    impl HidOut {
        #[inline]
        pub unsafe fn open(
            &mut self,
            device_num: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong {
            HidOut_open(self, device_num)
        }
        #[inline]
        pub unsafe fn close(&mut self) -> ::std::os::raw::c_ulong {
            HidOut_close(self)
        }
        #[inline]
        pub unsafe fn good(&mut self) -> ::std::os::raw::c_ulong {
            HidOut_good(self)
        }
        #[inline]
        pub unsafe fn num(&mut self) -> ::std::os::raw::c_long {
            HidOut_num(self)
        }
        #[inline]
        pub unsafe fn set_suppress(&mut self, print_or_not: ::std::os::raw::c_ulong) {
            HidOut_set_suppress(self, print_or_not)
        }
        #[inline]
        pub unsafe fn get_suppress(&mut self) -> ::std::os::raw::c_ulong {
            HidOut_get_suppress(self)
        }
        #[inline]
        pub unsafe fn send(&mut self, msg: *const HidMsg) -> ::std::os::raw::c_ulong {
            HidOut_send(self, msg)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            HidOut_HidOut(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            HidOut_HidOut_destructor(self)
        }
    }
    #[repr(C)]
    pub struct HidIn {
        pub _base: Chuck_Event,
        pub phin: *mut PhyHidDevIn,
        pub m_buffer: *mut CBufferAdvance,
        pub m_read_index: ::std::os::raw::c_ulong,
        pub m_valid: ::std::os::raw::c_ulong,
        pub m_device_num: ::std::os::raw::c_long,
        pub SELF: *mut Chuck_Object,
        pub m_suppress_output: ::std::os::raw::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_HidIn() {
        assert_eq!(
            ::std::mem::size_of::<HidIn>(),
            248usize,
            concat!("Size of: ", stringify!(HidIn))
        );
        assert_eq!(
            ::std::mem::align_of::<HidIn>(),
            8usize,
            concat!("Alignment of ", stringify!(HidIn))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).phin as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(phin)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).m_buffer as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(m_buffer)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).m_read_index as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(m_read_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).m_valid as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(m_valid)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).m_device_num as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(m_device_num)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).SELF as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(SELF)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<HidIn>())).m_suppress_output as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(HidIn),
                "::",
                stringify!(m_suppress_output)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn HidIn_open(
            this: *mut HidIn,
            vm: *mut Chuck_VM,
            device_type: ::std::os::raw::c_long,
            device_num: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn HidIn_open1(
            this: *mut HidIn,
            vm: *mut Chuck_VM,
            name: *mut string,
            device_type: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn HidIn_close(this: *mut HidIn) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}read"]
        pub fn HidIn_read(
            this: *mut HidIn,
            type_: ::std::os::raw::c_long,
            num: ::std::os::raw::c_long,
            msg: *mut HidMsg,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}send"]
        pub fn HidIn_send(this: *mut HidIn, msg: *const HidMsg) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}good"]
        pub fn HidIn_good(this: *mut HidIn) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}num"]
        pub fn HidIn_num(this: *mut HidIn) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[link_name = "\u{1}set_suppress"]
        pub fn HidIn_set_suppress(this: *mut HidIn, print_or_not: ::std::os::raw::c_ulong);
    }
    extern "C" {
        #[link_name = "\u{1}get_suppress"]
        pub fn HidIn_get_suppress(this: *mut HidIn) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}empty"]
        pub fn HidIn_empty(this: *mut HidIn) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}recv"]
        pub fn HidIn_recv(this: *mut HidIn, msg: *mut HidMsg) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}name"]
        pub fn HidIn_name(this: *mut HidIn) -> string;
    }
    extern "C" {
        #[link_name = "\u{1}HidIn"]
        pub fn HidIn_HidIn(this: *mut HidIn);
    }
    impl Default for HidIn {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for HidIn {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! ( f , "HidIn {{ phin: {:?}, m_buffer: {:?}, m_read_index: {:?}, m_valid: {:?}, m_device_num: {:?}, SELF: {:?}, m_suppress_output: {:?} }}" , self . phin , self . m_buffer , self . m_read_index , self . m_valid , self . m_device_num , self . SELF , self . m_suppress_output )
        }
    }
    impl HidIn {
        #[inline]
        pub unsafe fn open(
            &mut self,
            vm: *mut Chuck_VM,
            device_type: ::std::os::raw::c_long,
            device_num: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong {
            HidIn_open(self, vm, device_type, device_num)
        }
        #[inline]
        pub unsafe fn open1(
            &mut self,
            vm: *mut Chuck_VM,
            name: *mut string,
            device_type: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong {
            HidIn_open1(self, vm, name, device_type)
        }
        #[inline]
        pub unsafe fn close(&mut self) -> ::std::os::raw::c_ulong {
            HidIn_close(self)
        }
        #[inline]
        pub unsafe fn read(
            &mut self,
            type_: ::std::os::raw::c_long,
            num: ::std::os::raw::c_long,
            msg: *mut HidMsg,
        ) -> ::std::os::raw::c_ulong {
            HidIn_read(self, type_, num, msg)
        }
        #[inline]
        pub unsafe fn send(&mut self, msg: *const HidMsg) -> ::std::os::raw::c_ulong {
            HidIn_send(self, msg)
        }
        #[inline]
        pub unsafe fn good(&mut self) -> ::std::os::raw::c_ulong {
            HidIn_good(self)
        }
        #[inline]
        pub unsafe fn num(&mut self) -> ::std::os::raw::c_long {
            HidIn_num(self)
        }
        #[inline]
        pub unsafe fn set_suppress(&mut self, print_or_not: ::std::os::raw::c_ulong) {
            HidIn_set_suppress(self, print_or_not)
        }
        #[inline]
        pub unsafe fn get_suppress(&mut self) -> ::std::os::raw::c_ulong {
            HidIn_get_suppress(self)
        }
        #[inline]
        pub unsafe fn empty(&mut self) -> ::std::os::raw::c_ulong {
            HidIn_empty(self)
        }
        #[inline]
        pub unsafe fn recv(&mut self, msg: *mut HidMsg) -> ::std::os::raw::c_ulong {
            HidIn_recv(self, msg)
        }
        #[inline]
        pub unsafe fn name(&mut self) -> string {
            HidIn_name(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            HidIn_HidIn(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}HidIn_destructor"]
        pub fn HidIn_HidIn_destructor(this: *mut HidIn);
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct HidInManager {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "\u{1}m_event_buffers"]
        pub static mut HidInManager_m_event_buffers: map;
    }
    extern "C" {
        #[link_name = "\u{1}the_matrix"]
        pub static mut HidInManager_the_matrix: vector;
    }
    extern "C" {
        #[link_name = "\u{1}the_thread"]
        pub static mut HidInManager_the_thread: *mut XThread;
    }
    extern "C" {
        #[link_name = "\u{1}msg_buffer"]
        pub static mut HidInManager_msg_buffer: *mut CBufferSimple;
    }
    extern "C" {
        #[link_name = "\u{1}thread_going"]
        pub static mut HidInManager_thread_going: ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}has_init"]
        pub static mut HidInManager_has_init: ::std::os::raw::c_ulong;
    }
    #[test]
    fn bindgen_test_layout_HidInManager() {
        assert_eq!(
            ::std::mem::size_of::<HidInManager>(),
            1usize,
            concat!("Size of: ", stringify!(HidInManager))
        );
        assert_eq!(
            ::std::mem::align_of::<HidInManager>(),
            1usize,
            concat!("Alignment of ", stringify!(HidInManager))
        );
    }
    extern "C" {
        #[link_name = "\u{1}init"]
        pub fn HidInManager_init();
    }
    extern "C" {
        #[link_name = "\u{1}init_default_drivers"]
        pub fn HidInManager_init_default_drivers();
    }
    extern "C" {
        #[link_name = "\u{1}cleanup"]
        pub fn HidInManager_cleanup();
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn HidInManager_open(
            hin: *mut HidIn,
            vm: *mut Chuck_VM,
            device_type: ::std::os::raw::c_long,
            device_num: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn HidInManager_open1(
            hin: *mut HidIn,
            vm: *mut Chuck_VM,
            device_type: ::std::os::raw::c_long,
            device_name: *mut string,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn HidInManager_close(hin: *mut HidIn) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}cleanup_buffer"]
        pub fn HidInManager_cleanup_buffer(vm: *mut Chuck_VM);
    }
    extern "C" {
        #[link_name = "\u{1}probeHidIn"]
        pub fn HidInManager_probeHidIn();
    }
    extern "C" {
        #[link_name = "\u{1}probeHidOut"]
        pub fn HidInManager_probeHidOut();
    }
    extern "C" {
        #[link_name = "\u{1}cb_hid_input"]
        pub fn HidInManager_cb_hid_input(
            arg1: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}push_message"]
        pub fn HidInManager_push_message(msg: *mut HidMsg);
    }
    impl HidInManager {
        #[inline]
        pub unsafe fn init() {
            HidInManager_init()
        }
        #[inline]
        pub unsafe fn init_default_drivers() {
            HidInManager_init_default_drivers()
        }
        #[inline]
        pub unsafe fn cleanup() {
            HidInManager_cleanup()
        }
        #[inline]
        pub unsafe fn open(
            hin: *mut HidIn,
            vm: *mut Chuck_VM,
            device_type: ::std::os::raw::c_long,
            device_num: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong {
            HidInManager_open(hin, vm, device_type, device_num)
        }
        #[inline]
        pub unsafe fn open1(
            hin: *mut HidIn,
            vm: *mut Chuck_VM,
            device_type: ::std::os::raw::c_long,
            device_name: *mut string,
        ) -> ::std::os::raw::c_ulong {
            HidInManager_open1(hin, vm, device_type, device_name)
        }
        #[inline]
        pub unsafe fn close(hin: *mut HidIn) -> ::std::os::raw::c_ulong {
            HidInManager_close(hin)
        }
        #[inline]
        pub unsafe fn cleanup_buffer(vm: *mut Chuck_VM) {
            HidInManager_cleanup_buffer(vm)
        }
        #[inline]
        pub unsafe fn probeHidIn() {
            HidInManager_probeHidIn()
        }
        #[inline]
        pub unsafe fn probeHidOut() {
            HidInManager_probeHidOut()
        }
        #[inline]
        pub unsafe fn cb_hid_input(
            arg1: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void {
            HidInManager_cb_hid_input(arg1)
        }
        #[inline]
        pub unsafe fn push_message(msg: *mut HidMsg) {
            HidInManager_push_message(msg)
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct HidOutManager {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "\u{1}the_phouts"]
        pub static mut HidOutManager_the_phouts: vector;
    }
    #[test]
    fn bindgen_test_layout_HidOutManager() {
        assert_eq!(
            ::std::mem::size_of::<HidOutManager>(),
            1usize,
            concat!("Size of: ", stringify!(HidOutManager))
        );
        assert_eq!(
            ::std::mem::align_of::<HidOutManager>(),
            1usize,
            concat!("Alignment of ", stringify!(HidOutManager))
        );
    }
    extern "C" {
        #[link_name = "\u{1}open"]
        pub fn HidOutManager_open(
            hout: *mut HidOut,
            device_num: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}close"]
        pub fn HidOutManager_close(hout: *mut HidOut) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        #[link_name = "\u{1}HidOutManager"]
        pub fn HidOutManager_HidOutManager(this: *mut HidOutManager);
    }
    extern "C" {
        #[link_name = "\u{1}HidOutManager_destructor"]
        pub fn HidOutManager_HidOutManager_destructor(this: *mut HidOutManager);
    }
    impl HidOutManager {
        #[inline]
        pub unsafe fn open(
            hout: *mut HidOut,
            device_num: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_ulong {
            HidOutManager_open(hout, device_num)
        }
        #[inline]
        pub unsafe fn close(hout: *mut HidOut) -> ::std::os::raw::c_ulong {
            HidOutManager_close(hout)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            HidOutManager_HidOutManager(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            HidOutManager_HidOutManager_destructor(self)
        }
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Chuck_Func_allocator_open1_ptr_Chuck_Func_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_Func_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_queue_open0_ptr_Chuck_VM_Shred_deque_open1_ptr_Chuck_VM_Shred_allocator_open2_ptr_Chuck_VM_Shred_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<queue<deque>>(),
            80usize,
            concat!(
                "Size of template specialization: ",
                stringify!(queue<deque>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<queue<deque>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(queue<deque>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_deque_open0_ptr_Chuck_VM_Shred_allocator_open1_ptr_Chuck_VM_Shred_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<deque>(),
            80usize,
            concat!("Size of template specialization: ", stringify!(deque))
        );
        assert_eq!(
            ::std::mem::align_of::<deque>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(deque))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Chuck_VM_Shred_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_CBufferAdvance_ReadOffset_allocator_open1_CBufferAdvance_ReadOffset_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_CBufferAdvance_ReadOffset_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_queue_open0_unsigned_long_deque_open1_unsigned_long_allocator_open2_unsigned_long_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<queue<deque>>(),
            80usize,
            concat!(
                "Size of template specialization: ",
                stringify!(queue<deque>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<queue<deque>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(queue<deque>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_deque_open0_unsigned_long_allocator_open1_unsigned_long_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<deque>(),
            80usize,
            concat!("Size of template specialization: ", stringify!(deque))
        );
        assert_eq!(
            ::std::mem::align_of::<deque>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(deque))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_unsigned_long_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_unsigned_char_allocator_open1_unsigned_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<vector>(),
            24usize,
            concat!("Size of template specialization: ", stringify!(vector))
        );
        assert_eq!(
            ::std::mem::align_of::<vector>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(vector))
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
}
