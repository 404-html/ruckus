/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}

    pub mod std {

        pub mod __cxx11 {

            pub type string = basic_string<::std::os::raw::c_char>;
            #[repr(C)]
            pub struct basic_string<_CharT> {
                pub _M_dataplus: basic_string__Alloc_hider,
                pub _M_string_length: basic_string_size_type,
                pub __bindgen_anon_1: basic_string__bindgen_ty_2<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_string__Char_alloc_type = [u8; 0usize];
            pub type basic_string__Alloc_traits = __alloc_traits;
            pub type basic_string_traits_type<_Traits> = _Traits;
            pub type basic_string_value_type = [u8; 0usize];
            pub type basic_string_allocator_type = basic_string__Char_alloc_type;
            pub type basic_string_size_type = [u8; 0usize];
            pub type basic_string_difference_type = [u8; 0usize];
            pub type basic_string_reference = [u8; 0usize];
            pub type basic_string_const_reference = [u8; 0usize];
            pub type basic_string_pointer = [u8; 0usize];
            pub type basic_string_const_pointer = [u8; 0usize];
            pub type basic_string_iterator = __normal_iterator<basic_string_pointer>;
            pub type basic_string_const_iterator = __normal_iterator<basic_string_const_pointer>;
            pub type basic_string_const_reverse_iterator =
                reverse_iterator<basic_string_const_iterator>;
            pub type basic_string_reverse_iterator = reverse_iterator<basic_string_iterator>;
            pub type basic_string___const_iterator = basic_string_const_iterator;
            pub type basic_string___sv_type<_CharT> = basic_string_view<_CharT>;
            pub type basic_string__If_sv = enable_if_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
            pub struct basic_string___sv_wrapper<_CharT> {
                pub _M_sv: basic_string___sv_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string___sv_wrapper<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            #[repr(C)]
            pub struct basic_string__Alloc_hider {
                pub _M_p: basic_string_pointer,
            }
            impl Default for basic_string__Alloc_hider {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl ::std::fmt::Debug for basic_string__Alloc_hider {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__Alloc_hider {{  }}")
                }
            }
            impl ::std::cmp::PartialEq for basic_string__Alloc_hider {
                fn eq(&self, other: &basic_string__Alloc_hider) -> bool {
                    self._M_p == other._M_p
                }
            }
            pub const basic_string__S_local_capacity: basic_string__bindgen_ty_1 =
                basic_string__bindgen_ty_1::_S_local_capacity;
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
            pub enum basic_string__bindgen_ty_1 {
                _S_local_capacity = 0,
            }
            #[repr(C)]
            pub struct basic_string__bindgen_ty_2<_CharT> {
                pub _M_local_buf: crate::core::err::err::root::__BindgenUnionField<*mut _CharT>,
                pub _M_allocated_capacity:
                    crate::core::err::err::root::__BindgenUnionField<basic_string_size_type>,
                pub bindgen_union_field: u64,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_string__bindgen_ty_2<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string__bindgen_ty_2<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "basic_string__bindgen_ty_2 {{ union }}")
                }
            }
            impl<_CharT> Default for basic_string<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_string<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_string {{ _M_dataplus: {:?}, __bindgen_anon_1: {:?} }}",
                        self._M_dataplus, self.__bindgen_anon_1
                    )
                }
            }
            #[repr(C)]
            pub struct basic_stringbuf<_CharT> {
                pub _base: basic_streambuf<_CharT>,
                pub _M_mode: ios_base_openmode,
                pub _M_string: basic_stringbuf___string_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_stringbuf_char_type<_CharT> = _CharT;
            pub type basic_stringbuf_traits_type<_Traits> = _Traits;
            pub type basic_stringbuf_allocator_type<_Alloc> = _Alloc;
            pub type basic_stringbuf_int_type = [u8; 0usize];
            pub type basic_stringbuf_pos_type = [u8; 0usize];
            pub type basic_stringbuf_off_type = [u8; 0usize];
            pub type basic_stringbuf___streambuf_type<_CharT> =
                basic_streambuf<basic_stringbuf_char_type<_CharT>>;
            pub type basic_stringbuf___string_type<_CharT> =
                basic_string<basic_stringbuf_char_type<_CharT>>;
            pub type basic_stringbuf___size_type<_CharT> = basic_stringbuf___string_type<_CharT>;
            #[repr(C)]
            pub struct basic_stringbuf___xfer_bufptrs<_CharT> {
                pub _M_to: *mut basic_stringbuf<_CharT>,
                pub _M_goff: [basic_stringbuf_off_type; 3usize],
                pub _M_poff: [basic_stringbuf_off_type; 3usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            impl<_CharT> Default for basic_stringbuf___xfer_bufptrs<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_stringbuf___xfer_bufptrs<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write ! ( f , "basic_stringbuf___xfer_bufptrs {{ _M_to: {:?}, _M_goff: {:?}, _M_poff: {:?} }}" , self . _M_to , self . _M_goff , self . _M_poff )
                }
            }
            impl<_CharT> Default for basic_stringbuf<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_stringbuf<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_stringbuf {{ _M_mode: {:?}, _M_string: {:?} }}",
                        self._M_mode, self._M_string
                    )
                }
            }
            #[repr(C)]
            pub struct basic_stringstream<_CharT> {
                pub _base: basic_iostream<_CharT>,
                pub _M_stringbuf: basic_stringstream___stringbuf_type<_CharT>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
            }
            pub type basic_stringstream_char_type<_CharT> = _CharT;
            pub type basic_stringstream_traits_type<_Traits> = _Traits;
            pub type basic_stringstream_allocator_type<_Alloc> = _Alloc;
            pub type basic_stringstream_int_type = [u8; 0usize];
            pub type basic_stringstream_pos_type = [u8; 0usize];
            pub type basic_stringstream_off_type = [u8; 0usize];
            pub type basic_stringstream___string_type<_CharT> = basic_string<_CharT>;
            pub type basic_stringstream___stringbuf_type<_CharT> = basic_stringbuf<_CharT>;
            pub type basic_stringstream___iostream_type<_CharT> =
                basic_iostream<basic_stringstream_char_type<_CharT>>;
            impl<_CharT> Default for basic_stringstream<_CharT> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl<_CharT> ::std::fmt::Debug for basic_stringstream<_CharT> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(
                        f,
                        "basic_stringstream {{ _M_stringbuf: {:?} }}",
                        self._M_stringbuf
                    )
                }
            }
        }
        pub type streamoff = ::std::os::raw::c_long;
        pub type streamsize = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct fpos<_StateT> {
            pub _M_off: streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        impl<_StateT> Default for fpos<_StateT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type streampos = fpos<mbstate_t>;
        pub type stringstream = basic_stringstream<::std::os::raw::c_char>;
        #[repr(C)]
        pub struct exception__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct exception {
            pub vtable_: *const exception__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(
                ::std::mem::size_of::<exception>(),
                8usize,
                concat!("Size of: ", stringify!(exception))
            );
            assert_eq!(
                ::std::mem::align_of::<exception>(),
                8usize,
                concat!("Alignment of ", stringify!(exception))
            );
        }
        extern "C" {
            #[link_name = "\u{1}exception"]
            pub fn exception_exception(this: *mut exception);
        }
        impl Default for exception {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl exception {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                exception_exception(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}exception_destructor"]
            pub fn exception_exception_destructor(this: *mut exception);
        }
        extern "C" {
            #[link_name = "\u{1}what"]
            pub fn exception_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = __detector;
        pub type __detected_or_t = __detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_output_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<output_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(output_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<output_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(output_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = __undefined;
        pub type __get_first_arg_t = __get_first_arg;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = __detected_or_t;
        pub type pointer_traits_difference_type = __detected_or_t;
        pub type pointer_traits_rebind = pointer_traits___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = reverse_iterator___traits_type;
        pub type reverse_iterator_reference = reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        impl Default for char_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __c_locale = __locale_t;
        pub type __allocator_base = new_allocator;
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = allocator;
        pub type allocator_propagate_on_container_move_assignment = true_type;
        pub type allocator_is_always_equal = true_type;
        impl Default for allocator {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = __allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = __detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment = __detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = __detected_or_t;
        pub type allocator_traits_is_always_equal = __detected_or_t;
        pub type allocator_traits_rebind_alloc = __alloc_rebind;
        pub type allocator_traits_rebind_traits = allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: usize,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_const_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_iterator<_CharT> = *const _CharT;
        pub type basic_string_view_iterator<_CharT> = basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            reverse_iterator<basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        impl<_CharT> Default for basic_string_view<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        pub mod literals {}
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale {
            pub _M_impl: *mut locale__Impl,
        }
        pub type locale_category = ::std::os::raw::c_int;
        pub const locale__S_categories_size: locale__bindgen_ty_1 =
            locale__bindgen_ty_1::_S_categories_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum locale__bindgen_ty_1 {
            _S_categories_size = 12,
        }
        pub const locale_none: locale_category = 0;
        pub const locale_ctype: locale_category = 1;
        pub const locale_numeric: locale_category = 2;
        pub const locale_collate: locale_category = 4;
        pub const locale_time: locale_category = 8;
        pub const locale_monetary: locale_category = 16;
        pub const locale_messages: locale_category = 32;
        pub const locale_all: locale_category = 63;
        extern "C" {
            #[link_name = "\u{1}_S_classic"]
            pub static mut locale__S_classic: *mut locale__Impl;
        }
        extern "C" {
            #[link_name = "\u{1}_S_global"]
            pub static mut locale__S_global: *mut locale__Impl;
        }
        extern "C" {
            #[link_name = "\u{1}_S_categories"]
            pub static locale__S_categories: *const *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_S_once"]
            pub static mut locale__S_once: __gthread_once_t;
        }
        extern "C" {
            #[link_name = "\u{1}_S_twinned_facets"]
            pub static mut locale__S_twinned_facets: [*const locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale() {
            assert_eq!(
                ::std::mem::size_of::<locale>(),
                8usize,
                concat!("Size of: ", stringify!(locale))
            );
            assert_eq!(
                ::std::mem::align_of::<locale>(),
                8usize,
                concat!("Alignment of ", stringify!(locale))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale>()))._M_impl as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale),
                    "::",
                    stringify!(_M_impl)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}name"]
            pub fn locale_name(this: *const locale) -> string;
        }
        extern "C" {
            #[link_name = "\u{1}global"]
            pub fn locale_global(__loc: *const locale) -> locale;
        }
        extern "C" {
            #[link_name = "\u{1}classic"]
            pub fn locale_classic() -> *const locale;
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale(this: *mut locale);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale1(this: *mut locale, __other: *const locale);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale2(this: *mut locale, __s: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale3(
                this: *mut locale,
                __base: *const locale,
                __s: *const ::std::os::raw::c_char,
                __cat: locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale4(this: *mut locale, __s: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale5(
                this: *mut locale,
                __base: *const locale,
                __s: *const string,
                __cat: locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}locale"]
            pub fn locale_locale6(
                this: *mut locale,
                __base: *const locale,
                __add: *const locale,
                __cat: locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}locale_destructor"]
            pub fn locale_locale_destructor(this: *mut locale);
        }
        impl Default for locale {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl locale {
            #[inline]
            pub unsafe fn name(&self) -> string {
                locale_name(self)
            }
            #[inline]
            pub unsafe fn global(__loc: *const locale) -> locale {
                locale_global(__loc)
            }
            #[inline]
            pub unsafe fn classic() -> *const locale {
                locale_classic()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__other: *const locale) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale1(&mut __bindgen_tmp, __other);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale2(&mut __bindgen_tmp, __s);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                __base: *const locale,
                __s: *const ::std::os::raw::c_char,
                __cat: locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale3(&mut __bindgen_tmp, __base, __s, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(__s: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale4(&mut __bindgen_tmp, __s);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                __base: *const locale,
                __s: *const string,
                __cat: locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale5(&mut __bindgen_tmp, __base, __s, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new6(
                __base: *const locale,
                __add: *const locale,
                __cat: locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_locale6(&mut __bindgen_tmp, __base, __add, __cat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                locale_locale_destructor(self)
            }
        }
        #[repr(C)]
        pub struct locale_facet__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale_facet {
            pub vtable_: *const locale_facet__bindgen_vtable,
            pub _M_refcount: _Atomic_word,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct locale_facet___shim {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_S_c_locale"]
            pub static mut locale_facet__S_c_locale: __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_c_name"]
            pub static mut locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_once"]
            pub static mut locale_facet__S_once: __gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale_facet() {
            assert_eq!(
                ::std::mem::size_of::<locale_facet>(),
                16usize,
                concat!("Size of: ", stringify!(locale_facet))
            );
            assert_eq!(
                ::std::mem::align_of::<locale_facet>(),
                8usize,
                concat!("Alignment of ", stringify!(locale_facet))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale_facet>()))._M_refcount as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale_facet),
                    "::",
                    stringify!(_M_refcount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_create_c_locale"]
            pub fn locale_facet__S_create_c_locale(
                __cloc: *mut __c_locale,
                __s: *const ::std::os::raw::c_char,
                __old: __c_locale,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_S_clone_c_locale"]
            pub fn locale_facet__S_clone_c_locale(__cloc: *mut __c_locale) -> __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_destroy_c_locale"]
            pub fn locale_facet__S_destroy_c_locale(__cloc: *mut __c_locale);
        }
        extern "C" {
            #[link_name = "\u{1}_S_lc_ctype_c_locale"]
            pub fn locale_facet__S_lc_ctype_c_locale(
                __cloc: __c_locale,
                __s: *const ::std::os::raw::c_char,
            ) -> __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_get_c_locale"]
            pub fn locale_facet__S_get_c_locale() -> __c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_S_get_c_name"]
            pub fn locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}facet"]
            pub fn locale_facet_facet(this: *mut locale_facet, __refs: usize);
        }
        extern "C" {
            #[link_name = "\u{1}facet"]
            pub fn locale_facet_facet1(this: *mut locale_facet, arg1: *const locale_facet);
        }
        impl Default for locale_facet {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl locale_facet {
            #[inline]
            pub unsafe fn _S_create_c_locale(
                __cloc: *mut __c_locale,
                __s: *const ::std::os::raw::c_char,
                __old: __c_locale,
            ) {
                locale_facet__S_create_c_locale(__cloc, __s, __old)
            }
            #[inline]
            pub unsafe fn _S_clone_c_locale(__cloc: *mut __c_locale) -> __c_locale {
                locale_facet__S_clone_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_destroy_c_locale(__cloc: *mut __c_locale) {
                locale_facet__S_destroy_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_lc_ctype_c_locale(
                __cloc: __c_locale,
                __s: *const ::std::os::raw::c_char,
            ) -> __c_locale {
                locale_facet__S_lc_ctype_c_locale(__cloc, __s)
            }
            #[inline]
            pub unsafe fn _S_get_c_locale() -> __c_locale {
                locale_facet__S_get_c_locale()
            }
            #[inline]
            pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
                locale_facet__S_get_c_name()
            }
            #[inline]
            pub unsafe fn new(__refs: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_facet_facet(&mut __bindgen_tmp, __refs);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const locale_facet) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_facet_facet1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}facet_destructor"]
            pub fn locale_facet_facet_destructor(this: *mut locale_facet);
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale_id {
            pub _M_index: usize,
        }
        extern "C" {
            #[link_name = "\u{1}_S_refcount"]
            pub static mut locale_id__S_refcount: _Atomic_word;
        }
        #[test]
        fn bindgen_test_layout_locale_id() {
            assert_eq!(
                ::std::mem::size_of::<locale_id>(),
                8usize,
                concat!("Size of: ", stringify!(locale_id))
            );
            assert_eq!(
                ::std::mem::align_of::<locale_id>(),
                8usize,
                concat!("Alignment of ", stringify!(locale_id))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale_id>()))._M_index as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale_id),
                    "::",
                    stringify!(_M_index)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_M_id"]
            pub fn locale_id__M_id(this: *const locale_id) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}id"]
            pub fn locale_id_id(this: *mut locale_id);
        }
        impl locale_id {
            #[inline]
            pub unsafe fn _M_id(&self) -> usize {
                locale_id__M_id(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                locale_id_id(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct locale__Impl {
            pub _M_refcount: _Atomic_word,
            pub _M_facets: *mut *const locale_facet,
            pub _M_facets_size: usize,
            pub _M_caches: *mut *const locale_facet,
            pub _M_names: *mut *mut ::std::os::raw::c_char,
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_ctype"]
            pub static mut locale__Impl__S_id_ctype: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_numeric"]
            pub static mut locale__Impl__S_id_numeric: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_collate"]
            pub static mut locale__Impl__S_id_collate: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_time"]
            pub static mut locale__Impl__S_id_time: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_monetary"]
            pub static mut locale__Impl__S_id_monetary: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_id_messages"]
            pub static mut locale__Impl__S_id_messages: [*const locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_S_facet_categories"]
            pub static mut locale__Impl__S_facet_categories: [*const *const locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale__Impl() {
            assert_eq!(
                ::std::mem::size_of::<locale__Impl>(),
                40usize,
                concat!("Size of: ", stringify!(locale__Impl))
            );
            assert_eq!(
                ::std::mem::align_of::<locale__Impl>(),
                8usize,
                concat!("Alignment of ", stringify!(locale__Impl))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale__Impl>()))._M_refcount as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_refcount)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_facets as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_facets)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale__Impl>()))._M_facets_size as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_facets_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_caches as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_caches)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_names as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_names)
                )
            );
        }
        impl Default for locale__Impl {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct __cow_string {
            pub __bindgen_anon_1: __cow_string__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union __cow_string__bindgen_ty_1 {
            pub _M_p: *const ::std::os::raw::c_char,
            pub _M_bytes: [::std::os::raw::c_char; 8usize],
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout___cow_string__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<__cow_string__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(__cow_string__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<__cow_string__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(__cow_string__bindgen_ty_1))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_p as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__cow_string__bindgen_ty_1),
                    "::",
                    stringify!(_M_p)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_bytes as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__cow_string__bindgen_ty_1),
                    "::",
                    stringify!(_M_bytes)
                )
            );
        }
        impl Default for __cow_string__bindgen_ty_1 {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for __cow_string__bindgen_ty_1 {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "__cow_string__bindgen_ty_1 {{ union }}")
            }
        }
        #[test]
        fn bindgen_test_layout___cow_string() {
            assert_eq!(
                ::std::mem::size_of::<__cow_string>(),
                8usize,
                concat!("Size of: ", stringify!(__cow_string))
            );
            assert_eq!(
                ::std::mem::align_of::<__cow_string>(),
                8usize,
                concat!("Alignment of ", stringify!(__cow_string))
            );
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string(this: *mut __cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string1(this: *mut __cow_string, arg1: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string2(
                this: *mut __cow_string,
                arg1: *const ::std::os::raw::c_char,
                arg2: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string3(this: *mut __cow_string, arg1: *const __cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string"]
            pub fn __cow_string___cow_string4(this: *mut __cow_string, arg1: *mut __cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}__cow_string_destructor"]
            pub fn __cow_string___cow_string_destructor(this: *mut __cow_string);
        }
        impl Default for __cow_string {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for __cow_string {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "__cow_string {{ __bindgen_anon_1: {:?} }}",
                    self.__bindgen_anon_1
                )
            }
        }
        impl __cow_string {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string2(&mut __bindgen_tmp, arg1, arg2);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(arg1: *const __cow_string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string3(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(arg1: *mut __cow_string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                __cow_string___cow_string4(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                __cow_string___cow_string_destructor(self)
            }
        }
        #[repr(C)]
        pub struct runtime_error {
            pub _base: exception,
            pub _M_msg: __cow_string,
        }
        #[test]
        fn bindgen_test_layout_runtime_error() {
            assert_eq!(
                ::std::mem::size_of::<runtime_error>(),
                16usize,
                concat!("Size of: ", stringify!(runtime_error))
            );
            assert_eq!(
                ::std::mem::align_of::<runtime_error>(),
                8usize,
                concat!("Alignment of ", stringify!(runtime_error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<runtime_error>()))._M_msg as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(runtime_error),
                    "::",
                    stringify!(_M_msg)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error"]
            pub fn runtime_error_runtime_error(this: *mut runtime_error, __arg: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error"]
            pub fn runtime_error_runtime_error1(
                this: *mut runtime_error,
                arg1: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error"]
            pub fn runtime_error_runtime_error2(
                this: *mut runtime_error,
                arg1: *const runtime_error,
            );
        }
        impl Default for runtime_error {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for runtime_error {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "runtime_error {{ _M_msg: {:?} }}", self._M_msg)
            }
        }
        impl runtime_error {
            #[inline]
            pub unsafe fn new(__arg: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                runtime_error_runtime_error(&mut __bindgen_tmp, __arg);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                runtime_error_runtime_error1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(arg1: *const runtime_error) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                runtime_error_runtime_error2(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}runtime_error_destructor"]
            pub fn runtime_error_runtime_error_destructor(this: *mut runtime_error);
        }
        extern "C" {
            #[link_name = "\u{1}what"]
            pub fn runtime_error_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        pub mod _V2 {

            #[repr(C)]
            pub struct error_category__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
            pub struct error_category {
                pub vtable_: *const error_category__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_error_category() {
                assert_eq!(
                    ::std::mem::size_of::<error_category>(),
                    8usize,
                    concat!("Size of: ", stringify!(error_category))
                );
                assert_eq!(
                    ::std::mem::align_of::<error_category>(),
                    8usize,
                    concat!("Alignment of ", stringify!(error_category))
                );
            }
            extern "C" {
                #[link_name = "\u{1}error_category"]
                pub fn error_category_error_category(this: *mut error_category);
            }
            extern "C" {
                #[link_name = "\u{1}error_category"]
                pub fn error_category_error_category1(
                    this: *mut error_category,
                    arg1: *const error_category,
                );
            }
            impl Default for error_category {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
            impl error_category {
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    error_category_error_category(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(arg1: *const error_category) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    error_category_error_category1(&mut __bindgen_tmp, arg1);
                    __bindgen_tmp
                }
            }
            extern "C" {
                #[link_name = "\u{1}error_category_destructor"]
                pub fn error_category_error_category_destructor(this: *mut error_category);
            }
            extern "C" {
                #[link_name = "\u{1}default_error_condition"]
                pub fn error_category_default_error_condition(
                    this: *mut ::std::os::raw::c_void,
                    __i: ::std::os::raw::c_int,
                ) -> error_condition;
            }
            extern "C" {
                #[link_name = "\u{1}equivalent"]
                pub fn error_category_equivalent(
                    this: *mut ::std::os::raw::c_void,
                    __i: ::std::os::raw::c_int,
                    __cond: *const error_condition,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}equivalent"]
                pub fn error_category_equivalent1(
                    this: *mut ::std::os::raw::c_void,
                    __code: *const error_code,
                    __i: ::std::os::raw::c_int,
                ) -> bool;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct error_code {
            pub _M_value: ::std::os::raw::c_int,
            pub _M_cat: *const error_category,
        }
        #[test]
        fn bindgen_test_layout_error_code() {
            assert_eq!(
                ::std::mem::size_of::<error_code>(),
                16usize,
                concat!("Size of: ", stringify!(error_code))
            );
            assert_eq!(
                ::std::mem::align_of::<error_code>(),
                8usize,
                concat!("Alignment of ", stringify!(error_code))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_code>()))._M_value as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_code),
                    "::",
                    stringify!(_M_value)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_code>()))._M_cat as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_code),
                    "::",
                    stringify!(_M_cat)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}assign"]
            pub fn error_code_assign(
                this: *mut error_code,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}clear"]
            pub fn error_code_clear(this: *mut error_code);
        }
        extern "C" {
            #[link_name = "\u{1}value"]
            pub fn error_code_value(this: *const error_code) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}category"]
            pub fn error_code_category(this: *const error_code) -> *const error_category;
        }
        extern "C" {
            #[link_name = "\u{1}default_error_condition"]
            pub fn error_code_default_error_condition(this: *const error_code) -> error_condition;
        }
        extern "C" {
            #[link_name = "\u{1}message"]
            pub fn error_code_message(this: *const error_code) -> string;
        }
        extern "C" {
            #[link_name = "\u{1}error_code"]
            pub fn error_code_error_code(this: *mut error_code);
        }
        extern "C" {
            #[link_name = "\u{1}error_code"]
            pub fn error_code_error_code1(
                this: *mut error_code,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        impl Default for error_code {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl error_code {
            #[inline]
            pub unsafe fn assign(
                &mut self,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            ) {
                error_code_assign(self, __v, __cat)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                error_code_clear(self)
            }
            #[inline]
            pub unsafe fn value(&self) -> ::std::os::raw::c_int {
                error_code_value(self)
            }
            #[inline]
            pub unsafe fn category(&self) -> *const error_category {
                error_code_category(self)
            }
            #[inline]
            pub unsafe fn default_error_condition(&self) -> error_condition {
                error_code_default_error_condition(self)
            }
            #[inline]
            pub unsafe fn message(&self) -> string {
                error_code_message(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_code_error_code(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__v: ::std::os::raw::c_int, __cat: *const error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_code_error_code1(&mut __bindgen_tmp, __v, __cat);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct error_condition {
            pub _M_value: ::std::os::raw::c_int,
            pub _M_cat: *const error_category,
        }
        #[test]
        fn bindgen_test_layout_error_condition() {
            assert_eq!(
                ::std::mem::size_of::<error_condition>(),
                16usize,
                concat!("Size of: ", stringify!(error_condition))
            );
            assert_eq!(
                ::std::mem::align_of::<error_condition>(),
                8usize,
                concat!("Alignment of ", stringify!(error_condition))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<error_condition>()))._M_value as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_condition),
                    "::",
                    stringify!(_M_value)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_condition>()))._M_cat as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_condition),
                    "::",
                    stringify!(_M_cat)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}assign"]
            pub fn error_condition_assign(
                this: *mut error_condition,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}clear"]
            pub fn error_condition_clear(this: *mut error_condition);
        }
        extern "C" {
            #[link_name = "\u{1}value"]
            pub fn error_condition_value(this: *const error_condition) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}category"]
            pub fn error_condition_category(this: *const error_condition) -> *const error_category;
        }
        extern "C" {
            #[link_name = "\u{1}message"]
            pub fn error_condition_message(this: *const error_condition) -> string;
        }
        extern "C" {
            #[link_name = "\u{1}error_condition"]
            pub fn error_condition_error_condition(this: *mut error_condition);
        }
        extern "C" {
            #[link_name = "\u{1}error_condition"]
            pub fn error_condition_error_condition1(
                this: *mut error_condition,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            );
        }
        impl Default for error_condition {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl error_condition {
            #[inline]
            pub unsafe fn assign(
                &mut self,
                __v: ::std::os::raw::c_int,
                __cat: *const error_category,
            ) {
                error_condition_assign(self, __v, __cat)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                error_condition_clear(self)
            }
            #[inline]
            pub unsafe fn value(&self) -> ::std::os::raw::c_int {
                error_condition_value(self)
            }
            #[inline]
            pub unsafe fn category(&self) -> *const error_category {
                error_condition_category(self)
            }
            #[inline]
            pub unsafe fn message(&self) -> string {
                error_condition_message(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_condition_error_condition(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__v: ::std::os::raw::c_int, __cat: *const error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                error_condition_error_condition1(&mut __bindgen_tmp, __v, __cat);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        pub struct system_error {
            pub _base: runtime_error,
            pub _M_code: error_code,
        }
        #[test]
        fn bindgen_test_layout_system_error() {
            assert_eq!(
                ::std::mem::size_of::<system_error>(),
                32usize,
                concat!("Size of: ", stringify!(system_error))
            );
            assert_eq!(
                ::std::mem::align_of::<system_error>(),
                8usize,
                concat!("Alignment of ", stringify!(system_error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<system_error>()))._M_code as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(system_error),
                    "::",
                    stringify!(_M_code)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}code"]
            pub fn system_error_code(this: *const system_error) -> *const error_code;
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error(this: *mut system_error, __ec: error_code);
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error1(
                this: *mut system_error,
                __ec: error_code,
                __what: *const string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error2(
                this: *mut system_error,
                __ec: error_code,
                __what: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error3(
                this: *mut system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error4(
                this: *mut system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}system_error"]
            pub fn system_error_system_error5(
                this: *mut system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const string,
            );
        }
        impl Default for system_error {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for system_error {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "system_error {{ _M_code: {:?} }}", self._M_code)
            }
        }
        impl system_error {
            #[inline]
            pub unsafe fn code(&self) -> *const error_code {
                system_error_code(self)
            }
            #[inline]
            pub unsafe fn new(__ec: error_code) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error(&mut __bindgen_tmp, __ec);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(__ec: error_code, __what: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error1(&mut __bindgen_tmp, __ec, __what);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(__ec: error_code, __what: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error2(&mut __bindgen_tmp, __ec, __what);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error3(&mut __bindgen_tmp, __v, __ecat, __what);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(__v: ::std::os::raw::c_int, __ecat: *const error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error4(&mut __bindgen_tmp, __v, __ecat);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                __v: ::std::os::raw::c_int,
                __ecat: *const error_category,
                __what: *const string,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                system_error_system_error5(&mut __bindgen_tmp, __v, __ecat, __what);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}system_error_destructor"]
            pub fn system_error_system_error_destructor(this: *mut system_error);
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Fmtflags {
            _S_boolalpha = 1,
            _S_dec = 2,
            _S_fixed = 4,
            _S_hex = 8,
            _S_internal = 16,
            _S_left = 32,
            _S_oct = 64,
            _S_right = 128,
            _S_scientific = 256,
            _S_showbase = 512,
            _S_showpoint = 1024,
            _S_showpos = 2048,
            _S_skipws = 4096,
            _S_unitbuf = 8192,
            _S_uppercase = 16384,
            _S_adjustfield = 176,
            _S_basefield = 74,
            _S_floatfield = 260,
            _S_ios_fmtflags_end = 65536,
            _S_ios_fmtflags_max = 2147483647,
            _S_ios_fmtflags_min = -2147483648,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Openmode {
            _S_app = 1,
            _S_ate = 2,
            _S_bin = 4,
            _S_in = 8,
            _S_out = 16,
            _S_trunc = 32,
            _S_ios_openmode_end = 65536,
            _S_ios_openmode_max = 2147483647,
            _S_ios_openmode_min = -2147483648,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Iostate {
            _S_goodbit = 0,
            _S_badbit = 1,
            _S_eofbit = 2,
            _S_failbit = 4,
            _S_ios_iostate_end = 65536,
            _S_ios_iostate_max = 2147483647,
            _S_ios_iostate_min = -2147483648,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum _Ios_Seekdir {
            _S_beg = 0,
            _S_cur = 1,
            _S_end = 2,
            _S_ios_seekdir_end = 65536,
        }
        #[repr(C)]
        pub struct ios_base__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base {
            pub vtable_: *const ios_base__bindgen_vtable,
            pub _M_precision: streamsize,
            pub _M_width: streamsize,
            pub _M_flags: ios_base_fmtflags,
            pub _M_exception: ios_base_iostate,
            pub _M_streambuf_state: ios_base_iostate,
            pub _M_callbacks: *mut ios_base__Callback_list,
            pub _M_word_zero: ios_base__Words,
            pub _M_local_word: [ios_base__Words; 8usize],
            pub _M_word_size: ::std::os::raw::c_int,
            pub _M_word: *mut ios_base__Words,
            pub _M_ios_locale: locale,
        }
        #[repr(C)]
        pub struct ios_base_failure {
            pub _base: system_error,
        }
        #[test]
        fn bindgen_test_layout_ios_base_failure() {
            assert_eq!(
                ::std::mem::size_of::<ios_base_failure>(),
                32usize,
                concat!("Size of: ", stringify!(ios_base_failure))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base_failure>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base_failure))
            );
        }
        extern "C" {
            #[link_name = "\u{1}failure"]
            pub fn ios_base_failure_failure(this: *mut ios_base_failure, __str: *const string);
        }
        extern "C" {
            #[link_name = "\u{1}failure"]
            pub fn ios_base_failure_failure1(
                this: *mut ios_base_failure,
                arg1: *const string,
                arg2: *const error_code,
            );
        }
        extern "C" {
            #[link_name = "\u{1}failure"]
            pub fn ios_base_failure_failure2(
                this: *mut ios_base_failure,
                arg1: *const ::std::os::raw::c_char,
                arg2: *const error_code,
            );
        }
        impl Default for ios_base_failure {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for ios_base_failure {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "ios_base_failure {{  }}")
            }
        }
        impl ios_base_failure {
            #[inline]
            pub unsafe fn new(__str: *const string) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure(&mut __bindgen_tmp, __str);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const string, arg2: *const error_code) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure1(&mut __bindgen_tmp, arg1, arg2);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const error_code,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_failure_failure2(&mut __bindgen_tmp, arg1, arg2);
                __bindgen_tmp
            }
        }
        pub use _Ios_Fmtflags as ios_base_fmtflags;
        pub use _Ios_Iostate as ios_base_iostate;
        pub use _Ios_Openmode as ios_base_openmode;
        pub use _Ios_Seekdir as ios_base_seekdir;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum ios_base_event {
            erase_event = 0,
            imbue_event = 1,
            copyfmt_event = 2,
        }
        pub type ios_base_event_callback = ::std::option::Option<
            unsafe extern "C" fn(
                __e: ios_base_event,
                __b: *mut ios_base,
                __i: ::std::os::raw::c_int,
            ),
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base__Callback_list {
            pub _M_next: *mut ios_base__Callback_list,
            pub _M_fn: ios_base_event_callback,
            pub _M_index: ::std::os::raw::c_int,
            pub _M_refcount: _Atomic_word,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Callback_list() {
            assert_eq!(
                ::std::mem::size_of::<ios_base__Callback_list>(),
                24usize,
                concat!("Size of: ", stringify!(ios_base__Callback_list))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base__Callback_list>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base__Callback_list))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_next as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_next)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_fn as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_fn)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_index as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_index)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_refcount as *const _
                        as usize
                },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_refcount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_M_add_reference"]
            pub fn ios_base__Callback_list__M_add_reference(this: *mut ios_base__Callback_list);
        }
        extern "C" {
            #[link_name = "\u{1}_M_remove_reference"]
            pub fn ios_base__Callback_list__M_remove_reference(
                this: *mut ios_base__Callback_list,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_Callback_list"]
            pub fn ios_base__Callback_list__Callback_list(
                this: *mut ios_base__Callback_list,
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
                __cb: *mut ios_base__Callback_list,
            );
        }
        impl Default for ios_base__Callback_list {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ios_base__Callback_list {
            #[inline]
            pub unsafe fn _M_add_reference(&mut self) {
                ios_base__Callback_list__M_add_reference(self)
            }
            #[inline]
            pub unsafe fn _M_remove_reference(&mut self) -> ::std::os::raw::c_int {
                ios_base__Callback_list__M_remove_reference(self)
            }
            #[inline]
            pub unsafe fn new(
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
                __cb: *mut ios_base__Callback_list,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base__Callback_list__Callback_list(&mut __bindgen_tmp, __fn, __index, __cb);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base__Words {
            pub _M_pword: *mut ::std::os::raw::c_void,
            pub _M_iword: ::std::os::raw::c_long,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Words() {
            assert_eq!(
                ::std::mem::size_of::<ios_base__Words>(),
                16usize,
                concat!("Size of: ", stringify!(ios_base__Words))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base__Words>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base__Words))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Words>()))._M_pword as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Words),
                    "::",
                    stringify!(_M_pword)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Words>()))._M_iword as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Words),
                    "::",
                    stringify!(_M_iword)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_Words"]
            pub fn ios_base__Words__Words(this: *mut ios_base__Words);
        }
        impl Default for ios_base__Words {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ios_base__Words {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base__Words__Words(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        pub const ios_base__S_local_word_size: ios_base__bindgen_ty_1 =
            ios_base__bindgen_ty_1::_S_local_word_size;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
        pub enum ios_base__bindgen_ty_1 {
            _S_local_word_size = 8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ios_base_Init {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}_S_refcount"]
            pub static mut ios_base_Init__S_refcount: _Atomic_word;
        }
        extern "C" {
            #[link_name = "\u{1}_S_synced_with_stdio"]
            pub static mut ios_base_Init__S_synced_with_stdio: bool;
        }
        #[test]
        fn bindgen_test_layout_ios_base_Init() {
            assert_eq!(
                ::std::mem::size_of::<ios_base_Init>(),
                1usize,
                concat!("Size of: ", stringify!(ios_base_Init))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base_Init>(),
                1usize,
                concat!("Alignment of ", stringify!(ios_base_Init))
            );
        }
        extern "C" {
            #[link_name = "\u{1}Init"]
            pub fn ios_base_Init_Init(this: *mut ios_base_Init);
        }
        extern "C" {
            #[link_name = "\u{1}Init_destructor"]
            pub fn ios_base_Init_Init_destructor(this: *mut ios_base_Init);
        }
        impl ios_base_Init {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_Init_Init(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ios_base_Init_Init_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}boolalpha"]
            pub static ios_base_boolalpha: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}dec"]
            pub static ios_base_dec: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}fixed"]
            pub static ios_base_fixed: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}hex"]
            pub static ios_base_hex: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}internal"]
            pub static ios_base_internal: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}left"]
            pub static ios_base_left: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}oct"]
            pub static ios_base_oct: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}right"]
            pub static ios_base_right: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}scientific"]
            pub static ios_base_scientific: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}showbase"]
            pub static ios_base_showbase: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}showpoint"]
            pub static ios_base_showpoint: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}showpos"]
            pub static ios_base_showpos: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}skipws"]
            pub static ios_base_skipws: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}unitbuf"]
            pub static ios_base_unitbuf: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}uppercase"]
            pub static ios_base_uppercase: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}adjustfield"]
            pub static ios_base_adjustfield: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}basefield"]
            pub static ios_base_basefield: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}floatfield"]
            pub static ios_base_floatfield: ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}badbit"]
            pub static ios_base_badbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}eofbit"]
            pub static ios_base_eofbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}failbit"]
            pub static ios_base_failbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}goodbit"]
            pub static ios_base_goodbit: ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}app"]
            pub static ios_base_app: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}ate"]
            pub static ios_base_ate: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}binary"]
            pub static ios_base_binary: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}in"]
            pub static ios_base_in: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}out"]
            pub static ios_base_out: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}trunc"]
            pub static ios_base_trunc: ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}beg"]
            pub static ios_base_beg: ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "\u{1}cur"]
            pub static ios_base_cur: ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "\u{1}end"]
            pub static ios_base_end: ios_base_seekdir;
        }
        #[test]
        fn bindgen_test_layout_ios_base() {
            assert_eq!(
                ::std::mem::size_of::<ios_base>(),
                216usize,
                concat!("Size of: ", stringify!(ios_base))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_precision as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_precision)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_width as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_width)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_flags as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_flags)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_exception as *const _ as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_exception)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base>()))._M_streambuf_state as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_streambuf_state)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_callbacks as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_callbacks)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_zero as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word_zero)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_local_word as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_local_word)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_size as *const _ as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word as *const _ as usize },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_ios_locale as *const _ as usize },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_ios_locale)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}register_callback"]
            pub fn ios_base_register_callback(
                this: *mut ios_base,
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_M_call_callbacks"]
            pub fn ios_base__M_call_callbacks(this: *mut ios_base, __ev: ios_base_event);
        }
        extern "C" {
            #[link_name = "\u{1}_M_dispose_callbacks"]
            pub fn ios_base__M_dispose_callbacks(this: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_M_grow_words"]
            pub fn ios_base__M_grow_words(
                this: *mut ios_base,
                __index: ::std::os::raw::c_int,
                __iword: bool,
            ) -> *mut ios_base__Words;
        }
        extern "C" {
            #[link_name = "\u{1}_M_init"]
            pub fn ios_base__M_init(this: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}flags"]
            pub fn ios_base_flags(this: *const ios_base) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}flags"]
            pub fn ios_base_flags1(
                this: *mut ios_base,
                __fmtfl: ios_base_fmtflags,
            ) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}setf"]
            pub fn ios_base_setf(
                this: *mut ios_base,
                __fmtfl: ios_base_fmtflags,
            ) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}setf"]
            pub fn ios_base_setf1(
                this: *mut ios_base,
                __fmtfl: ios_base_fmtflags,
                __mask: ios_base_fmtflags,
            ) -> ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}unsetf"]
            pub fn ios_base_unsetf(this: *mut ios_base, __mask: ios_base_fmtflags);
        }
        extern "C" {
            #[link_name = "\u{1}precision"]
            pub fn ios_base_precision(this: *const ios_base) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}precision"]
            pub fn ios_base_precision1(this: *mut ios_base, __prec: streamsize) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}width"]
            pub fn ios_base_width(this: *const ios_base) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}width"]
            pub fn ios_base_width1(this: *mut ios_base, __wide: streamsize) -> streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}sync_with_stdio"]
            pub fn ios_base_sync_with_stdio(__sync: bool) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}imbue"]
            pub fn ios_base_imbue(this: *mut ios_base, __loc: *const locale) -> locale;
        }
        extern "C" {
            #[link_name = "\u{1}getloc"]
            pub fn ios_base_getloc(this: *const ios_base) -> locale;
        }
        extern "C" {
            #[link_name = "\u{1}_M_getloc"]
            pub fn ios_base__M_getloc(this: *const ios_base) -> *const locale;
        }
        extern "C" {
            #[link_name = "\u{1}xalloc"]
            pub fn ios_base_xalloc() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}iword"]
            pub fn ios_base_iword(
                this: *mut ios_base,
                __ix: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}pword"]
            pub fn ios_base_pword(
                this: *mut ios_base,
                __ix: ::std::os::raw::c_int,
            ) -> *mut *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_M_move"]
            pub fn ios_base__M_move(this: *mut ios_base, arg1: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_M_swap"]
            pub fn ios_base__M_swap(this: *mut ios_base, __rhs: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}ios_base"]
            pub fn ios_base_ios_base(this: *mut ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}ios_base"]
            pub fn ios_base_ios_base1(this: *mut ios_base, arg1: *const ios_base);
        }
        impl Default for ios_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ios_base {
            #[inline]
            pub unsafe fn register_callback(
                &mut self,
                __fn: ios_base_event_callback,
                __index: ::std::os::raw::c_int,
            ) {
                ios_base_register_callback(self, __fn, __index)
            }
            #[inline]
            pub unsafe fn _M_call_callbacks(&mut self, __ev: ios_base_event) {
                ios_base__M_call_callbacks(self, __ev)
            }
            #[inline]
            pub unsafe fn _M_dispose_callbacks(&mut self) {
                ios_base__M_dispose_callbacks(self)
            }
            #[inline]
            pub unsafe fn _M_grow_words(
                &mut self,
                __index: ::std::os::raw::c_int,
                __iword: bool,
            ) -> *mut ios_base__Words {
                ios_base__M_grow_words(self, __index, __iword)
            }
            #[inline]
            pub unsafe fn _M_init(&mut self) {
                ios_base__M_init(self)
            }
            #[inline]
            pub unsafe fn flags(&self) -> ios_base_fmtflags {
                ios_base_flags(self)
            }
            #[inline]
            pub unsafe fn flags1(&mut self, __fmtfl: ios_base_fmtflags) -> ios_base_fmtflags {
                ios_base_flags1(self, __fmtfl)
            }
            #[inline]
            pub unsafe fn setf(&mut self, __fmtfl: ios_base_fmtflags) -> ios_base_fmtflags {
                ios_base_setf(self, __fmtfl)
            }
            #[inline]
            pub unsafe fn setf1(
                &mut self,
                __fmtfl: ios_base_fmtflags,
                __mask: ios_base_fmtflags,
            ) -> ios_base_fmtflags {
                ios_base_setf1(self, __fmtfl, __mask)
            }
            #[inline]
            pub unsafe fn unsetf(&mut self, __mask: ios_base_fmtflags) {
                ios_base_unsetf(self, __mask)
            }
            #[inline]
            pub unsafe fn precision(&self) -> streamsize {
                ios_base_precision(self)
            }
            #[inline]
            pub unsafe fn precision1(&mut self, __prec: streamsize) -> streamsize {
                ios_base_precision1(self, __prec)
            }
            #[inline]
            pub unsafe fn width(&self) -> streamsize {
                ios_base_width(self)
            }
            #[inline]
            pub unsafe fn width1(&mut self, __wide: streamsize) -> streamsize {
                ios_base_width1(self, __wide)
            }
            #[inline]
            pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
                ios_base_sync_with_stdio(__sync)
            }
            #[inline]
            pub unsafe fn imbue(&mut self, __loc: *const locale) -> locale {
                ios_base_imbue(self, __loc)
            }
            #[inline]
            pub unsafe fn getloc(&self) -> locale {
                ios_base_getloc(self)
            }
            #[inline]
            pub unsafe fn _M_getloc(&self) -> *const locale {
                ios_base__M_getloc(self)
            }
            #[inline]
            pub unsafe fn xalloc() -> ::std::os::raw::c_int {
                ios_base_xalloc()
            }
            #[inline]
            pub unsafe fn iword(
                &mut self,
                __ix: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_long {
                ios_base_iword(self, __ix)
            }
            #[inline]
            pub unsafe fn pword(
                &mut self,
                __ix: ::std::os::raw::c_int,
            ) -> *mut *mut ::std::os::raw::c_void {
                ios_base_pword(self, __ix)
            }
            #[inline]
            pub unsafe fn _M_move(&mut self, arg1: *mut ios_base) {
                ios_base__M_move(self, arg1)
            }
            #[inline]
            pub unsafe fn _M_swap(&mut self, __rhs: *mut ios_base) {
                ios_base__M_swap(self, __rhs)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_ios_base(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const ios_base) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ios_base_ios_base1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}failure_destructor"]
            pub fn ios_base_failure_failure_destructor(this: *mut ios_base_failure);
        }
        extern "C" {
            #[link_name = "\u{1}what"]
            pub fn ios_base_failure_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}ios_base_destructor"]
            pub fn ios_base_ios_base_destructor(this: *mut ios_base);
        }
        #[repr(C)]
        pub struct basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_streambuf<_CharT> {
            pub vtable_: *const basic_streambuf__bindgen_vtable,
            pub _M_in_beg: *mut basic_streambuf_char_type<_CharT>,
            pub _M_in_cur: *mut basic_streambuf_char_type<_CharT>,
            pub _M_in_end: *mut basic_streambuf_char_type<_CharT>,
            pub _M_out_beg: *mut basic_streambuf_char_type<_CharT>,
            pub _M_out_cur: *mut basic_streambuf_char_type<_CharT>,
            pub _M_out_end: *mut basic_streambuf_char_type<_CharT>,
            pub _M_buf_locale: locale,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_streambuf_char_type<_CharT> = _CharT;
        pub type basic_streambuf_traits_type<_Traits> = _Traits;
        pub type basic_streambuf_int_type = [u8; 0usize];
        pub type basic_streambuf_pos_type = [u8; 0usize];
        pub type basic_streambuf_off_type = [u8; 0usize];
        pub type basic_streambuf___streambuf_type<_CharT> =
            basic_streambuf<basic_streambuf_char_type<_CharT>>;
        impl<_CharT> Default for basic_streambuf<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ctype_base {
            pub _address: u8,
        }
        pub type ctype_base___to_type = *const ::std::os::raw::c_int;
        pub type ctype_base_mask = ::std::os::raw::c_ushort;
        pub const ctype_base_upper: ctype_base_mask = 256;
        pub const ctype_base_lower: ctype_base_mask = 512;
        pub const ctype_base_alpha: ctype_base_mask = 1024;
        pub const ctype_base_digit: ctype_base_mask = 2048;
        pub const ctype_base_xdigit: ctype_base_mask = 4096;
        pub const ctype_base_space: ctype_base_mask = 8192;
        pub const ctype_base_print: ctype_base_mask = 16384;
        pub const ctype_base_graph: ctype_base_mask = 3076;
        pub const ctype_base_cntrl: ctype_base_mask = 2;
        pub const ctype_base_punct: ctype_base_mask = 4;
        pub const ctype_base_alnum: ctype_base_mask = 3072;
        pub const ctype_base_blank: ctype_base_mask = 1;
        #[test]
        fn bindgen_test_layout_ctype_base() {
            assert_eq!(
                ::std::mem::size_of::<ctype_base>(),
                1usize,
                concat!("Size of: ", stringify!(ctype_base))
            );
            assert_eq!(
                ::std::mem::align_of::<ctype_base>(),
                1usize,
                concat!("Alignment of ", stringify!(ctype_base))
            );
        }
        #[repr(C)]
        pub struct istreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut istreambuf_iterator_streambuf_type<_CharT>,
            pub _M_c: istreambuf_iterator_int_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type istreambuf_iterator_char_type<_CharT> = _CharT;
        pub type istreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type istreambuf_iterator_int_type = [u8; 0usize];
        pub type istreambuf_iterator_streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type istreambuf_iterator_istream_type<_CharT> = basic_istream<_CharT>;
        impl<_CharT> Default for istreambuf_iterator<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for istreambuf_iterator<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "istreambuf_iterator {{ _M_sbuf: {:?} }}", self._M_sbuf)
            }
        }
        impl<_CharT> ::std::cmp::PartialEq for istreambuf_iterator<_CharT>
        where
            _CharT: PartialEq,
        {
            fn eq(&self, other: &istreambuf_iterator<_CharT>) -> bool {
                self._M_sbuf == other._M_sbuf && self._M_c == other._M_c
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ostreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut ostreambuf_iterator_streambuf_type<_CharT>,
            pub _M_failed: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type ostreambuf_iterator_char_type<_CharT> = _CharT;
        pub type ostreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type ostreambuf_iterator_streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type ostreambuf_iterator_ostream_type<_CharT> = basic_ostream<_CharT>;
        impl<_CharT> Default for ostreambuf_iterator<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __ctype_abstract_base {
            pub _base: locale_facet,
        }
        pub type __ctype_abstract_base_char_type<_CharT> = _CharT;
        impl Default for __ctype_abstract_base {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct ctype {
            pub _base: __ctype_abstract_base,
        }
        pub type ctype_char_type<_CharT> = _CharT;
        pub type ctype_mask = __ctype_abstract_base;
        impl Default for ctype {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct num_get {
            pub _base: locale_facet,
        }
        pub type num_get_char_type<_CharT> = _CharT;
        pub type num_get_iter_type<_InIter> = _InIter;
        impl Default for num_get {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct num_put {
            pub _base: locale_facet,
        }
        pub type num_put_char_type<_CharT> = _CharT;
        pub type num_put_iter_type<_OutIter> = _OutIter;
        impl Default for num_put {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_ios<_CharT> {
            pub _base: ios_base,
            pub _M_tie: *mut basic_ostream<_CharT>,
            pub _M_fill: basic_ios_char_type<_CharT>,
            pub _M_fill_init: bool,
            pub _M_streambuf: *mut basic_streambuf<_CharT>,
            pub _M_ctype: *const basic_ios___ctype_type,
            pub _M_num_put: *const basic_ios___num_put_type,
            pub _M_num_get: *const basic_ios___num_get_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_ios_char_type<_CharT> = _CharT;
        pub type basic_ios_int_type = [u8; 0usize];
        pub type basic_ios_pos_type = [u8; 0usize];
        pub type basic_ios_off_type = [u8; 0usize];
        pub type basic_ios_traits_type<_Traits> = _Traits;
        pub type basic_ios___ctype_type = ctype;
        pub type basic_ios___num_put_type = num_put;
        pub type basic_ios___num_get_type = num_get;
        impl<_CharT> Default for basic_ios<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_ostream<_CharT> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_ostream_char_type<_CharT> = _CharT;
        pub type basic_ostream_int_type = [u8; 0usize];
        pub type basic_ostream_pos_type = [u8; 0usize];
        pub type basic_ostream_off_type = [u8; 0usize];
        pub type basic_ostream_traits_type<_Traits> = _Traits;
        pub type basic_ostream___streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type basic_ostream___ios_type<_CharT> = basic_ios<_CharT>;
        pub type basic_ostream___ostream_type<_CharT> = basic_ostream<_CharT>;
        pub type basic_ostream___num_put_type = num_put;
        pub type basic_ostream___ctype_type = ctype;
        impl<_CharT> Default for basic_ostream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_ostream_sentry {
            pub _M_ok: bool,
            pub _M_os: *mut basic_ostream<_CharT>,
        }
        impl Default for basic_ostream_sentry {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_istream<_CharT> {
            pub _M_gcount: streamsize,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_istream_char_type<_CharT> = _CharT;
        pub type basic_istream_int_type = [u8; 0usize];
        pub type basic_istream_pos_type = [u8; 0usize];
        pub type basic_istream_off_type = [u8; 0usize];
        pub type basic_istream_traits_type<_Traits> = _Traits;
        pub type basic_istream___streambuf_type<_CharT> = basic_streambuf<_CharT>;
        pub type basic_istream___ios_type<_CharT> = basic_ios<_CharT>;
        pub type basic_istream___istream_type<_CharT> = basic_istream<_CharT>;
        pub type basic_istream___num_get_type = num_get;
        pub type basic_istream___ctype_type = ctype;
        impl<_CharT> Default for basic_istream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_istream_sentry {
            pub _M_ok: bool,
        }
        pub type basic_istream_sentry_traits_type = _Traits;
        pub type basic_istream_sentry___streambuf_type = basic_streambuf<_CharT>;
        pub type basic_istream_sentry___istream_type = basic_istream<_CharT>;
        pub type basic_istream_sentry___ctype_type = basic_istream___ctype_type;
        pub type basic_istream_sentry___int_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_iostream<_CharT> {
            pub _base: basic_istream<_CharT>,
            pub _base_1: basic_ostream<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_iostream_char_type<_CharT> = _CharT;
        pub type basic_iostream_int_type = [u8; 0usize];
        pub type basic_iostream_pos_type = [u8; 0usize];
        pub type basic_iostream_off_type = [u8; 0usize];
        pub type basic_iostream_traits_type<_Traits> = _Traits;
        pub type basic_iostream___istream_type<_CharT> = basic_istream<_CharT>;
        pub type basic_iostream___ostream_type<_CharT> = basic_ostream<_CharT>;
        impl<_CharT> Default for basic_iostream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
    }
    pub mod __gnu_cxx {

        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category = __normal_iterator___traits_type;
        pub type __normal_iterator_value_type = __normal_iterator___traits_type;
        pub type __normal_iterator_difference_type = __normal_iterator___traits_type;
        pub type __normal_iterator_reference = __normal_iterator___traits_type;
        pub type __normal_iterator_pointer = __normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = streampos;
        pub type _Char_types_off_type = streamoff;
        pub type _Char_types_state_type = mbstate_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = _Char_types;
        pub type char_traits_pos_type = _Char_types;
        pub type char_traits_off_type = _Char_types;
        pub type char_traits_state_type = _Char_types;
        #[repr(C)]
        #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = allocator_traits;
        pub type __alloc_traits_value_type = __alloc_traits__Base_type;
        pub type __alloc_traits_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = __alloc_traits__Base_type;
        pub type __alloc_traits_size_type = __alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = __alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut __alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const __alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = __and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = __alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __locale_struct {
        pub __locales: [*mut __locale_data; 13usize],
        pub __ctype_b: *const ::std::os::raw::c_ushort,
        pub __ctype_tolower: *const ::std::os::raw::c_int,
        pub __ctype_toupper: *const ::std::os::raw::c_int,
        pub __names: [*const ::std::os::raw::c_char; 13usize],
    }
    #[test]
    fn bindgen_test_layout___locale_struct() {
        assert_eq!(
            ::std::mem::size_of::<__locale_struct>(),
            232usize,
            concat!("Size of: ", stringify!(__locale_struct))
        );
        assert_eq!(
            ::std::mem::align_of::<__locale_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(__locale_struct))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    impl Default for __locale_struct {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type __locale_t = *mut __locale_struct;
    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    pub type pthread_once_t = ::std::os::raw::c_int;
    pub type c_constr = *const ::std::os::raw::c_char;
    pub type __gnuc_va_list = __builtin_va_list;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: __mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    impl Default for __mbstate_t__bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
        }
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    impl Default for __mbstate_t {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __mbstate_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
                self.__count, self.__value
            )
        }
    }
    pub type FILE = _IO_FILE;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut _IO_marker,
        pub _chain: *mut _IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: __off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut _IO_lock_t,
        pub _offset: __off64_t,
        pub _codecvt: *mut _IO_codecvt,
        pub _wide_data: *mut _IO_wide_data,
        pub _freeres_list: *mut _IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[test]
    fn bindgen_test_layout__IO_FILE() {
        assert_eq!(
            ::std::mem::size_of::<_IO_FILE>(),
            216usize,
            concat!("Size of: ", stringify!(_IO_FILE))
        );
        assert_eq!(
            ::std::mem::align_of::<_IO_FILE>(),
            8usize,
            concat!("Alignment of ", stringify!(_IO_FILE))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    impl Default for _IO_FILE {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type va_list = __gnuc_va_list;
    extern "C" {
        pub fn EM_newline();
    }
    extern "C" {
        pub fn ck_fprintf_stdout(format: *const ::std::os::raw::c_char, ...);
    }
    extern "C" {
        pub fn ck_fprintf_stderr(format: *const ::std::os::raw::c_char, ...);
    }
    extern "C" {
        pub fn ck_fflush_stdout();
    }
    extern "C" {
        pub fn ck_fflush_stderr();
    }
    extern "C" {
        pub fn ck_vfprintf_stdout(format: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
    }
    extern "C" {
        pub fn ck_vfprintf_stderr(format: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
    }
    extern "C" {
        pub fn ck_set_stdout_callback(
            callback: ::std::option::Option<
                unsafe extern "C" fn(callback: *const ::std::os::raw::c_char),
            >,
        );
    }
    extern "C" {
        pub fn ck_set_stderr_callback(
            callback: ::std::option::Option<
                unsafe extern "C" fn(callback: *const ::std::os::raw::c_char),
            >,
        );
    }
    pub type mbstate_t = __mbstate_t;
    pub type __gthread_once_t = pthread_once_t;
    pub type _Atomic_word = ::std::os::raw::c_int;
    #[repr(C)]
    pub struct ChuckOutStream {
        pub m_stream: stringstream,
        pub m_callback:
            ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
        pub m_isErr: bool,
    }
    #[test]
    fn bindgen_test_layout_ChuckOutStream() {
        assert_eq!(
            ::std::mem::size_of::<ChuckOutStream>(),
            408usize,
            concat!("Size of: ", stringify!(ChuckOutStream))
        );
        assert_eq!(
            ::std::mem::align_of::<ChuckOutStream>(),
            8usize,
            concat!("Alignment of ", stringify!(ChuckOutStream))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<ChuckOutStream>())).m_stream as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ChuckOutStream),
                "::",
                stringify!(m_stream)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<ChuckOutStream>())).m_callback as *const _ as usize },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(ChuckOutStream),
                "::",
                stringify!(m_callback)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<ChuckOutStream>())).m_isErr as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(ChuckOutStream),
                "::",
                stringify!(m_isErr)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}set_callback"]
        pub fn ChuckOutStream_set_callback(
            this: *mut ChuckOutStream,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    this: *mut ChuckOutStream,
                    callback: *const ::std::os::raw::c_char,
                ),
            >,
        );
    }
    extern "C" {
        #[link_name = "\u{1}ChuckOutStream"]
        pub fn ChuckOutStream_ChuckOutStream(this: *mut ChuckOutStream, isErr: bool);
    }
    extern "C" {
        #[link_name = "\u{1}ChuckOutStream_destructor"]
        pub fn ChuckOutStream_ChuckOutStream_destructor(this: *mut ChuckOutStream);
    }
    impl Default for ChuckOutStream {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for ChuckOutStream {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "ChuckOutStream {{ m_stream: {:?}, m_callback: {:?}, m_isErr: {:?} }}",
                self.m_stream, self.m_callback, self.m_isErr
            )
        }
    }
    impl ChuckOutStream {
        #[inline]
        pub unsafe fn set_callback(
            &mut self,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    this: *mut ChuckOutStream,
                    callback: *const ::std::os::raw::c_char,
                ),
            >,
        ) {
            ChuckOutStream_set_callback(self, callback)
        }
        #[inline]
        pub unsafe fn new(isErr: bool) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ChuckOutStream_ChuckOutStream(&mut __bindgen_tmp, isErr);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            ChuckOutStream_ChuckOutStream_destructor(self)
        }
    }
    extern "C" {
        pub fn EM_log(arg1: ::std::os::raw::c_long, arg2: c_constr, ...);
    }
    extern "C" {
        pub fn EM_setlog(arg1: ::std::os::raw::c_long);
    }
    extern "C" {
        pub fn EM_pushlog();
    }
    extern "C" {
        pub fn EM_poplog();
    }
    extern "C" {
        pub fn EM_error(arg1: ::std::os::raw::c_int, arg2: c_constr, ...);
    }
    extern "C" {
        pub fn EM_error2(arg1: ::std::os::raw::c_int, arg2: c_constr, ...);
    }
    extern "C" {
        pub fn EM_error2b(arg1: ::std::os::raw::c_int, arg2: c_constr, ...);
    }
    extern "C" {
        pub fn EM_error3(arg1: c_constr, ...);
    }
    extern "C" {
        pub fn EM_impossible(arg1: c_constr, ...);
    }
    extern "C" {
        pub fn EM_reset(filename: c_constr, fd: *mut FILE) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn EM_change_file(filename: c_constr);
    }
    extern "C" {
        pub fn EM_lasterror() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn EM_reset_msg();
    }
    extern "C" {
        pub fn mini(str: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn mini_type(str: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __locale_data {
        pub _address: u8,
    }
    pub type __builtin_va_list = [__va_list_tag; 1usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        assert_eq!(
            ::std::mem::size_of::<__va_list_tag>(),
            24usize,
            concat!("Size of: ", stringify!(__va_list_tag))
        );
        assert_eq!(
            ::std::mem::align_of::<__va_list_tag>(),
            8usize,
            concat!("Alignment of ", stringify!(__va_list_tag))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    impl Default for __va_list_tag {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_stringstream_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<basic_stringstream<::std::os::raw::c_char>>(),
            392usize,
            concat!(
                "Size of template specialization: ",
                stringify!(basic_stringstream<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<basic_stringstream<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(basic_stringstream<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<char_traits>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(char_traits))
        );
        assert_eq!(
            ::std::mem::align_of::<char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<allocator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(allocator))
        );
        assert_eq!(
            ::std::mem::align_of::<allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_iterator_open0_output_iterator_tag_void_void_void_void_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<iterator>(),
            1usize,
            concat!("Size of template specialization: ", stringify!(iterator))
        );
        assert_eq!(
            ::std::mem::align_of::<iterator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(iterator)
            )
        );
    }
}
