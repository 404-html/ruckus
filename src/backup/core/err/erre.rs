/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> Hash for __BindgenUnionField<T> {
    fn hash<H: Hasher>(&self, _state: &mut H) {}
}
impl<T> PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> Eq for __BindgenUnionField<T> {}

pub mod std {

    pub mod __cxx11 {

        pub type string = root::std::__cxx11::basic_string<::std::os::raw::c_char>;
        #[repr(C)]
        pub struct basic_string<_CharT> {
            pub _M_dataplus: root::std::__cxx11::basic_string__Alloc_hider,
            pub _M_string_length: root::std::__cxx11::basic_string_size_type,
            pub __bindgen_anon_1: root::std::__cxx11::basic_string__bindgen_ty_2<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string__Char_alloc_type = [u8; 0usize];
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::__cxx11::basic_string__Char_alloc_type;
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_reference = [u8; 0usize];
        pub type basic_string_const_reference = [u8; 0usize];
        pub type basic_string_pointer = [u8; 0usize];
        pub type basic_string_const_pointer = [u8; 0usize];
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::__cxx11::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::__cxx11::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::__cxx11::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::__cxx11::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::__cxx11::basic_string_const_iterator;
        pub type basic_string___sv_type<_CharT> = root::std::basic_string_view<_CharT>;
        pub type basic_string__If_sv = root::std::enable_if_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct basic_string___sv_wrapper<_CharT> {
            pub _M_sv: root::std::__cxx11::basic_string___sv_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        impl<_CharT> Default for basic_string___sv_wrapper<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::__cxx11::basic_string_pointer,
        }
        impl Default for basic_string__Alloc_hider {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl ::std::fmt::Debug for basic_string__Alloc_hider {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "basic_string__Alloc_hider {{  }}")
            }
        }
        impl PartialEq for basic_string__Alloc_hider {
            fn eq(&self, other: &basic_string__Alloc_hider) -> bool {
                self._M_p == other._M_p
            }
        }
        pub const basic_string__S_local_capacity: root::std::__cxx11::basic_string__bindgen_ty_1 =
            0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub struct basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: root::__BindgenUnionField<*mut _CharT>,
            pub _M_allocated_capacity:
                root::__BindgenUnionField<root::std::__cxx11::basic_string_size_type>,
            pub bindgen_union_field: u64,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        impl<_CharT> Default for basic_string__bindgen_ty_2<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_string__bindgen_ty_2<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "basic_string__bindgen_ty_2 {{ union }}")
            }
        }
        impl<_CharT> Default for basic_string<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_string<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "basic_string {{ _M_dataplus: {:?}, __bindgen_anon_1: {:?} }}",
                    self._M_dataplus, self.__bindgen_anon_1
                )
            }
        }
        #[repr(C)]
        pub struct basic_stringbuf<_CharT> {
            pub _base: root::std::basic_streambuf<_CharT>,
            pub _M_mode: root::std::ios_base_openmode,
            pub _M_string: root::std::__cxx11::basic_stringbuf___string_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_stringbuf_char_type<_CharT> = _CharT;
        pub type basic_stringbuf_traits_type<_Traits> = _Traits;
        pub type basic_stringbuf_allocator_type<_Alloc> = _Alloc;
        pub type basic_stringbuf_int_type = [u8; 0usize];
        pub type basic_stringbuf_pos_type = [u8; 0usize];
        pub type basic_stringbuf_off_type = [u8; 0usize];
        pub type basic_stringbuf___streambuf_type<_CharT> =
            root::std::basic_streambuf<root::std::__cxx11::basic_stringbuf_char_type<_CharT>>;
        pub type basic_stringbuf___string_type<_CharT> =
            root::std::__cxx11::basic_string<root::std::__cxx11::basic_stringbuf_char_type<_CharT>>;
        pub type basic_stringbuf___size_type<_CharT> =
            root::std::__cxx11::basic_stringbuf___string_type<_CharT>;
        #[repr(C)]
        pub struct basic_stringbuf___xfer_bufptrs<_CharT> {
            pub _M_to: *mut root::std::__cxx11::basic_stringbuf<_CharT>,
            pub _M_goff: [self::std::__cxx11::basic_stringbuf_off_type; 3usize],
            pub _M_poff: [self::std::__cxx11::basic_stringbuf_off_type; 3usize],
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        impl<_CharT> Default for basic_stringbuf___xfer_bufptrs<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_stringbuf___xfer_bufptrs<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! ( f , "basic_stringbuf___xfer_bufptrs {{ _M_to: {:?}, _M_goff: {:?}, _M_poff: {:?} }}" , self . _M_to , self . _M_goff , self . _M_poff )
            }
        }
        impl<_CharT> Default for basic_stringbuf<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_stringbuf<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "basic_stringbuf {{ _M_mode: {:?}, _M_string: {:?} }}",
                    self._M_mode, self._M_string
                )
            }
        }
        #[repr(C)]
        pub struct basic_stringstream<_CharT> {
            pub _base: root::std::basic_iostream<_CharT>,
            pub _M_stringbuf: root::std::__cxx11::basic_stringstream___stringbuf_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_stringstream_char_type<_CharT> = _CharT;
        pub type basic_stringstream_traits_type<_Traits> = _Traits;
        pub type basic_stringstream_allocator_type<_Alloc> = _Alloc;
        pub type basic_stringstream_int_type = [u8; 0usize];
        pub type basic_stringstream_pos_type = [u8; 0usize];
        pub type basic_stringstream_off_type = [u8; 0usize];
        pub type basic_stringstream___string_type<_CharT> =
            root::std::__cxx11::basic_string<_CharT>;
        pub type basic_stringstream___stringbuf_type<_CharT> =
            root::std::__cxx11::basic_stringbuf<_CharT>;
        pub type basic_stringstream___iostream_type<_CharT> =
            root::std::basic_iostream<root::std::__cxx11::basic_stringstream_char_type<_CharT>>;
        impl<_CharT> Default for basic_stringstream<_CharT> {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        impl<_CharT> ::std::fmt::Debug for basic_stringstream<_CharT> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "basic_stringstream {{ _M_stringbuf: {:?} }}",
                    self._M_stringbuf
                )
            }
        }
    }
    pub type streamoff = ::std::os::raw::c_long;
    pub type streamsize = isize;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct fpos<_StateT> {
        pub _M_off: root::std::streamoff,
        pub _M_state: _StateT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
    }
    impl<_StateT> Default for fpos<_StateT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type streampos = root::std::fpos<root::mbstate_t>;
    pub type stringstream = root::std::__cxx11::basic_stringstream<::std::os::raw::c_char>;
    #[repr(C)]
    pub struct exception__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct exception {
        pub vtable_: *const exception__bindgen_vtable,
    }
    // #[test]
    // fn bindgen_test_layout_exception() {
    //     assert_eq!(
    //         ::std::mem::size_of::<exception>(),
    //         8usize,
    //         concat!("Size of: ", stringify!(exception))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<exception>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(exception))
    //     );
    // }
    impl Default for exception {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    extern "C" {
        #[link_name = "\u{1}exception_destructor"]
        pub fn exception_exception_destructor(this: *mut root::std::exception);
    }
    extern "C" {
        #[link_name = "\u{1}what"]
        pub fn exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
    }
    pub type integral_constant_value_type<_Tp> = _Tp;
    pub type integral_constant_type = u8;
    pub type true_type = u8;
    pub type false_type = u8;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __and_ {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct is_empty {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct make_unsigned {
        pub _address: u8,
    }
    pub type make_unsigned_type = u8;
    pub type enable_if_t = u8;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __detector {
        pub _address: u8,
    }
    pub type __detector_value_t = root::std::false_type;
    pub type __detector_type<_Default> = _Default;
    pub type __detected_or = root::std::__detector;
    pub type __detected_or_t = root::std::__detected_or;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct input_iterator_tag {
        pub _address: u8,
    }
    // #[test]
    // fn bindgen_test_layout_input_iterator_tag() {
    //     assert_eq!(
    //         ::std::mem::size_of::<input_iterator_tag>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(input_iterator_tag))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<input_iterator_tag>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(input_iterator_tag))
    //     );
    // }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct output_iterator_tag {
        pub _address: u8,
    }
    // #[test]
    // fn bindgen_test_layout_output_iterator_tag() {
    //     assert_eq!(
    //         ::std::mem::size_of::<output_iterator_tag>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(output_iterator_tag))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<output_iterator_tag>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(output_iterator_tag))
    //     );
    // }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct iterator {
        pub _address: u8,
    }
    pub type iterator_iterator_category<_Category> = _Category;
    pub type iterator_value_type<_Tp> = _Tp;
    pub type iterator_difference_type<_Distance> = _Distance;
    pub type iterator_pointer<_Pointer> = _Pointer;
    pub type iterator_reference<_Reference> = _Reference;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __iterator_traits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct iterator_traits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __undefined {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __get_first_arg {
        pub _address: u8,
    }
    pub type __get_first_arg_type = root::std::__undefined;
    pub type __get_first_arg_t = root::std::__get_first_arg;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __replace_first_arg {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct pointer_traits {
        pub _address: u8,
    }
    pub type pointer_traits___element_type = [u8; 0usize];
    pub type pointer_traits___difference_type = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct pointer_traits___rebind {
        pub _address: u8,
    }
    impl Default for pointer_traits___rebind {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type pointer_traits_pointer<_Ptr> = _Ptr;
    pub type pointer_traits_element_type = root::std::__detected_or_t;
    pub type pointer_traits_difference_type = root::std::__detected_or_t;
    pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct reverse_iterator<_Iterator> {
        pub current: _Iterator,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    }
    pub type reverse_iterator___traits_type = root::std::iterator_traits;
    pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
    pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
    pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
    pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
    impl<_Iterator> Default for reverse_iterator<_Iterator> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct char_traits {
        pub _address: u8,
    }
    impl Default for char_traits {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type __c_locale = root::__locale_t;
    pub type __allocator_base = root::__gnu_cxx::new_allocator;
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator {
        pub _address: u8,
    }
    pub type allocator_size_type = usize;
    pub type allocator_difference_type = isize;
    pub type allocator_pointer<_Tp> = *mut _Tp;
    pub type allocator_const_pointer<_Tp> = *const _Tp;
    pub type allocator_reference<_Tp> = *mut _Tp;
    pub type allocator_const_reference<_Tp> = *const _Tp;
    pub type allocator_value_type<_Tp> = _Tp;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_rebind {
        pub _address: u8,
    }
    pub type allocator_rebind_other = root::std::allocator;
    pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
    pub type allocator_is_always_equal = root::std::true_type;
    impl Default for allocator {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __allocator_traits_base {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __allocator_traits_base___rebind {
        pub _address: u8,
    }
    impl Default for __allocator_traits_base___rebind {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type __allocator_traits_base___pointer = [u8; 0usize];
    pub type __allocator_traits_base___c_pointer = [u8; 0usize];
    pub type __allocator_traits_base___v_pointer = [u8; 0usize];
    pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
    pub type __allocator_traits_base___pocca = [u8; 0usize];
    pub type __allocator_traits_base___pocma = [u8; 0usize];
    pub type __allocator_traits_base___pocs = [u8; 0usize];
    pub type __allocator_traits_base___equal = [u8; 0usize];
    // #[test]
    // fn bindgen_test_layout___allocator_traits_base() {
    //     assert_eq!(
    //         ::std::mem::size_of::<__allocator_traits_base>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(__allocator_traits_base))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<__allocator_traits_base>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(__allocator_traits_base))
    //     );
    // }
    pub type __alloc_rebind = root::std::__allocator_traits_base;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits {
        pub _address: u8,
    }
    pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
    pub type allocator_traits_value_type = [u8; 0usize];
    pub type allocator_traits_pointer = root::std::__detected_or_t;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits__Ptr {
        pub _address: u8,
    }
    pub type allocator_traits__Ptr_type = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits__Diff {
        pub _address: u8,
    }
    pub type allocator_traits__Diff_type = root::std::pointer_traits;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits__Size {
        pub _address: u8,
    }
    impl Default for allocator_traits__Size {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub type allocator_traits_const_pointer = [u8; 0usize];
    pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
    pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
    pub type allocator_traits_difference_type = [u8; 0usize];
    pub type allocator_traits_size_type = [u8; 0usize];
    pub type allocator_traits_propagate_on_container_copy_assignment = root::std::__detected_or_t;
    pub type allocator_traits_propagate_on_container_move_assignment = root::std::__detected_or_t;
    pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
    pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
    pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
    pub type allocator_traits_rebind_traits = root::std::allocator_traits;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct allocator_traits___construct_helper {
        pub _address: u8,
    }
    pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
    pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_string_view<_CharT> {
        pub _M_len: usize,
        pub _M_str: *const _CharT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type basic_string_view_traits_type<_Traits> = _Traits;
    pub type basic_string_view_value_type<_CharT> = _CharT;
    pub type basic_string_view_pointer<_CharT> = *const _CharT;
    pub type basic_string_view_const_pointer<_CharT> = *const _CharT;
    pub type basic_string_view_reference<_CharT> = *const _CharT;
    pub type basic_string_view_const_reference<_CharT> = *const _CharT;
    pub type basic_string_view_const_iterator<_CharT> = *const _CharT;
    pub type basic_string_view_iterator<_CharT> =
        root::std::basic_string_view_const_iterator<_CharT>;
    pub type basic_string_view_const_reverse_iterator<_CharT> =
        root::std::reverse_iterator<root::std::basic_string_view_const_iterator<_CharT>>;
    pub type basic_string_view_reverse_iterator<_CharT> =
        root::std::basic_string_view_const_reverse_iterator<_CharT>;
    pub type basic_string_view_size_type = usize;
    pub type basic_string_view_difference_type = isize;
    impl<_CharT> Default for basic_string_view<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub mod literals {}
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct locale {
        pub _M_impl: *mut root::std::locale__Impl,
    }
    pub type locale_category = ::std::os::raw::c_int;
    pub const locale__S_categories_size: root::std::locale__bindgen_ty_1 = 12;
    pub type locale__bindgen_ty_1 = u32;
    pub const locale_none: root::std::locale_category = 0;
    pub const locale_ctype: root::std::locale_category = 1;
    pub const locale_numeric: root::std::locale_category = 2;
    pub const locale_collate: root::std::locale_category = 4;
    pub const locale_time: root::std::locale_category = 8;
    pub const locale_monetary: root::std::locale_category = 16;
    pub const locale_messages: root::std::locale_category = 32;
    pub const locale_all: root::std::locale_category = 63;
    extern "C" {
        #[link_name = "\u{1}_S_classic"]
        pub static mut locale__S_classic: *mut root::std::locale__Impl;
    }
    extern "C" {
        #[link_name = "\u{1}_S_global"]
        pub static mut locale__S_global: *mut root::std::locale__Impl;
    }
    extern "C" {
        #[link_name = "\u{1}_S_categories"]
        pub static locale__S_categories: *const *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_S_once"]
        pub static mut locale__S_once: root::__gthread_once_t;
    }
    extern "C" {
        #[link_name = "\u{1}_S_twinned_facets"]
        pub static mut locale__S_twinned_facets: [*const root::std::locale_id; 0usize];
    }
    // #[test]
    // fn bindgen_test_layout_locale() {
    //     assert_eq!(
    //         ::std::mem::size_of::<locale>(),
    //         8usize,
    //         concat!("Size of: ", stringify!(locale))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<locale>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(locale))
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<locale>()))._M_impl as *const _ as usize },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale),
    //             "::",
    //             stringify!(_M_impl)
    //         )
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}name"]
        pub fn locale_name(this: *const root::std::locale) -> root::std::__cxx11::string;
    }
    extern "C" {
        #[link_name = "\u{1}global"]
        pub fn locale_global(__loc: *const root::std::locale) -> root::std::locale;
    }
    extern "C" {
        #[link_name = "\u{1}classic"]
        pub fn locale_classic() -> *const root::std::locale;
    }
    extern "C" {
        #[link_name = "\u{1}locale"]
        pub fn locale_locale(this: *mut root::std::locale);
    }
    extern "C" {
        #[link_name = "\u{1}locale"]
        pub fn locale_locale1(this: *mut root::std::locale, __other: *const root::std::locale);
    }
    extern "C" {
        #[link_name = "\u{1}locale"]
        pub fn locale_locale2(this: *mut root::std::locale, __s: *const ::std::os::raw::c_char);
    }
    extern "C" {
        #[link_name = "\u{1}locale"]
        pub fn locale_locale3(
            this: *mut root::std::locale,
            __base: *const root::std::locale,
            __s: *const ::std::os::raw::c_char,
            __cat: root::std::locale_category,
        );
    }
    extern "C" {
        #[link_name = "\u{1}locale"]
        pub fn locale_locale4(
            this: *mut root::std::locale,
            __base: *const root::std::locale,
            __add: *const root::std::locale,
            __cat: root::std::locale_category,
        );
    }
    extern "C" {
        #[link_name = "\u{1}locale_destructor"]
        pub fn locale_locale_destructor(this: *mut root::std::locale);
    }
    impl Default for locale {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl locale {
        #[inline]
        pub unsafe fn name(&self) -> root::std::__cxx11::string {
            locale_name(self)
        }
        #[inline]
        pub unsafe fn global(__loc: *const root::std::locale) -> root::std::locale {
            locale_global(__loc)
        }
        #[inline]
        pub unsafe fn classic() -> *const root::std::locale {
            locale_classic()
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            locale_locale(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(__other: *const root::std::locale) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            locale_locale1(&mut __bindgen_tmp, __other);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            locale_locale2(&mut __bindgen_tmp, __s);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(
            __base: *const root::std::locale,
            __s: *const ::std::os::raw::c_char,
            __cat: root::std::locale_category,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            locale_locale3(&mut __bindgen_tmp, __base, __s, __cat);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(
            __base: *const root::std::locale,
            __add: *const root::std::locale,
            __cat: root::std::locale_category,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            locale_locale4(&mut __bindgen_tmp, __base, __add, __cat);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            locale_locale_destructor(self)
        }
    }
    #[repr(C)]
    pub struct locale_facet__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct locale_facet {
        pub vtable_: *const locale_facet__bindgen_vtable,
        pub _M_refcount: root::_Atomic_word,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct locale_facet___shim {
        _unused: [u8; 0],
    }
    extern "C" {
        #[link_name = "\u{1}_S_c_locale"]
        pub static mut locale_facet__S_c_locale: root::std::__c_locale;
    }
    extern "C" {
        #[link_name = "\u{1}_S_c_name"]
        pub static mut locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_once"]
        pub static mut locale_facet__S_once: root::__gthread_once_t;
    }
    // #[test]
    // fn bindgen_test_layout_locale_facet() {
    //     assert_eq!(
    //         ::std::mem::size_of::<locale_facet>(),
    //         16usize,
    //         concat!("Size of: ", stringify!(locale_facet))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<locale_facet>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(locale_facet))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<locale_facet>()))._M_refcount as *const _ as usize
    //         },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale_facet),
    //             "::",
    //             stringify!(_M_refcount)
    //         )
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}_S_create_c_locale"]
        pub fn locale_facet__S_create_c_locale(
            __cloc: *mut root::std::__c_locale,
            __s: *const ::std::os::raw::c_char,
            __old: root::std::__c_locale,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_S_clone_c_locale"]
        pub fn locale_facet__S_clone_c_locale(
            __cloc: *mut root::std::__c_locale,
        ) -> root::std::__c_locale;
    }
    extern "C" {
        #[link_name = "\u{1}_S_destroy_c_locale"]
        pub fn locale_facet__S_destroy_c_locale(__cloc: *mut root::std::__c_locale);
    }
    extern "C" {
        #[link_name = "\u{1}_S_lc_ctype_c_locale"]
        pub fn locale_facet__S_lc_ctype_c_locale(
            __cloc: root::std::__c_locale,
            __s: *const ::std::os::raw::c_char,
        ) -> root::std::__c_locale;
    }
    extern "C" {
        #[link_name = "\u{1}_S_get_c_locale"]
        pub fn locale_facet__S_get_c_locale() -> root::std::__c_locale;
    }
    extern "C" {
        #[link_name = "\u{1}_S_get_c_name"]
        pub fn locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
    }
    impl Default for locale_facet {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl locale_facet {
        #[inline]
        pub unsafe fn _S_create_c_locale(
            __cloc: *mut root::std::__c_locale,
            __s: *const ::std::os::raw::c_char,
            __old: root::std::__c_locale,
        ) {
            locale_facet__S_create_c_locale(__cloc, __s, __old)
        }
        #[inline]
        pub unsafe fn _S_clone_c_locale(
            __cloc: *mut root::std::__c_locale,
        ) -> root::std::__c_locale {
            locale_facet__S_clone_c_locale(__cloc)
        }
        #[inline]
        pub unsafe fn _S_destroy_c_locale(__cloc: *mut root::std::__c_locale) {
            locale_facet__S_destroy_c_locale(__cloc)
        }
        #[inline]
        pub unsafe fn _S_lc_ctype_c_locale(
            __cloc: root::std::__c_locale,
            __s: *const ::std::os::raw::c_char,
        ) -> root::std::__c_locale {
            locale_facet__S_lc_ctype_c_locale(__cloc, __s)
        }
        #[inline]
        pub unsafe fn _S_get_c_locale() -> root::std::__c_locale {
            locale_facet__S_get_c_locale()
        }
        #[inline]
        pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
            locale_facet__S_get_c_name()
        }
    }
    extern "C" {
        #[link_name = "\u{1}facet_destructor"]
        pub fn locale_facet_facet_destructor(this: *mut root::std::locale_facet);
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct locale_id {
        pub _M_index: usize,
    }
    extern "C" {
        #[link_name = "\u{1}_S_refcount"]
        pub static mut locale_id__S_refcount: root::_Atomic_word;
    }
    // #[test]
    // fn bindgen_test_layout_locale_id() {
    //     assert_eq!(
    //         ::std::mem::size_of::<locale_id>(),
    //         8usize,
    //         concat!("Size of: ", stringify!(locale_id))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<locale_id>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(locale_id))
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<locale_id>()))._M_index as *const _ as usize },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale_id),
    //             "::",
    //             stringify!(_M_index)
    //         )
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}_M_id"]
        pub fn locale_id__M_id(this: *const root::std::locale_id) -> usize;
    }
    impl locale_id {
        #[inline]
        pub unsafe fn _M_id(&self) -> usize {
            locale_id__M_id(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct locale__Impl {
        pub _M_refcount: root::_Atomic_word,
        pub _M_facets: *mut *const root::std::locale_facet,
        pub _M_facets_size: usize,
        pub _M_caches: *mut *const root::std::locale_facet,
        pub _M_names: *mut *mut ::std::os::raw::c_char,
    }
    extern "C" {
        #[link_name = "\u{1}_S_id_ctype"]
        pub static mut locale__Impl__S_id_ctype: [*const root::std::locale_id; 0usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_id_numeric"]
        pub static mut locale__Impl__S_id_numeric: [*const root::std::locale_id; 0usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_id_collate"]
        pub static mut locale__Impl__S_id_collate: [*const root::std::locale_id; 0usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_id_time"]
        pub static mut locale__Impl__S_id_time: [*const root::std::locale_id; 0usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_id_monetary"]
        pub static mut locale__Impl__S_id_monetary: [*const root::std::locale_id; 0usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_id_messages"]
        pub static mut locale__Impl__S_id_messages: [*const root::std::locale_id; 0usize];
    }
    extern "C" {
        #[link_name = "\u{1}_S_facet_categories"]
        pub static mut locale__Impl__S_facet_categories:
            [*const *const root::std::locale_id; 0usize];
    }
    // #[test]
    // fn bindgen_test_layout_locale__Impl() {
    //     assert_eq!(
    //         ::std::mem::size_of::<locale__Impl>(),
    //         40usize,
    //         concat!("Size of: ", stringify!(locale__Impl))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<locale__Impl>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(locale__Impl))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<locale__Impl>()))._M_refcount as *const _ as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale__Impl),
    //             "::",
    //             stringify!(_M_refcount)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_facets as *const _ as usize },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale__Impl),
    //             "::",
    //             stringify!(_M_facets)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<locale__Impl>()))._M_facets_size as *const _ as usize
    //         },
    //         16usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale__Impl),
    //             "::",
    //             stringify!(_M_facets_size)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_caches as *const _ as usize },
    //         24usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale__Impl),
    //             "::",
    //             stringify!(_M_caches)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_names as *const _ as usize },
    //         32usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(locale__Impl),
    //             "::",
    //             stringify!(_M_names)
    //         )
    //     );
    // }
    impl Default for locale__Impl {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    pub struct __cow_string {
        pub __bindgen_anon_1: root::std::__cow_string__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __cow_string__bindgen_ty_1 {
        pub _M_p: *const ::std::os::raw::c_char,
        pub _M_bytes: [::std::os::raw::c_char; 8usize],
        _bindgen_union_align: u64,
    }
    // #[test]
    // fn bindgen_test_layout___cow_string__bindgen_ty_1() {
    //     assert_eq!(
    //         ::std::mem::size_of::<__cow_string__bindgen_ty_1>(),
    //         8usize,
    //         concat!("Size of: ", stringify!(__cow_string__bindgen_ty_1))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<__cow_string__bindgen_ty_1>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(__cow_string__bindgen_ty_1))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_p as *const _ as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(__cow_string__bindgen_ty_1),
    //             "::",
    //             stringify!(_M_p)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_bytes as *const _
    //                 as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(__cow_string__bindgen_ty_1),
    //             "::",
    //             stringify!(_M_bytes)
    //         )
    //     );
    // }
    impl Default for __cow_string__bindgen_ty_1 {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __cow_string__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "__cow_string__bindgen_ty_1 {{ union }}")
        }
    }
    // #[test]
    // fn bindgen_test_layout___cow_string() {
    //     assert_eq!(
    //         ::std::mem::size_of::<__cow_string>(),
    //         8usize,
    //         concat!("Size of: ", stringify!(__cow_string))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<__cow_string>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(__cow_string))
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}__cow_string"]
        pub fn __cow_string___cow_string(this: *mut root::std::__cow_string);
    }
    extern "C" {
        #[link_name = "\u{1}__cow_string"]
        pub fn __cow_string___cow_string1(
            this: *mut root::std::__cow_string,
            arg1: *const root::std::__cxx11::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}__cow_string"]
        pub fn __cow_string___cow_string2(
            this: *mut root::std::__cow_string,
            arg1: *const ::std::os::raw::c_char,
            arg2: usize,
        );
    }
    extern "C" {
        #[link_name = "\u{1}__cow_string"]
        pub fn __cow_string___cow_string3(
            this: *mut root::std::__cow_string,
            arg1: *const root::std::__cow_string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}__cow_string"]
        pub fn __cow_string___cow_string4(
            this: *mut root::std::__cow_string,
            arg1: *mut root::std::__cow_string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}__cow_string_destructor"]
        pub fn __cow_string___cow_string_destructor(this: *mut root::std::__cow_string);
    }
    impl Default for __cow_string {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for __cow_string {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(
                f,
                "__cow_string {{ __bindgen_anon_1: {:?} }}",
                self.__bindgen_anon_1
            )
        }
    }
    impl __cow_string {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            __cow_string___cow_string(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const root::std::__cxx11::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            __cow_string___cow_string1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            __cow_string___cow_string2(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new3(arg1: *const root::std::__cow_string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            __cow_string___cow_string3(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new4(arg1: *mut root::std::__cow_string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            __cow_string___cow_string4(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            __cow_string___cow_string_destructor(self)
        }
    }
    #[repr(C)]
    pub struct runtime_error {
        pub _base: root::std::exception,
        pub _M_msg: root::std::__cow_string,
    }
    // #[test]
    // fn bindgen_test_layout_runtime_error() {
    //     assert_eq!(
    //         ::std::mem::size_of::<runtime_error>(),
    //         16usize,
    //         concat!("Size of: ", stringify!(runtime_error))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<runtime_error>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(runtime_error))
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<runtime_error>()))._M_msg as *const _ as usize },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(runtime_error),
    //             "::",
    //             stringify!(_M_msg)
    //         )
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}runtime_error"]
        pub fn runtime_error_runtime_error(
            this: *mut root::std::runtime_error,
            __arg: *const root::std::__cxx11::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}runtime_error"]
        pub fn runtime_error_runtime_error1(
            this: *mut root::std::runtime_error,
            arg1: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}runtime_error"]
        pub fn runtime_error_runtime_error2(
            this: *mut root::std::runtime_error,
            arg1: *const root::std::runtime_error,
        );
    }
    impl Default for runtime_error {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for runtime_error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "runtime_error {{ _M_msg: {:?} }}", self._M_msg)
        }
    }
    impl runtime_error {
        #[inline]
        pub unsafe fn new(__arg: *const root::std::__cxx11::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            runtime_error_runtime_error(&mut __bindgen_tmp, __arg);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            runtime_error_runtime_error1(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(arg1: *const root::std::runtime_error) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            runtime_error_runtime_error2(&mut __bindgen_tmp, arg1);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}runtime_error_destructor"]
        pub fn runtime_error_runtime_error_destructor(this: *mut root::std::runtime_error);
    }
    extern "C" {
        #[link_name = "\u{1}what"]
        pub fn runtime_error_what(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    pub mod _V2 {

        #[repr(C)]
        pub struct error_category__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
        pub struct error_category {
            pub vtable_: *const error_category__bindgen_vtable,
        }
        // #[test]
        // fn bindgen_test_layout_error_category() {
        //     assert_eq!(
        //         ::std::mem::size_of::<error_category>(),
        //         8usize,
        //         concat!("Size of: ", stringify!(error_category))
        //     );
        //     assert_eq!(
        //         ::std::mem::align_of::<error_category>(),
        //         8usize,
        //         concat!("Alignment of ", stringify!(error_category))
        //     );
        // }
        impl Default for error_category {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }
        extern "C" {
            #[link_name = "\u{1}error_category_destructor"]
            pub fn error_category_error_category_destructor(
                this: *mut root::std::_V2::error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}default_error_condition"]
            pub fn error_category_default_error_condition(
                this: *mut ::std::os::raw::c_void,
                __i: ::std::os::raw::c_int,
            ) -> root::std::error_condition;
        }
        extern "C" {
            #[link_name = "\u{1}equivalent"]
            pub fn error_category_equivalent(
                this: *mut ::std::os::raw::c_void,
                __i: ::std::os::raw::c_int,
                __cond: *const root::std::error_condition,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}equivalent"]
            pub fn error_category_equivalent1(
                this: *mut ::std::os::raw::c_void,
                __code: *const root::std::error_code,
                __i: ::std::os::raw::c_int,
            ) -> bool;
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct error_code {
        pub _M_value: ::std::os::raw::c_int,
        pub _M_cat: *const root::std::_V2::error_category,
    }
    // #[test]
    // fn bindgen_test_layout_error_code() {
    //     assert_eq!(
    //         ::std::mem::size_of::<error_code>(),
    //         16usize,
    //         concat!("Size of: ", stringify!(error_code))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<error_code>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(error_code))
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<error_code>()))._M_value as *const _ as usize },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(error_code),
    //             "::",
    //             stringify!(_M_value)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<error_code>()))._M_cat as *const _ as usize },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(error_code),
    //             "::",
    //             stringify!(_M_cat)
    //         )
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}default_error_condition"]
        pub fn error_code_default_error_condition(
            this: *const root::std::error_code,
        ) -> root::std::error_condition;
    }
    impl Default for error_code {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl error_code {
        #[inline]
        pub unsafe fn default_error_condition(&self) -> root::std::error_condition {
            error_code_default_error_condition(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct error_condition {
        pub _M_value: ::std::os::raw::c_int,
        pub _M_cat: *const root::std::_V2::error_category,
    }
    // #[test]
    // fn bindgen_test_layout_error_condition() {
    //     assert_eq!(
    //         ::std::mem::size_of::<error_condition>(),
    //         16usize,
    //         concat!("Size of: ", stringify!(error_condition))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<error_condition>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(error_condition))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<error_condition>()))._M_value as *const _ as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(error_condition),
    //             "::",
    //             stringify!(_M_value)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<error_condition>()))._M_cat as *const _ as usize },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(error_condition),
    //             "::",
    //             stringify!(_M_cat)
    //         )
    //     );
    // }
    impl Default for error_condition {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    pub struct system_error {
        pub _base: root::std::runtime_error,
        pub _M_code: root::std::error_code,
    }
    // #[test]
    // fn bindgen_test_layout_system_error() {
    //     assert_eq!(
    //         ::std::mem::size_of::<system_error>(),
    //         32usize,
    //         concat!("Size of: ", stringify!(system_error))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<system_error>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(system_error))
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<system_error>()))._M_code as *const _ as usize },
    //         16usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(system_error),
    //             "::",
    //             stringify!(_M_code)
    //         )
    //     );
    // }
    impl Default for system_error {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for system_error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "system_error {{ _M_code: {:?} }}", self._M_code)
        }
    }
    extern "C" {
        #[link_name = "\u{1}system_error_destructor"]
        pub fn system_error_system_error_destructor(this: *mut root::std::system_error);
    }
    pub const _Ios_Fmtflags__S_boolalpha: root::std::_Ios_Fmtflags = 1;
    pub const _Ios_Fmtflags__S_dec: root::std::_Ios_Fmtflags = 2;
    pub const _Ios_Fmtflags__S_fixed: root::std::_Ios_Fmtflags = 4;
    pub const _Ios_Fmtflags__S_hex: root::std::_Ios_Fmtflags = 8;
    pub const _Ios_Fmtflags__S_internal: root::std::_Ios_Fmtflags = 16;
    pub const _Ios_Fmtflags__S_left: root::std::_Ios_Fmtflags = 32;
    pub const _Ios_Fmtflags__S_oct: root::std::_Ios_Fmtflags = 64;
    pub const _Ios_Fmtflags__S_right: root::std::_Ios_Fmtflags = 128;
    pub const _Ios_Fmtflags__S_scientific: root::std::_Ios_Fmtflags = 256;
    pub const _Ios_Fmtflags__S_showbase: root::std::_Ios_Fmtflags = 512;
    pub const _Ios_Fmtflags__S_showpoint: root::std::_Ios_Fmtflags = 1024;
    pub const _Ios_Fmtflags__S_showpos: root::std::_Ios_Fmtflags = 2048;
    pub const _Ios_Fmtflags__S_skipws: root::std::_Ios_Fmtflags = 4096;
    pub const _Ios_Fmtflags__S_unitbuf: root::std::_Ios_Fmtflags = 8192;
    pub const _Ios_Fmtflags__S_uppercase: root::std::_Ios_Fmtflags = 16384;
    pub const _Ios_Fmtflags__S_adjustfield: root::std::_Ios_Fmtflags = 176;
    pub const _Ios_Fmtflags__S_basefield: root::std::_Ios_Fmtflags = 74;
    pub const _Ios_Fmtflags__S_floatfield: root::std::_Ios_Fmtflags = 260;
    pub const _Ios_Fmtflags__S_ios_fmtflags_end: root::std::_Ios_Fmtflags = 65536;
    pub const _Ios_Fmtflags__S_ios_fmtflags_max: root::std::_Ios_Fmtflags = 2147483647;
    pub const _Ios_Fmtflags__S_ios_fmtflags_min: root::std::_Ios_Fmtflags = -2147483648;
    pub type _Ios_Fmtflags = i32;
    pub const _Ios_Openmode__S_app: root::std::_Ios_Openmode = 1;
    pub const _Ios_Openmode__S_ate: root::std::_Ios_Openmode = 2;
    pub const _Ios_Openmode__S_bin: root::std::_Ios_Openmode = 4;
    pub const _Ios_Openmode__S_in: root::std::_Ios_Openmode = 8;
    pub const _Ios_Openmode__S_out: root::std::_Ios_Openmode = 16;
    pub const _Ios_Openmode__S_trunc: root::std::_Ios_Openmode = 32;
    pub const _Ios_Openmode__S_ios_openmode_end: root::std::_Ios_Openmode = 65536;
    pub const _Ios_Openmode__S_ios_openmode_max: root::std::_Ios_Openmode = 2147483647;
    pub const _Ios_Openmode__S_ios_openmode_min: root::std::_Ios_Openmode = -2147483648;
    pub type _Ios_Openmode = i32;
    pub const _Ios_Iostate__S_goodbit: root::std::_Ios_Iostate = 0;
    pub const _Ios_Iostate__S_badbit: root::std::_Ios_Iostate = 1;
    pub const _Ios_Iostate__S_eofbit: root::std::_Ios_Iostate = 2;
    pub const _Ios_Iostate__S_failbit: root::std::_Ios_Iostate = 4;
    pub const _Ios_Iostate__S_ios_iostate_end: root::std::_Ios_Iostate = 65536;
    pub const _Ios_Iostate__S_ios_iostate_max: root::std::_Ios_Iostate = 2147483647;
    pub const _Ios_Iostate__S_ios_iostate_min: root::std::_Ios_Iostate = -2147483648;
    pub type _Ios_Iostate = i32;
    pub const _Ios_Seekdir__S_beg: root::std::_Ios_Seekdir = 0;
    pub const _Ios_Seekdir__S_cur: root::std::_Ios_Seekdir = 1;
    pub const _Ios_Seekdir__S_end: root::std::_Ios_Seekdir = 2;
    pub const _Ios_Seekdir__S_ios_seekdir_end: root::std::_Ios_Seekdir = 65536;
    pub type _Ios_Seekdir = u32;
    #[repr(C)]
    pub struct ios_base__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ios_base {
        pub vtable_: *const ios_base__bindgen_vtable,
        pub _M_precision: root::std::streamsize,
        pub _M_width: root::std::streamsize,
        pub _M_flags: root::std::ios_base_fmtflags,
        pub _M_exception: root::std::ios_base_iostate,
        pub _M_streambuf_state: root::std::ios_base_iostate,
        pub _M_callbacks: *mut root::std::ios_base__Callback_list,
        pub _M_word_zero: root::std::ios_base__Words,
        pub _M_local_word: [self::std::ios_base__Words; 8usize],
        pub _M_word_size: ::std::os::raw::c_int,
        pub _M_word: *mut root::std::ios_base__Words,
        pub _M_ios_locale: root::std::locale,
    }
    #[repr(C)]
    pub struct ios_base_failure {
        pub _base: root::std::system_error,
    }
    // #[test]
    // fn bindgen_test_layout_ios_base_failure() {
    //     assert_eq!(
    //         ::std::mem::size_of::<ios_base_failure>(),
    //         32usize,
    //         concat!("Size of: ", stringify!(ios_base_failure))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<ios_base_failure>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(ios_base_failure))
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}failure"]
        pub fn ios_base_failure_failure(
            this: *mut root::std::ios_base_failure,
            __str: *const root::std::__cxx11::string,
        );
    }
    extern "C" {
        #[link_name = "\u{1}failure"]
        pub fn ios_base_failure_failure1(
            this: *mut root::std::ios_base_failure,
            arg1: *const root::std::__cxx11::string,
            arg2: *const root::std::error_code,
        );
    }
    extern "C" {
        #[link_name = "\u{1}failure"]
        pub fn ios_base_failure_failure2(
            this: *mut root::std::ios_base_failure,
            arg1: *const ::std::os::raw::c_char,
            arg2: *const root::std::error_code,
        );
    }
    impl Default for ios_base_failure {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ::std::fmt::Debug for ios_base_failure {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "ios_base_failure {{  }}")
        }
    }
    impl ios_base_failure {
        #[inline]
        pub unsafe fn new(__str: *const root::std::__cxx11::string) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ios_base_failure_failure(&mut __bindgen_tmp, __str);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(
            arg1: *const root::std::__cxx11::string,
            arg2: *const root::std::error_code,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ios_base_failure_failure1(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new2(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const root::std::error_code,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ios_base_failure_failure2(&mut __bindgen_tmp, arg1, arg2);
            __bindgen_tmp
        }
    }
    pub use std::_Ios_Fmtflags as ios_base_fmtflags;
    pub use std::_Ios_Iostate as ios_base_iostate;
    pub use std::_Ios_Openmode as ios_base_openmode;
    pub use std::_Ios_Seekdir as ios_base_seekdir;
    pub const ios_base_event_erase_event: root::std::ios_base_event = 0;
    pub const ios_base_event_imbue_event: root::std::ios_base_event = 1;
    pub const ios_base_event_copyfmt_event: root::std::ios_base_event = 2;
    pub type ios_base_event = u32;
    pub type ios_base_event_callback = ::std::option::Option<
        unsafe extern "C" fn(
            __e: root::std::ios_base_event,
            __b: *mut root::std::ios_base,
            __i: ::std::os::raw::c_int,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ios_base__Callback_list {
        pub _M_next: *mut root::std::ios_base__Callback_list,
        pub _M_fn: root::std::ios_base_event_callback,
        pub _M_index: ::std::os::raw::c_int,
        pub _M_refcount: root::_Atomic_word,
    }
    // #[test]
    // fn bindgen_test_layout_ios_base__Callback_list() {
    //     assert_eq!(
    //         ::std::mem::size_of::<ios_base__Callback_list>(),
    //         24usize,
    //         concat!("Size of: ", stringify!(ios_base__Callback_list))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<ios_base__Callback_list>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(ios_base__Callback_list))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_next as *const _ as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base__Callback_list),
    //             "::",
    //             stringify!(_M_next)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_fn as *const _ as usize
    //         },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base__Callback_list),
    //             "::",
    //             stringify!(_M_fn)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_index as *const _
    //                 as usize
    //         },
    //         16usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base__Callback_list),
    //             "::",
    //             stringify!(_M_index)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_refcount as *const _
    //                 as usize
    //         },
    //         20usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base__Callback_list),
    //             "::",
    //             stringify!(_M_refcount)
    //         )
    //     );
    // }
    impl Default for ios_base__Callback_list {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ios_base__Words {
        pub _M_pword: *mut ::std::os::raw::c_void,
        pub _M_iword: ::std::os::raw::c_long,
    }
    // #[test]
    // fn bindgen_test_layout_ios_base__Words() {
    //     assert_eq!(
    //         ::std::mem::size_of::<ios_base__Words>(),
    //         16usize,
    //         concat!("Size of: ", stringify!(ios_base__Words))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<ios_base__Words>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(ios_base__Words))
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base__Words>()))._M_pword as *const _ as usize
    //         },
    //         0usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base__Words),
    //             "::",
    //             stringify!(_M_pword)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base__Words>()))._M_iword as *const _ as usize
    //         },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base__Words),
    //             "::",
    //             stringify!(_M_iword)
    //         )
    //     );
    // }
    impl Default for ios_base__Words {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    pub const ios_base__S_local_word_size: root::std::ios_base__bindgen_ty_1 = 8;
    pub type ios_base__bindgen_ty_1 = u32;
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ios_base_Init {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "\u{1}_S_refcount"]
        pub static mut ios_base_Init__S_refcount: root::_Atomic_word;
    }
    extern "C" {
        #[link_name = "\u{1}_S_synced_with_stdio"]
        pub static mut ios_base_Init__S_synced_with_stdio: bool;
    }
    // #[test]
    // fn bindgen_test_layout_ios_base_Init() {
    //     assert_eq!(
    //         ::std::mem::size_of::<ios_base_Init>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(ios_base_Init))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<ios_base_Init>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(ios_base_Init))
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}Init"]
        pub fn ios_base_Init_Init(this: *mut root::std::ios_base_Init);
    }
    extern "C" {
        #[link_name = "\u{1}Init_destructor"]
        pub fn ios_base_Init_Init_destructor(this: *mut root::std::ios_base_Init);
    }
    impl ios_base_Init {
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ios_base_Init_Init(&mut __bindgen_tmp);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            ios_base_Init_Init_destructor(self)
        }
    }
    extern "C" {
        #[link_name = "\u{1}boolalpha"]
        pub static ios_base_boolalpha: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}dec"]
        pub static ios_base_dec: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}fixed"]
        pub static ios_base_fixed: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}hex"]
        pub static ios_base_hex: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}internal"]
        pub static ios_base_internal: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}left"]
        pub static ios_base_left: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}oct"]
        pub static ios_base_oct: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}right"]
        pub static ios_base_right: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}scientific"]
        pub static ios_base_scientific: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}showbase"]
        pub static ios_base_showbase: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}showpoint"]
        pub static ios_base_showpoint: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}showpos"]
        pub static ios_base_showpos: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}skipws"]
        pub static ios_base_skipws: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}unitbuf"]
        pub static ios_base_unitbuf: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}uppercase"]
        pub static ios_base_uppercase: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}adjustfield"]
        pub static ios_base_adjustfield: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}basefield"]
        pub static ios_base_basefield: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}floatfield"]
        pub static ios_base_floatfield: root::std::ios_base_fmtflags;
    }
    extern "C" {
        #[link_name = "\u{1}badbit"]
        pub static ios_base_badbit: root::std::ios_base_iostate;
    }
    extern "C" {
        #[link_name = "\u{1}eofbit"]
        pub static ios_base_eofbit: root::std::ios_base_iostate;
    }
    extern "C" {
        #[link_name = "\u{1}failbit"]
        pub static ios_base_failbit: root::std::ios_base_iostate;
    }
    extern "C" {
        #[link_name = "\u{1}goodbit"]
        pub static ios_base_goodbit: root::std::ios_base_iostate;
    }
    extern "C" {
        #[link_name = "\u{1}app"]
        pub static ios_base_app: root::std::ios_base_openmode;
    }
    extern "C" {
        #[link_name = "\u{1}ate"]
        pub static ios_base_ate: root::std::ios_base_openmode;
    }
    extern "C" {
        #[link_name = "\u{1}binary"]
        pub static ios_base_binary: root::std::ios_base_openmode;
    }
    extern "C" {
        #[link_name = "\u{1}in"]
        pub static ios_base_in: root::std::ios_base_openmode;
    }
    extern "C" {
        #[link_name = "\u{1}out"]
        pub static ios_base_out: root::std::ios_base_openmode;
    }
    extern "C" {
        #[link_name = "\u{1}trunc"]
        pub static ios_base_trunc: root::std::ios_base_openmode;
    }
    extern "C" {
        #[link_name = "\u{1}beg"]
        pub static ios_base_beg: root::std::ios_base_seekdir;
    }
    extern "C" {
        #[link_name = "\u{1}cur"]
        pub static ios_base_cur: root::std::ios_base_seekdir;
    }
    extern "C" {
        #[link_name = "\u{1}end"]
        pub static ios_base_end: root::std::ios_base_seekdir;
    }
    // #[test]
    // fn bindgen_test_layout_ios_base() {
    //     assert_eq!(
    //         ::std::mem::size_of::<ios_base>(),
    //         216usize,
    //         concat!("Size of: ", stringify!(ios_base))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<ios_base>(),
    //         8usize,
    //         concat!("Alignment of ", stringify!(ios_base))
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_precision as *const _ as usize },
    //         8usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_precision)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_width as *const _ as usize },
    //         16usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_width)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_flags as *const _ as usize },
    //         24usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_flags)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_exception as *const _ as usize },
    //         28usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_exception)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe {
    //             &(*(::std::ptr::null::<ios_base>()))._M_streambuf_state as *const _ as usize
    //         },
    //         32usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_streambuf_state)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_callbacks as *const _ as usize },
    //         40usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_callbacks)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_zero as *const _ as usize },
    //         48usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_word_zero)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_local_word as *const _ as usize },
    //         64usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_local_word)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_size as *const _ as usize },
    //         192usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_word_size)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word as *const _ as usize },
    //         200usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_word)
    //         )
    //     );
    //     assert_eq!(
    //         unsafe { &(*(::std::ptr::null::<ios_base>()))._M_ios_locale as *const _ as usize },
    //         208usize,
    //         concat!(
    //             "Offset of field: ",
    //             stringify!(ios_base),
    //             "::",
    //             stringify!(_M_ios_locale)
    //         )
    //     );
    // }
    extern "C" {
        #[link_name = "\u{1}register_callback"]
        pub fn ios_base_register_callback(
            this: *mut root::std::ios_base,
            __fn: root::std::ios_base_event_callback,
            __index: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_M_call_callbacks"]
        pub fn ios_base__M_call_callbacks(
            this: *mut root::std::ios_base,
            __ev: root::std::ios_base_event,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_M_dispose_callbacks"]
        pub fn ios_base__M_dispose_callbacks(this: *mut root::std::ios_base);
    }
    extern "C" {
        #[link_name = "\u{1}_M_grow_words"]
        pub fn ios_base__M_grow_words(
            this: *mut root::std::ios_base,
            __index: ::std::os::raw::c_int,
            __iword: bool,
        ) -> *mut root::std::ios_base__Words;
    }
    extern "C" {
        #[link_name = "\u{1}_M_init"]
        pub fn ios_base__M_init(this: *mut root::std::ios_base);
    }
    extern "C" {
        #[link_name = "\u{1}sync_with_stdio"]
        pub fn ios_base_sync_with_stdio(__sync: bool) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}imbue"]
        pub fn ios_base_imbue(
            this: *mut root::std::ios_base,
            __loc: *const root::std::locale,
        ) -> root::std::locale;
    }
    extern "C" {
        #[link_name = "\u{1}xalloc"]
        pub fn ios_base_xalloc() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_M_move"]
        pub fn ios_base__M_move(this: *mut root::std::ios_base, arg1: *mut root::std::ios_base);
    }
    extern "C" {
        #[link_name = "\u{1}_M_swap"]
        pub fn ios_base__M_swap(this: *mut root::std::ios_base, __rhs: *mut root::std::ios_base);
    }
    extern "C" {
        #[link_name = "\u{1}ios_base"]
        pub fn ios_base_ios_base(this: *mut root::std::ios_base);
    }
    impl Default for ios_base {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl ios_base {
        #[inline]
        pub unsafe fn register_callback(
            &mut self,
            __fn: root::std::ios_base_event_callback,
            __index: ::std::os::raw::c_int,
        ) {
            ios_base_register_callback(self, __fn, __index)
        }
        #[inline]
        pub unsafe fn _M_call_callbacks(&mut self, __ev: root::std::ios_base_event) {
            ios_base__M_call_callbacks(self, __ev)
        }
        #[inline]
        pub unsafe fn _M_dispose_callbacks(&mut self) {
            ios_base__M_dispose_callbacks(self)
        }
        #[inline]
        pub unsafe fn _M_grow_words(
            &mut self,
            __index: ::std::os::raw::c_int,
            __iword: bool,
        ) -> *mut root::std::ios_base__Words {
            ios_base__M_grow_words(self, __index, __iword)
        }
        #[inline]
        pub unsafe fn _M_init(&mut self) {
            ios_base__M_init(self)
        }
        #[inline]
        pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
            ios_base_sync_with_stdio(__sync)
        }
        #[inline]
        pub unsafe fn imbue(&mut self, __loc: *const root::std::locale) -> root::std::locale {
            ios_base_imbue(self, __loc)
        }
        #[inline]
        pub unsafe fn xalloc() -> ::std::os::raw::c_int {
            ios_base_xalloc()
        }
        #[inline]
        pub unsafe fn _M_move(&mut self, arg1: *mut root::std::ios_base) {
            ios_base__M_move(self, arg1)
        }
        #[inline]
        pub unsafe fn _M_swap(&mut self, __rhs: *mut root::std::ios_base) {
            ios_base__M_swap(self, __rhs)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            ios_base_ios_base(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}failure_destructor"]
        pub fn ios_base_failure_failure_destructor(this: *mut root::std::ios_base_failure);
    }
    extern "C" {
        #[link_name = "\u{1}what"]
        pub fn ios_base_failure_what(
            this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}ios_base_destructor"]
        pub fn ios_base_ios_base_destructor(this: *mut root::std::ios_base);
    }
    #[repr(C)]
    pub struct basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_streambuf<_CharT> {
        pub vtable_: *const basic_streambuf__bindgen_vtable,
        pub _M_in_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
        pub _M_in_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
        pub _M_in_end: *mut root::std::basic_streambuf_char_type<_CharT>,
        pub _M_out_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
        pub _M_out_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
        pub _M_out_end: *mut root::std::basic_streambuf_char_type<_CharT>,
        pub _M_buf_locale: root::std::locale,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type basic_streambuf_char_type<_CharT> = _CharT;
    pub type basic_streambuf_traits_type<_Traits> = _Traits;
    pub type basic_streambuf_int_type = [u8; 0usize];
    pub type basic_streambuf_pos_type = [u8; 0usize];
    pub type basic_streambuf_off_type = [u8; 0usize];
    pub type basic_streambuf___streambuf_type<_CharT> =
        root::std::basic_streambuf<root::std::basic_streambuf_char_type<_CharT>>;
    impl<_CharT> Default for basic_streambuf<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ctype_base {
        pub _address: u8,
    }
    pub type ctype_base___to_type = *const ::std::os::raw::c_int;
    pub type ctype_base_mask = ::std::os::raw::c_ushort;
    pub const ctype_base_upper: root::std::ctype_base_mask = 256;
    pub const ctype_base_lower: root::std::ctype_base_mask = 512;
    pub const ctype_base_alpha: root::std::ctype_base_mask = 1024;
    pub const ctype_base_digit: root::std::ctype_base_mask = 2048;
    pub const ctype_base_xdigit: root::std::ctype_base_mask = 4096;
    pub const ctype_base_space: root::std::ctype_base_mask = 8192;
    pub const ctype_base_print: root::std::ctype_base_mask = 16384;
    pub const ctype_base_graph: root::std::ctype_base_mask = 3076;
    pub const ctype_base_cntrl: root::std::ctype_base_mask = 2;
    pub const ctype_base_punct: root::std::ctype_base_mask = 4;
    pub const ctype_base_alnum: root::std::ctype_base_mask = 3072;
    pub const ctype_base_blank: root::std::ctype_base_mask = 1;
    // #[test]
    // fn bindgen_test_layout_ctype_base() {
    //     assert_eq!(
    //         ::std::mem::size_of::<ctype_base>(),
    //         1usize,
    //         concat!("Size of: ", stringify!(ctype_base))
    //     );
    //     assert_eq!(
    //         ::std::mem::align_of::<ctype_base>(),
    //         1usize,
    //         concat!("Alignment of ", stringify!(ctype_base))
    //     );
    // }
    #[repr(C)]
    pub struct istreambuf_iterator<_CharT> {
        pub _M_sbuf: *mut root::std::istreambuf_iterator_streambuf_type<_CharT>,
        pub _M_c: root::std::istreambuf_iterator_int_type,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type istreambuf_iterator_char_type<_CharT> = _CharT;
    pub type istreambuf_iterator_traits_type<_Traits> = _Traits;
    pub type istreambuf_iterator_int_type = [u8; 0usize];
    pub type istreambuf_iterator_streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
    pub type istreambuf_iterator_istream_type<_CharT> = root::std::basic_istream<_CharT>;
    impl<_CharT> Default for istreambuf_iterator<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    impl<_CharT> ::std::fmt::Debug for istreambuf_iterator<_CharT> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "istreambuf_iterator {{ _M_sbuf: {:?} }}", self._M_sbuf)
        }
    }
    impl<_CharT> PartialEq for istreambuf_iterator<_CharT>
    where
        _CharT: PartialEq,
    {
        fn eq(&self, other: &istreambuf_iterator<_CharT>) -> bool {
            self._M_sbuf == other._M_sbuf && self._M_c == other._M_c
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ostreambuf_iterator<_CharT> {
        pub _M_sbuf: *mut root::std::ostreambuf_iterator_streambuf_type<_CharT>,
        pub _M_failed: bool,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type ostreambuf_iterator_char_type<_CharT> = _CharT;
    pub type ostreambuf_iterator_traits_type<_Traits> = _Traits;
    pub type ostreambuf_iterator_streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
    pub type ostreambuf_iterator_ostream_type<_CharT> = root::std::basic_ostream<_CharT>;
    impl<_CharT> Default for ostreambuf_iterator<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __ctype_abstract_base {
        pub _base: root::std::locale_facet,
    }
    pub type __ctype_abstract_base_char_type<_CharT> = _CharT;
    impl Default for __ctype_abstract_base {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct ctype {
        pub _base: root::std::__ctype_abstract_base,
    }
    pub type ctype_char_type<_CharT> = _CharT;
    pub type ctype_mask = root::std::__ctype_abstract_base;
    impl Default for ctype {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct num_get {
        pub _base: root::std::locale_facet,
    }
    pub type num_get_char_type<_CharT> = _CharT;
    pub type num_get_iter_type<_InIter> = _InIter;
    impl Default for num_get {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct num_put {
        pub _base: root::std::locale_facet,
    }
    pub type num_put_char_type<_CharT> = _CharT;
    pub type num_put_iter_type<_OutIter> = _OutIter;
    impl Default for num_put {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_ios<_CharT> {
        pub _base: root::std::ios_base,
        pub _M_tie: *mut root::std::basic_ostream<_CharT>,
        pub _M_fill: root::std::basic_ios_char_type<_CharT>,
        pub _M_fill_init: bool,
        pub _M_streambuf: *mut root::std::basic_streambuf<_CharT>,
        pub _M_ctype: *const root::std::basic_ios___ctype_type,
        pub _M_num_put: *const root::std::basic_ios___num_put_type,
        pub _M_num_get: *const root::std::basic_ios___num_get_type,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type basic_ios_char_type<_CharT> = _CharT;
    pub type basic_ios_int_type = [u8; 0usize];
    pub type basic_ios_pos_type = [u8; 0usize];
    pub type basic_ios_off_type = [u8; 0usize];
    pub type basic_ios_traits_type<_Traits> = _Traits;
    pub type basic_ios___ctype_type = root::std::ctype;
    pub type basic_ios___num_put_type = root::std::num_put;
    pub type basic_ios___num_get_type = root::std::num_get;
    impl<_CharT> Default for basic_ios<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_ostream<_CharT> {
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type basic_ostream_char_type<_CharT> = _CharT;
    pub type basic_ostream_int_type = [u8; 0usize];
    pub type basic_ostream_pos_type = [u8; 0usize];
    pub type basic_ostream_off_type = [u8; 0usize];
    pub type basic_ostream_traits_type<_Traits> = _Traits;
    pub type basic_ostream___streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
    pub type basic_ostream___ios_type<_CharT> = root::std::basic_ios<_CharT>;
    pub type basic_ostream___ostream_type<_CharT> = root::std::basic_ostream<_CharT>;
    pub type basic_ostream___num_put_type = root::std::num_put;
    pub type basic_ostream___ctype_type = root::std::ctype;
    impl<_CharT> Default for basic_ostream<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_ostream_sentry {
        pub _M_ok: bool,
        pub _M_os: *mut root::std::basic_ostream<_CharT>,
    }
    impl Default for basic_ostream_sentry {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_istream<_CharT> {
        pub _M_gcount: root::std::streamsize,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type basic_istream_char_type<_CharT> = _CharT;
    pub type basic_istream_int_type = [u8; 0usize];
    pub type basic_istream_pos_type = [u8; 0usize];
    pub type basic_istream_off_type = [u8; 0usize];
    pub type basic_istream_traits_type<_Traits> = _Traits;
    pub type basic_istream___streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
    pub type basic_istream___ios_type<_CharT> = root::std::basic_ios<_CharT>;
    pub type basic_istream___istream_type<_CharT> = root::std::basic_istream<_CharT>;
    pub type basic_istream___num_get_type = root::std::num_get;
    pub type basic_istream___ctype_type = root::std::ctype;
    impl<_CharT> Default for basic_istream<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_istream_sentry {
        pub _M_ok: bool,
    }
    pub type basic_istream_sentry_traits_type = _Traits;
    pub type basic_istream_sentry___streambuf_type = root::std::basic_streambuf<_CharT>;
    pub type basic_istream_sentry___istream_type = root::std::basic_istream<_CharT>;
    pub type basic_istream_sentry___ctype_type = root::std::basic_istream___ctype_type;
    pub type basic_istream_sentry___int_type = [u8; 0usize];
    #[repr(C)]
    #[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct basic_iostream<_CharT> {
        pub _base: root::std::basic_istream<_CharT>,
        pub _base_1: root::std::basic_ostream<_CharT>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    }
    pub type basic_iostream_char_type<_CharT> = _CharT;
    pub type basic_iostream_int_type = [u8; 0usize];
    pub type basic_iostream_pos_type = [u8; 0usize];
    pub type basic_iostream_off_type = [u8; 0usize];
    pub type basic_iostream_traits_type<_Traits> = _Traits;
    pub type basic_iostream___istream_type<_CharT> = root::std::basic_istream<_CharT>;
    pub type basic_iostream___ostream_type<_CharT> = root::std::basic_ostream<_CharT>;
    impl<_CharT> Default for basic_iostream<_CharT> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
}
pub mod __gnu_cxx {

    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __normal_iterator<_Iterator> {
        pub _M_current: _Iterator,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    }
    pub type __normal_iterator___traits_type = root::std::iterator_traits;
    pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
    pub type __normal_iterator_iterator_category = root::__gnu_cxx::__normal_iterator___traits_type;
    pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
    pub type __normal_iterator_difference_type = root::__gnu_cxx::__normal_iterator___traits_type;
    pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
    pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
    impl<_Iterator> Default for __normal_iterator<_Iterator> {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct _Char_types {
        pub _address: u8,
    }
    pub type _Char_types_int_type = ::std::os::raw::c_ulong;
    pub type _Char_types_pos_type = root::std::streampos;
    pub type _Char_types_off_type = root::std::streamoff;
    pub type _Char_types_state_type = root::mbstate_t;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct char_traits {
        pub _address: u8,
    }
    pub type char_traits_char_type<_CharT> = _CharT;
    pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
    pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
    pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
    pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    #[repr(C)]
    #[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct new_allocator {
        pub _address: u8,
    }
    pub type new_allocator_size_type = usize;
    pub type new_allocator_difference_type = isize;
    pub type new_allocator_pointer<_Tp> = *mut _Tp;
    pub type new_allocator_const_pointer<_Tp> = *const _Tp;
    pub type new_allocator_reference<_Tp> = *mut _Tp;
    pub type new_allocator_const_reference<_Tp> = *const _Tp;
    pub type new_allocator_value_type<_Tp> = _Tp;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct new_allocator_rebind {
        pub _address: u8,
    }
    pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
    pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __alloc_traits {
        pub _address: u8,
    }
    pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
    pub type __alloc_traits__Base_type = root::std::allocator_traits;
    pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
    pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
    pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
    pub type __alloc_traits___is_custom_pointer = root::std::__and_;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
    pub struct __alloc_traits_rebind {
        pub _address: u8,
    }
    pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
    impl Default for __alloc_traits {
        fn default() -> Self {
            unsafe { ::std::mem::zeroed() }
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __locale_struct {
    pub __locales: [*mut root::__locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
// #[test]
// fn bindgen_test_layout___locale_struct() {
//     assert_eq!(
//         ::std::mem::size_of::<__locale_struct>(),
//         232usize,
//         concat!("Size of: ", stringify!(__locale_struct))
//     );
//     assert_eq!(
//         ::std::mem::align_of::<__locale_struct>(),
//         8usize,
//         concat!("Alignment of ", stringify!(__locale_struct))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__locale_struct),
//             "::",
//             stringify!(__locales)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
//         104usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__locale_struct),
//             "::",
//             stringify!(__ctype_b)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
//         },
//         112usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__locale_struct),
//             "::",
//             stringify!(__ctype_tolower)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
//         },
//         120usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__locale_struct),
//             "::",
//             stringify!(__ctype_toupper)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
//         128usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__locale_struct),
//             "::",
//             stringify!(__names)
//         )
//     );
// }
impl Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __locale_t = *mut root::__locale_struct;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type pthread_once_t = ::std::os::raw::c_int;
pub type c_constr = *const ::std::os::raw::c_char;
pub type __gnuc_va_list = root::__builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: root::__mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
// #[test]
// fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
//     assert_eq!(
//         ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
//         4usize,
//         concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
//     );
//     assert_eq!(
//         ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
//         4usize,
//         concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__mbstate_t__bindgen_ty_1),
//             "::",
//             stringify!(__wch)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
//         },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__mbstate_t__bindgen_ty_1),
//             "::",
//             stringify!(__wchb)
//         )
//     );
// }
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
// #[test]
// fn bindgen_test_layout___mbstate_t() {
//     assert_eq!(
//         ::std::mem::size_of::<__mbstate_t>(),
//         8usize,
//         concat!("Size of: ", stringify!(__mbstate_t))
//     );
//     assert_eq!(
//         ::std::mem::align_of::<__mbstate_t>(),
//         4usize,
//         concat!("Alignment of ", stringify!(__mbstate_t))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__mbstate_t),
//             "::",
//             stringify!(__count)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
//         4usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__mbstate_t),
//             "::",
//             stringify!(__value)
//         )
//     );
// }
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
pub type FILE = root::_IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut root::_IO_marker,
    pub _chain: *mut root::_IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: root::__off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut root::_IO_lock_t,
    pub _offset: root::__off64_t,
    pub _codecvt: *mut root::_IO_codecvt,
    pub _wide_data: *mut root::_IO_wide_data,
    pub _freeres_list: *mut root::_IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
// #[test]
// fn bindgen_test_layout__IO_FILE() {
//     assert_eq!(
//         ::std::mem::size_of::<_IO_FILE>(),
//         216usize,
//         concat!("Size of: ", stringify!(_IO_FILE))
//     );
//     assert_eq!(
//         ::std::mem::align_of::<_IO_FILE>(),
//         8usize,
//         concat!("Alignment of ", stringify!(_IO_FILE))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_flags)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_read_ptr)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
//         16usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_read_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
//         24usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_read_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
//         32usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_write_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
//         40usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_write_ptr)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
//         48usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_write_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
//         56usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_buf_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
//         64usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_buf_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
//         72usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_save_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
//         80usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_backup_base)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
//         88usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_IO_save_end)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
//         96usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_markers)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
//         104usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_chain)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
//         112usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_fileno)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
//         116usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_flags2)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
//         120usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_old_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
//         128usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_cur_column)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
//         130usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_vtable_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
//         131usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_shortbuf)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
//         136usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_lock)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
//         144usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
//         152usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_codecvt)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
//         160usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_wide_data)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
//         168usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_freeres_list)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
//         176usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_freeres_buf)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
//         184usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(__pad5)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
//         192usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_mode)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
//         196usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(_IO_FILE),
//             "::",
//             stringify!(_unused2)
//         )
//     );
// }
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type va_list = root::__gnuc_va_list;
extern "C" {
    pub fn EM_newline();
}
extern "C" {
    pub fn ck_fprintf_stdout(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ck_fprintf_stderr(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ck_fflush_stdout();
}
extern "C" {
    pub fn ck_fflush_stderr();
}
extern "C" {
    pub fn ck_vfprintf_stdout(
        format: *const ::std::os::raw::c_char,
        args: *mut root::__va_list_tag,
    );
}
extern "C" {
    pub fn ck_vfprintf_stderr(
        format: *const ::std::os::raw::c_char,
        args: *mut root::__va_list_tag,
    );
}
extern "C" {
    pub fn ck_set_stdout_callback(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn ck_set_stderr_callback(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
pub type mbstate_t = root::__mbstate_t;
pub type __gthread_once_t = root::pthread_once_t;
pub type _Atomic_word = ::std::os::raw::c_int;
#[repr(C)]
pub struct ChuckOutStream {
    pub m_stream: root::std::stringstream,
    pub m_callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    pub m_isErr: bool,
}
// #[test]
// fn bindgen_test_layout_ChuckOutStream() {
//     assert_eq!(
//         ::std::mem::size_of::<ChuckOutStream>(),
//         408usize,
//         concat!("Size of: ", stringify!(ChuckOutStream))
//     );
//     assert_eq!(
//         ::std::mem::align_of::<ChuckOutStream>(),
//         8usize,
//         concat!("Alignment of ", stringify!(ChuckOutStream))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<ChuckOutStream>())).m_stream as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(ChuckOutStream),
//             "::",
//             stringify!(m_stream)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<ChuckOutStream>())).m_callback as *const _ as usize },
//         392usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(ChuckOutStream),
//             "::",
//             stringify!(m_callback)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<ChuckOutStream>())).m_isErr as *const _ as usize },
//         400usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(ChuckOutStream),
//             "::",
//             stringify!(m_isErr)
//         )
//     );
// }
extern "C" {
    #[link_name = "\u{1}set_callback"]
    pub fn ChuckOutStream_set_callback(
        this: *mut root::ChuckOutStream,
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    #[link_name = "\u{1}ChuckOutStream"]
    pub fn ChuckOutStream_ChuckOutStream(this: *mut root::ChuckOutStream, isErr: bool);
}
extern "C" {
    #[link_name = "\u{1}ChuckOutStream_destructor"]
    pub fn ChuckOutStream_ChuckOutStream_destructor(this: *mut root::ChuckOutStream);
}
impl Default for ChuckOutStream {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ChuckOutStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ChuckOutStream {{ m_stream: {:?}, m_callback: {:?}, m_isErr: {:?} }}",
            self.m_stream, self.m_callback, self.m_isErr
        )
    }
}
impl ChuckOutStream {
    #[inline]
    pub unsafe fn set_callback(
        &mut self,
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    ) {
        ChuckOutStream_set_callback(self, callback)
    }
    #[inline]
    pub unsafe fn new(isErr: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        ChuckOutStream_ChuckOutStream(&mut __bindgen_tmp, isErr);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ChuckOutStream_ChuckOutStream_destructor(self)
    }
}
extern "C" {
    pub fn EM_log(arg1: ::std::os::raw::c_long, arg2: root::c_constr, ...);
}
extern "C" {
    pub fn EM_setlog(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn EM_pushlog();
}
extern "C" {
    pub fn EM_poplog();
}
extern "C" {
    pub fn EM_error(arg1: ::std::os::raw::c_int, arg2: root::c_constr, ...);
}
extern "C" {
    pub fn EM_error2(arg1: ::std::os::raw::c_int, arg2: root::c_constr, ...);
}
extern "C" {
    pub fn EM_error2b(arg1: ::std::os::raw::c_int, arg2: root::c_constr, ...);
}
extern "C" {
    pub fn EM_error3(arg1: root::c_constr, ...);
}
extern "C" {
    pub fn EM_impossible(arg1: root::c_constr, ...);
}
extern "C" {
    pub fn EM_reset(filename: root::c_constr, fd: *mut root::FILE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EM_change_file(filename: root::c_constr);
}
extern "C" {
    pub fn EM_lasterror() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EM_reset_msg();
}
extern "C" {
    pub fn mini(str: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mini_type(str: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [self::__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
// #[test]
// fn bindgen_test_layout___va_list_tag() {
//     assert_eq!(
//         ::std::mem::size_of::<__va_list_tag>(),
//         24usize,
//         concat!("Size of: ", stringify!(__va_list_tag))
//     );
//     assert_eq!(
//         ::std::mem::align_of::<__va_list_tag>(),
//         8usize,
//         concat!("Alignment of ", stringify!(__va_list_tag))
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
//         0usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__va_list_tag),
//             "::",
//             stringify!(gp_offset)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
//         4usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__va_list_tag),
//             "::",
//             stringify!(fp_offset)
//         )
//     );
//     assert_eq!(
//         unsafe {
//             &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
//         },
//         8usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__va_list_tag),
//             "::",
//             stringify!(overflow_arg_area)
//         )
//     );
//     assert_eq!(
//         unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
//         16usize,
//         concat!(
//             "Offset of field: ",
//             stringify!(__va_list_tag),
//             "::",
//             stringify!(reg_save_area)
//         )
//     );
// }
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
// #[test]
// fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
// ) {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::__cxx11::basic_string<::std::os::raw::c_char>>(),
//         32usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::__cxx11::basic_string<::std::os::raw::c_char>)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::__cxx11::basic_string<::std::os::raw::c_char>>(),
//         8usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::__cxx11::basic_string<::std::os::raw::c_char>)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::char_traits>(),
//         1usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::char_traits)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::char_traits>(),
//         1usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::char_traits)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::allocator>(),
//         1usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::allocator)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::allocator>(),
//         1usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::allocator)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_basic_stringstream_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
// ) {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::__cxx11::basic_stringstream<::std::os::raw::c_char>>(),
//         392usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::__cxx11::basic_stringstream<::std::os::raw::c_char>)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::__cxx11::basic_stringstream<::std::os::raw::c_char>>(
//         ),
//         8usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::__cxx11::basic_stringstream<::std::os::raw::c_char>)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_1() {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::char_traits>(),
//         1usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::char_traits)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::char_traits>(),
//         1usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::char_traits)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_allocator_open0_char_close0_instantiation_1() {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::allocator>(),
//         1usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::allocator)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::allocator>(),
//         1usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::allocator)
//         )
//     );
// }
// #[test]
// fn __bindgen_test_layout_iterator_open0_output_iterator_tag_void_void_void_void_close0_instantiation(
// ) {
//     assert_eq!(
//         ::std::mem::size_of::<root::std::iterator>(),
//         1usize,
//         concat!(
//             "Size of template specialization: ",
//             stringify!(root::std::iterator)
//         )
//     );
//     assert_eq!(
//         ::std::mem::align_of::<root::std::iterator>(),
//         1usize,
//         concat!(
//             "Alignment of template specialization: ",
//             stringify!(root::std::iterator)
//         )
//     );
// }
