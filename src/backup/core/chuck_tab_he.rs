#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 8;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 0;
pub const __clang_version__ : & 'static [ u8 ; 165usize ] = b"8.0.0 (https://github.com/llvm-mirror/clang 27ff8dcc77fd7c9f1bcf181b25eaa7d68777fdfe) (https://github.com/llvm-mirror/llvm 718039ebb75d709b91dcc3ca18eddedb283892fd)\0" ;
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__ : & 'static [ u8 ; 188usize ] = b"4.2.1 Compatible Clang 8.0.0 (https://github.com/llvm-mirror/clang 27ff8dcc77fd7c9f1bcf181b25eaa7d68777fdfe) (https://github.com/llvm-mirror/llvm 718039ebb75d709b91dcc3ca18eddedb283892fd)\0" ;
pub const __STRICT_ANSI__: u32 = 1;
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __OPTIMIZE__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __PIC__: u32 = 2;
pub const __pic__: u32 = 2;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __SSP_STRONG__: u32 = 2;
pub const __code_model_small_: u32 = 1;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __bdver2: u32 = 1;
pub const __bdver2__: u32 = 1;
pub const __tune_bdver2__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __AES__: u32 = 1;
pub const __PCLMUL__: u32 = 1;
pub const __LZCNT__: u32 = 1;
pub const __BMI__: u32 = 1;
pub const __POPCNT__: u32 = 1;
pub const __PRFCHW__: u32 = 1;
pub const __TBM__: u32 = 1;
pub const __XOP__: u32 = 1;
pub const __FMA4__: u32 = 1;
pub const __SSE4A__: u32 = 1;
pub const __FMA__: u32 = 1;
pub const __F16C__: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __XSAVE__: u32 = 1;
pub const __AVX__: u32 = 1;
pub const __SSE4_2__: u32 = 1;
pub const __SSE4_1__: u32 = 1;
pub const __SSSE3__: u32 = 1;
pub const __SSE3__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const HAVE_CONFIG_H: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_LIBPTHREAD: u32 = 1;
pub const ENABLE_THREADS: u32 = 1;
pub const __PLATFORM_LINUX__: u32 = 1;
pub const __LINUX_ALSA__: u32 = 1;
pub const __UNIX_JACK__: u32 = 1;
pub const USE_ALSA: u32 = 1;
pub const USE_DLTRICK_ALSA: u32 = 1;
pub const USE_OSS: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __USE_EXTERN_INLINES: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _MEMORY_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const sz_VOID: u32 = 0;
pub const sz_WORD: u32 = 4;
pub const kindof_VOID: u32 = 0;
pub const kindof_INT: u32 = 1;
pub const kindof_FLOAT: u32 = 2;
pub const kindof_COMPLEX: u32 = 3;
pub const kindof_VEC3: u32 = 4;
pub const kindof_VEC4: u32 = 5;
pub const SILENCE: f64 = 0.0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const ONE_PI: f64 = 3.141592653589793;
pub const TWO_PI: f64 = 6.283185307179586;
pub const SQRT2: f64 = 1.4142135623730951;
pub const __CHUCK_STAT_TRACK__: u32 = 1;
pub const YYDEBUG: u32 = 0;
pub const YYSTYPE_IS_TRIVIAL: u32 = 1;
pub const YYSTYPE_IS_DECLARED: u32 = 1;
pub type wchar_t = c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    pub quot: c_int,
    pub rem: c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: c_long,
    pub rem: c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: c_longlong,
    pub rem: c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const c_char) -> c_int;
}
extern "C" {
    pub fn atol(__nptr: *const c_char) -> c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const c_char) -> c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const c_char, __endptr: *mut *mut c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const c_char, __endptr: *mut *mut c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const c_char, __endptr: *mut *mut c_char) -> u128;
}
extern "C" {
    pub fn strtol(__nptr: *const c_char, __endptr: *mut *mut c_char, __base: c_int) -> c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const c_char, __endptr: *mut *mut c_char, __base: c_int) -> c_ulong;
}
extern "C" {
    pub fn strtoll(__nptr: *const c_char, __endptr: *mut *mut c_char, __base: c_int) -> c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const c_char,
        __endptr: *mut *mut c_char,
        __base: c_int,
    ) -> c_ulonglong;
}
extern "C" {
    pub fn rand() -> c_int;
}
extern "C" {
    pub fn srand(__seed: c_uint);
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut c_void, __size: usize) -> *mut c_void;
}
extern "C" {
    pub fn free(__ptr: *mut c_void);
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> c_int;
}
extern "C" {
    pub fn exit(__status: c_int);
}
extern "C" {
    pub fn quick_exit(__status: c_int);
}
extern "C" {
    pub fn _Exit(__status: c_int);
}
extern "C" {
    pub fn getenv(__name: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn system(__command: *const c_char) -> c_int;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const c_void, arg2: *const c_void) -> c_int>;
extern "C" {
    pub fn bsearch(
        __key: *const c_void,
        __base: *const c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut c_void;
}
extern "C" {
    pub fn qsort(__base: *mut c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: c_int) -> c_int;
}
extern "C" {
    pub fn labs(__x: c_long) -> c_long;
}
extern "C" {
    pub fn llabs(__x: c_longlong) -> c_longlong;
}
extern "C" {
    pub fn div(__numer: c_int, __denom: c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: c_long, __denom: c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: c_longlong, __denom: c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const c_char, __n: usize) -> c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const c_char, __n: usize) -> c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut c_char, __wchar: wchar_t) -> c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn memcpy(__dest: *mut c_void, __src: *const c_void, __n: usize) -> *mut c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut c_void, __src: *const c_void, __n: usize) -> *mut c_void;
}
extern "C" {
    pub fn memset(__s: *mut c_void, __c: c_int, __n: usize) -> *mut c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const c_void, __s2: *const c_void, __n: usize) -> c_int;
}
extern "C" {
    pub fn memchr(__s: *const c_void, __c: c_int, __n: usize) -> *mut c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut c_char, __src: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut c_char, __src: *const c_char, __n: usize) -> *mut c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut c_char, __src: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut c_char, __src: *const c_char, __n: usize) -> *mut c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const c_char, __s2: *const c_char) -> c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const c_char, __s2: *const c_char, __n: usize) -> c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const c_char, __s2: *const c_char) -> c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut c_char, __src: *const c_char, __n: usize) -> c_ulong;
}
extern "C" {
    pub fn strchr(__s: *const c_char, __c: c_int) -> *mut c_char;
}
extern "C" {
    pub fn strrchr(__s: *const c_char, __c: c_int) -> *mut c_char;
}
extern "C" {
    pub fn strcspn(__s: *const c_char, __reject: *const c_char) -> c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const c_char, __accept: *const c_char) -> c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const c_char, __accept: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const c_char, __needle: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn strtok(__s: *mut c_char, __delim: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut c_char,
        __delim: *const c_char,
        __save_ptr: *mut *mut c_char,
    ) -> *mut c_char;
}
extern "C" {
    pub fn strlen(__s: *const c_char) -> c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: c_int) -> *mut c_char;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const c_char,
        __file: *const c_char,
        __line: c_uint,
        __function: *const c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: c_int,
        __file: *const c_char,
        __line: c_uint,
        __function: *const c_char,
    );
}
extern "C" {
    pub fn __assert(__assertion: *const c_char, __file: *const c_char, __line: c_int);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct t_CKCOMPLEX {
    pub re: f64,
    pub im: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct t_CKPOLAR {
    pub modulus: f64,
    pub phase: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct t_CKVEC3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct t_CKVEC4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct t_CKVECTOR {
    pub N: c_ulong,
    pub values: *mut f64,
}
impl Default for t_CKVECTOR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
pub type c_str = *mut c_char;
pub type c_constr = *const c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct t_CKCOMPLEX_SAMPLE {
    pub re: f64,
    pub im: f64,
}
pub type U_boolList = *mut U_boolList_;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct U_boolList_ {
    pub head: c_ulong,
    pub tail: U_boolList,
}
impl Default for U_boolList_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
extern "C" {
    pub fn checked_malloc(size: c_int) -> *mut c_void;
}
extern "C" {
    pub fn cc_str(arg1: *mut c_char) -> c_str;
}
extern "C" {
    pub fn U_BoolList(head: c_ulong, tail: U_boolList) -> U_boolList;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S_Symbol_ {
    _unused: [u8; 0],
}
pub type S_Symbol = *mut S_Symbol_;
extern "C" {
    pub fn insert_symbol(arg1: c_constr) -> S_Symbol;
}
extern "C" {
    pub fn S_name(arg1: S_Symbol) -> c_str;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAB_table_ {
    _unused: [u8; 0],
}
pub type S_table = *mut TAB_table_;
extern "C" {
    pub fn S_empty() -> S_table;
}
extern "C" {
    pub fn S_empty2(size: c_uint) -> S_table;
}
extern "C" {
    pub fn S_enter(t: S_table, sym: S_Symbol, value: *mut c_void);
}
extern "C" {
    pub fn S_enter2(t: S_table, str: c_constr, value: *mut c_void);
}
extern "C" {
    pub fn S_look(t: S_table, sym: S_Symbol) -> *mut c_void;
}
extern "C" {
    pub fn S_look2(t: S_table, str: c_constr) -> *mut c_void;
}
extern "C" {
    pub fn S_beginScope(t: S_table);
}
extern "C" {
    pub fn S_endScope(t: S_table);
}
extern "C" {
    pub fn S_pop(t: S_table);
}
pub type a_Pos = c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Operator {
    ae_op_plus = 0,
    ae_op_minus = 1,
    ae_op_times = 2,
    ae_op_divide = 3,
    ae_op_eq = 4,
    ae_op_neq = 5,
    ae_op_lt = 6,
    ae_op_le = 7,
    ae_op_gt = 8,
    ae_op_ge = 9,
    ae_op_and = 10,
    ae_op_or = 11,
    ae_op_s_or = 12,
    ae_op_s_and = 13,
    ae_op_shift_left = 14,
    ae_op_shift_right = 15,
    ae_op_percent = 16,
    ae_op_s_xor = 17,
    ae_op_chuck = 18,
    ae_op_plus_chuck = 19,
    ae_op_minus_chuck = 20,
    ae_op_times_chuck = 21,
    ae_op_divide_chuck = 22,
    ae_op_s_and_chuck = 23,
    ae_op_s_or_chuck = 24,
    ae_op_s_xor_chuck = 25,
    ae_op_shift_right_chuck = 26,
    ae_op_shift_left_chuck = 27,
    ae_op_percent_chuck = 28,
    ae_op_s_chuck = 29,
    ae_op_plusplus = 30,
    ae_op_minusminus = 31,
    ae_op_tilda = 32,
    ae_op_exclamation = 33,
    ae_op_at_chuck = 34,
    ae_op_unchuck = 35,
    ae_op_upchuck = 36,
    ae_op_spork = 37,
    ae_op_typeof = 38,
    ae_op_sizeof = 39,
    ae_op_new = 40,
    ae_op_arrow_left = 41,
    ae_op_arrow_right = 42,
}
extern "C" {
    pub fn op2str(op: ae_Operator) -> *const c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Keyword {
    ae_key_this = 0,
    ae_key_me = 1,
    ae_key_func = 2,
    ae_key_public = 3,
    ae_key_protected = 4,
    ae_key_private = 5,
    ae_key_static = 6,
    ae_key_instance = 7,
    ae_key_abstract = 8,
}
pub type a_Program = *mut a_Program_;
pub type a_Section = *mut a_Section_;
pub type a_Stmt_List = *mut a_Stmt_List_;
pub type a_Class_Def = *mut a_Class_Def_;
pub type a_Func_Def = *mut a_Func_Def_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct a_Code_Segment_ {
    _unused: [u8; 0],
}
pub type a_Code_Segment = *mut a_Code_Segment_;
pub type a_Stmt = *mut a_Stmt_;
pub type a_Exp = *mut a_Exp_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct a_Exp_Chuck_ {
    _unused: [u8; 0],
}
pub type a_Exp_Chuck = *mut a_Exp_Chuck_;
pub type a_Exp_Binary = *mut a_Exp_Binary_;
pub type a_Exp_Cast = *mut a_Exp_Cast_;
pub type a_Exp_Unary = *mut a_Exp_Unary_;
pub type a_Exp_Postfix = *mut a_Exp_Postfix_;
pub type a_Exp_Primary = *mut a_Exp_Primary_;
pub type a_Exp_Dur = *mut a_Exp_Dur_;
pub type a_Exp_Array = *mut a_Exp_Array_;
pub type a_Exp_Func_Call = *mut a_Exp_Func_Call_;
pub type a_Exp_Dot_Member = *mut a_Exp_Dot_Member_;
pub type a_Exp_If = *mut a_Exp_If_;
pub type a_Exp_Decl = *mut a_Exp_Decl_;
pub type a_Exp_Hack = *mut a_Exp_Hack_;
pub type a_Stmt_Code = *mut a_Stmt_Code_;
pub type a_Stmt_If = *mut a_Stmt_If_;
pub type a_Stmt_While = *mut a_Stmt_While_;
pub type a_Stmt_Until = *mut a_Stmt_Until_;
pub type a_Stmt_For = *mut a_Stmt_For_;
pub type a_Stmt_Loop = *mut a_Stmt_Loop_;
pub type a_Stmt_Switch = *mut a_Stmt_Switch_;
pub type a_Stmt_Break = *mut a_Stmt_Break_;
pub type a_Stmt_Continue = *mut a_Stmt_Continue_;
pub type a_Stmt_Return = *mut a_Stmt_Return_;
pub type a_Stmt_Case = *mut a_Stmt_Case_;
pub type a_Stmt_GotoLabel = *mut a_Stmt_GotoLabel_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct a_Decl_ {
    _unused: [u8; 0],
}
pub type a_Decl = *mut a_Decl_;
pub type a_Var_Decl = *mut a_Var_Decl_;
pub type a_Var_Decl_List = *mut a_Var_Decl_List_;
pub type a_Type_Decl = *mut a_Type_Decl_;
pub type a_Arg_List = *mut a_Arg_List_;
pub type a_Id_List = *mut a_Id_List_;
pub type a_Class_Ext = *mut a_Class_Ext_;
pub type a_Class_Body = *mut a_Class_Body_;
pub type a_Array_Sub = *mut a_Array_Sub_;
pub type a_Complex = *mut a_Complex_;
pub type a_Polar = *mut a_Polar_;
pub type a_Vec = *mut a_Vec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_Type {
    _unused: [u8; 0],
}
pub type t_CKTYPE = *mut Chuck_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_Value {
    _unused: [u8; 0],
}
pub type t_CKVALUE = *mut Chuck_Value;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_Func {
    _unused: [u8; 0],
}
pub type t_CKFUNC = *mut Chuck_Func;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_Namespace {
    _unused: [u8; 0],
}
pub type t_CKNSPC = *mut Chuck_Namespace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chuck_VM_Code {
    _unused: [u8; 0],
}
pub type t_CKVMCODE = *mut Chuck_VM_Code;
extern "C" {
    pub fn new_program(section: a_Section, pos: c_int) -> a_Program;
}
extern "C" {
    pub fn prepend_program(section: a_Section, program: a_Program, pos: c_int) -> a_Program;
}
extern "C" {
    pub fn new_section_stmt(stmt_list: a_Stmt_List, pos: c_int) -> a_Section;
}
extern "C" {
    pub fn new_section_func_def(func_def: a_Func_Def, pos: c_int) -> a_Section;
}
extern "C" {
    pub fn new_section_class_def(class_def: a_Class_Def, pos: c_int) -> a_Section;
}
extern "C" {
    pub fn new_stmt_list(stmt: a_Stmt, pos: c_int) -> a_Stmt_List;
}
extern "C" {
    pub fn prepend_stmt_list(stmt: a_Stmt, stmt_list: a_Stmt_List, pos: c_int) -> a_Stmt_List;
}
extern "C" {
    pub fn new_stmt_from_expression(exp: a_Exp, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_code(code: a_Stmt_List, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_while(cond: a_Exp, body: a_Stmt, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_do_while(cond: a_Exp, body: a_Stmt, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_until(cond: a_Exp, body: a_Stmt, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_do_until(cond: a_Exp, body: a_Stmt, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_for(c1: a_Stmt, c2: a_Stmt, c3: a_Exp, body: a_Stmt, pos: c_int)
        -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_loop(cond: a_Exp, body: a_Stmt, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_if(cond: a_Exp, if_body: a_Stmt, else_body: a_Stmt, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_switch(exp: a_Exp, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_break(pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_continue(pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_return(exp: a_Exp, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_label(xid: c_str, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn new_stmt_from_case(exp: a_Exp, pos: c_int) -> a_Stmt;
}
extern "C" {
    pub fn prepend_expression(exp: a_Exp, list: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_binary(lhs: a_Exp, oper: ae_Operator, rhs: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_unary(oper: ae_Operator, exp: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_unary2(
        oper: ae_Operator,
        type_: a_Type_Decl,
        array: a_Array_Sub,
        pos: c_int,
    ) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_unary3(oper: ae_Operator, code: a_Stmt, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_cast(type_: a_Type_Decl, exp: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_array(base: a_Exp, indices: a_Array_Sub, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_array_lit(exp_list: a_Array_Sub, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_func_call(base: a_Exp, args: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_member_dot(base: a_Exp, member: c_str, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_postfix(base: a_Exp, op: ae_Operator, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_dur(base: a_Exp, unit: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_id(xid: c_str, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_int(num: c_long, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_uint(num: c_ulong, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_float(num: f64, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_str(str: c_str, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_char(chr: c_str, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_if(cond: a_Exp, lhs: a_Exp, rhs: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_complex(arg1: a_Complex, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_polar(arg1: a_Polar, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_vec(arg1: a_Vec, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_decl_external(
        type_decl: a_Type_Decl,
        var_decl_list: a_Var_Decl_List,
        is_static: c_int,
        pos: c_int,
    ) -> a_Exp;
}
extern "C" {
    pub fn new_exp_decl_global(
        type_decl: a_Type_Decl,
        var_decl_list: a_Var_Decl_List,
        is_static: c_int,
        pos: c_int,
    ) -> a_Exp;
}
extern "C" {
    pub fn new_exp_decl(
        type_decl: a_Type_Decl,
        var_decl_list: a_Var_Decl_List,
        is_static: c_int,
        pos: c_int,
    ) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_hack(exp: a_Exp, pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_exp_from_nil(pos: c_int) -> a_Exp;
}
extern "C" {
    pub fn new_var_decl_list(var_decl: a_Var_Decl, pos: c_int) -> a_Var_Decl_List;
}
extern "C" {
    pub fn prepend_var_decl_list(
        var_decl: a_Var_Decl,
        list: a_Var_Decl_List,
        pos: c_int,
    ) -> a_Var_Decl_List;
}
extern "C" {
    pub fn new_var_decl(xid: c_constr, array: a_Array_Sub, pos: c_int) -> a_Var_Decl;
}
extern "C" {
    pub fn new_type_decl(xid: a_Id_List, ref_: c_int, pos: c_int) -> a_Type_Decl;
}
extern "C" {
    pub fn add_type_decl_array(
        type_decl: a_Type_Decl,
        array: a_Array_Sub,
        pos: c_int,
    ) -> a_Type_Decl;
}
extern "C" {
    pub fn new_arg_list(type_decl: a_Type_Decl, var_decl: a_Var_Decl, pos: c_int) -> a_Arg_List;
}
extern "C" {
    pub fn prepend_arg_list(
        type_decl: a_Type_Decl,
        var_decl: a_Var_Decl,
        arg_list: a_Arg_List,
        pos: c_int,
    ) -> a_Arg_List;
}
extern "C" {
    pub fn new_array_sub(exp: a_Exp, pos: c_int) -> a_Array_Sub;
}
extern "C" {
    pub fn prepend_array_sub(array: a_Array_Sub, exp: a_Exp, pos: c_int) -> a_Array_Sub;
}
extern "C" {
    pub fn new_complex(re: a_Exp, pos: c_int) -> a_Complex;
}
extern "C" {
    pub fn new_polar(mod_: a_Exp, pos: c_int) -> a_Polar;
}
extern "C" {
    pub fn new_vec(e: a_Exp, pos: c_int) -> a_Vec;
}
extern "C" {
    pub fn new_class_def(
        class_decl: ae_Keyword,
        xid: a_Id_List,
        ext: a_Class_Ext,
        body: a_Class_Body,
        pos: c_int,
    ) -> a_Class_Def;
}
extern "C" {
    pub fn new_class_body(section: a_Section, pos: c_int) -> a_Class_Body;
}
extern "C" {
    pub fn prepend_class_body(section: a_Section, body: a_Class_Body, pos: c_int) -> a_Class_Body;
}
extern "C" {
    pub fn new_class_ext(extend_id: a_Id_List, impl_list: a_Id_List, pos: c_int) -> a_Class_Ext;
}
extern "C" {
    pub fn new_iface_def(
        class_decl: ae_Keyword,
        xid: a_Id_List,
        ext: a_Class_Ext,
        body: a_Class_Body,
        pos: c_int,
    ) -> a_Class_Def;
}
extern "C" {
    pub fn new_id_list(xid: c_constr, pos: c_int) -> a_Id_List;
}
extern "C" {
    pub fn prepend_id_list(xid: c_constr, list: a_Id_List, pos: c_int) -> a_Id_List;
}
extern "C" {
    pub fn clean_exp(exp: a_Exp);
}
extern "C" {
    pub fn new_func_def(
        func_decl: ae_Keyword,
        static_decl: ae_Keyword,
        type_decl: a_Type_Decl,
        name: c_str,
        arg_list: a_Arg_List,
        code: a_Stmt,
        pos: c_int,
    ) -> a_Func_Def;
}
extern "C" {
    pub fn delete_id_list(x: a_Id_List);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Binary_ {
    pub lhs: a_Exp,
    pub op: ae_Operator,
    pub rhs: a_Exp,
    pub ck_func: t_CKFUNC,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Binary_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Cast_ {
    pub type_: a_Type_Decl,
    pub exp: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Cast_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Unary_ {
    pub op: ae_Operator,
    pub exp: a_Exp,
    pub type_: a_Type_Decl,
    pub array: a_Array_Sub,
    pub code: a_Stmt,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Unary_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Postfix_ {
    pub exp: a_Exp,
    pub op: ae_Operator,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Postfix_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Dur_ {
    pub base: a_Exp,
    pub unit: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Dur_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Array_ {
    pub base: a_Exp,
    pub indices: a_Array_Sub,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Array_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Func_Call_ {
    pub func: a_Exp,
    pub args: a_Exp,
    pub ret_type: t_CKTYPE,
    pub ck_func: t_CKFUNC,
    pub ck_vm_code: t_CKVMCODE,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Func_Call_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Dot_Member_ {
    pub base: a_Exp,
    pub t_base: t_CKTYPE,
    pub xid: S_Symbol,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Dot_Member_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_If_ {
    pub cond: a_Exp,
    pub if_exp: a_Exp,
    pub else_exp: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_If_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Decl_ {
    pub type_: a_Type_Decl,
    pub var_decl_list: a_Var_Decl_List,
    pub num_var_decls: c_int,
    pub is_static: c_int,
    pub is_global: c_int,
    pub ck_type: t_CKTYPE,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Decl_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Exp_Hack_ {
    pub exp: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Exp_Hack_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Var_Decl_List_ {
    pub var_decl: a_Var_Decl,
    pub next: a_Var_Decl_List,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Var_Decl_List_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Var_Decl_ {
    pub xid: S_Symbol,
    pub var_decl: a_Var_Decl,
    pub array: a_Array_Sub,
    pub value: t_CKVALUE,
    pub addr: *mut c_void,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Var_Decl_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Type_Decl_ {
    pub xid: a_Id_List,
    pub array: a_Array_Sub,
    pub ref_: c_int,
    pub linepos: c_int,
}
impl Default for a_Type_Decl_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Array_Sub_ {
    pub depth: c_ulong,
    pub exp_list: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
    pub err_num: c_int,
    pub err_pos: c_int,
}
impl Default for a_Array_Sub_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Arg_List_ {
    pub type_decl: a_Type_Decl,
    pub var_decl: a_Var_Decl,
    pub type_: t_CKTYPE,
    pub next: a_Arg_List,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Arg_List_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Complex_ {
    pub re: a_Exp,
    pub im: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Complex_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Polar_ {
    pub mod_: a_Exp,
    pub phase: a_Exp,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Polar_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Vec_ {
    pub args: a_Exp,
    pub numdims: c_int,
    pub linepos: c_int,
    pub self_: a_Exp,
}
impl Default for a_Vec_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Exp_Primary_Type {
    ae_primary_var = 0,
    ae_primary_num = 1,
    ae_primary_float = 2,
    ae_primary_str = 3,
    ae_primary_array = 4,
    ae_primary_exp = 5,
    ae_primary_hack = 6,
    ae_primary_complex = 7,
    ae_primary_polar = 8,
    ae_primary_vec = 9,
    ae_primary_char = 10,
    ae_primary_nil = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct a_Exp_Primary_ {
    pub s_type: ae_Exp_Primary_Type,
    pub value: t_CKVALUE,
    pub __bindgen_anon_1: a_Exp_Primary___bindgen_ty_1,
    pub linepos: c_int,
    pub self_: a_Exp,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union a_Exp_Primary___bindgen_ty_1 {
    pub var: S_Symbol,
    pub num: c_long,
    pub fnum: f64,
    pub str: c_str,
    pub chr: c_str,
    pub array: a_Array_Sub,
    pub exp: a_Exp,
    pub complex: a_Complex,
    pub polar: a_Polar,
    pub vec: a_Vec,
    _bindgen_union_align: u64,
}
impl Default for a_Exp_Primary___bindgen_ty_1 {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Exp_Primary___bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "a_Exp_Primary___bindgen_ty_1 {{ union }}")
    }
}
impl Default for a_Exp_Primary_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Exp_Primary_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "a_Exp_Primary_ {{ s_type: {:?}, value: {:?}, __bindgen_anon_1: {:?}, linepos: {:?}, self: {:?} }}" , self . s_type , self . value , self . __bindgen_anon_1 , self . linepos , self . self_ )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Exp_Type {
    ae_exp_binary = 0,
    ae_exp_unary = 1,
    ae_exp_cast = 2,
    ae_exp_postfix = 3,
    ae_exp_dur = 4,
    ae_exp_primary = 5,
    ae_exp_array = 6,
    ae_exp_func_call = 7,
    ae_exp_dot_member = 8,
    ae_exp_if = 9,
    ae_exp_decl = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Exp_Meta {
    ae_meta_value = 0,
    ae_meta_var = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct a_Exp_ {
    pub s_type: ae_Exp_Type,
    pub s_meta: ae_Exp_Meta,
    pub type_: t_CKTYPE,
    pub owner: t_CKNSPC,
    pub next: a_Exp,
    pub group_size: c_ulong,
    pub cast_to: t_CKTYPE,
    pub emit_var: c_ulong,
    pub __bindgen_anon_1: a_Exp___bindgen_ty_1,
    pub linepos: c_int,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union a_Exp___bindgen_ty_1 {
    pub binary: a_Exp_Binary_,
    pub unary: a_Exp_Unary_,
    pub cast: a_Exp_Cast_,
    pub postfix: a_Exp_Postfix_,
    pub dur: a_Exp_Dur_,
    pub primary: a_Exp_Primary_,
    pub array: a_Exp_Array_,
    pub func_call: a_Exp_Func_Call_,
    pub dot_member: a_Exp_Dot_Member_,
    pub exp_if: a_Exp_If_,
    pub decl: a_Exp_Decl_,
    _bindgen_union_align: [u64; 7usize],
}
impl Default for a_Exp___bindgen_ty_1 {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Exp___bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "a_Exp___bindgen_ty_1 {{ union }}")
    }
}
impl Default for a_Exp_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Exp_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "a_Exp_ {{ s_type: {:?}, s_meta: {:?}, type: {:?}, owner: {:?}, next: {:?}, group_size: {:?}, cast_to: {:?}, emit_var: {:?}, __bindgen_anon_1: {:?}, linepos: {:?} }}" , self . s_type , self . s_meta , self . type_ , self . owner , self . next , self . group_size , self . cast_to , self . emit_var , self . __bindgen_anon_1 , self . linepos )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_While_ {
    pub is_do: c_int,
    pub cond: a_Exp,
    pub body: a_Stmt,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_While_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Until_ {
    pub is_do: c_int,
    pub cond: a_Exp,
    pub body: a_Stmt,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Until_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_For_ {
    pub c1: a_Stmt,
    pub c2: a_Stmt,
    pub c3: a_Exp,
    pub body: a_Stmt,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_For_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Loop_ {
    pub cond: a_Exp,
    pub body: a_Stmt,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Code_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_If_ {
    pub cond: a_Exp,
    pub if_body: a_Stmt,
    pub else_body: a_Stmt,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_If_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Switch_ {
    pub val: a_Exp,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Switch_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Break_ {
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Break_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Continue_ {
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Continue_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Return_ {
    pub val: a_Exp,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Return_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_Case_ {
    pub exp: a_Exp,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_Case_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_GotoLabel_ {
    pub name: S_Symbol,
    pub linepos: c_int,
    pub self_: a_Stmt,
}
impl Default for a_Stmt_GotoLabel_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Stmt_Type {
    ae_stmt_exp = 0,
    ae_stmt_while = 1,
    ae_stmt_until = 2,
    ae_stmt_for = 3,
    ae_stmt_loop = 4,
    ae_stmt_if = 5,
    ae_stmt_code = 6,
    ae_stmt_switch = 7,
    ae_stmt_break = 8,
    ae_stmt_continue = 9,
    ae_stmt_return = 10,
    ae_stmt_case = 11,
    ae_stmt_gotolabel = 12,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct a_Stmt_ {
    pub s_type: ae_Stmt_Type,
    pub skip: c_int,
    pub __bindgen_anon_1: a_Stmt___bindgen_ty_1,
    pub linepos: c_int,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union a_Stmt___bindgen_ty_1 {
    pub stmt_exp: a_Exp,
    pub stmt_code: a_Stmt_Code_,
    pub stmt_while: a_Stmt_While_,
    pub stmt_until: a_Stmt_Until_,
    pub stmt_loop: a_Stmt_Loop_,
    pub stmt_for: a_Stmt_For_,
    pub stmt_if: a_Stmt_If_,
    pub stmt_switch: a_Stmt_Switch_,
    pub stmt_break: a_Stmt_Break_,
    pub stmt_continue: a_Stmt_Continue_,
    pub stmt_return: a_Stmt_Return_,
    pub stmt_case: a_Stmt_Case_,
    pub stmt_gotolabel: a_Stmt_GotoLabel_,
    _bindgen_union_align: [u64; 6usize],
}
impl Default for a_Stmt___bindgen_ty_1 {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Stmt___bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "a_Stmt___bindgen_ty_1 {{ union }}")
    }
}
impl Default for a_Stmt_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Stmt_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "a_Stmt_ {{ s_type: {:?}, skip: {:?}, __bindgen_anon_1: {:?}, linepos: {:?} }}",
            self.s_type, self.skip, self.__bindgen_anon_1, self.linepos
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Stmt_List_ {
    pub stmt: a_Stmt,
    pub next: a_Stmt_List,
    pub linepos: c_int,
}
impl Default for a_Stmt_List_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Class_Def_ {
    pub decl: ae_Keyword,
    pub name: a_Id_List,
    pub ext: a_Class_Ext,
    pub body: a_Class_Body,
    pub type_: t_CKTYPE,
    pub iface: c_int,
    pub home: t_CKNSPC,
    pub linepos: c_int,
}
impl Default for a_Class_Def_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Class_Ext_ {
    pub extend_id: a_Id_List,
    pub impl_list: a_Id_List,
    pub linepos: c_int,
}
impl Default for a_Class_Ext_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Class_Body_ {
    pub section: a_Section,
    pub next: a_Class_Body,
    pub linepos: c_int,
}
impl Default for a_Class_Body_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Id_List_ {
    pub xid: S_Symbol,
    pub next: a_Id_List,
    pub linepos: c_int,
}
impl Default for a_Id_List_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Func_Type {
    ae_func_user = 0,
    ae_func_builtin = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Func_Def_ {
    pub func_decl: ae_Keyword,
    pub static_decl: ae_Keyword,
    pub type_decl: a_Type_Decl,
    pub ret_type: t_CKTYPE,
    pub name: S_Symbol,
    pub arg_list: a_Arg_List,
    pub code: a_Stmt,
    pub ck_func: t_CKFUNC,
    pub global: c_uint,
    pub s_type: c_uint,
    pub stack_depth: c_uint,
    pub dl_func_ptr: *mut c_void,
    pub linepos: c_int,
}
impl Default for a_Func_Def_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ae_Section_Type {
    ae_section_stmt = 0,
    ae_section_func = 1,
    ae_section_class = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct a_Section_ {
    pub s_type: ae_Section_Type,
    pub __bindgen_anon_1: a_Section___bindgen_ty_1,
    pub linepos: c_int,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union a_Section___bindgen_ty_1 {
    pub stmt_list: a_Stmt_List,
    pub class_def: a_Class_Def,
    pub func_def: a_Func_Def,
    _bindgen_union_align: u64,
}
impl Default for a_Section___bindgen_ty_1 {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Section___bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "a_Section___bindgen_ty_1 {{ union }}")
    }
}
impl Default for a_Section_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for a_Section_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "a_Section_ {{ s_type: {:?}, __bindgen_anon_1: {:?}, linepos: {:?} }}",
            self.s_type, self.__bindgen_anon_1, self.linepos
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct a_Program_ {
    pub section: a_Section,
    pub next: a_Program,
    pub linepos: c_int,
}
impl Default for a_Program_ {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum yytokentype {
    ID = 258,
    STRING_LIT = 259,
    CHAR_LIT = 260,
    NUM = 261,
    FLOAT = 262,
    POUND = 263,
    COMMA = 264,
    COLON = 265,
    SEMICOLON = 266,
    LPAREN = 267,
    RPAREN = 268,
    LBRACK = 269,
    RBRACK = 270,
    LBRACE = 271,
    RBRACE = 272,
    DOT = 273,
    PLUS = 274,
    MINUS = 275,
    TIMES = 276,
    DIVIDE = 277,
    PERCENT = 278,
    EQ = 279,
    NEQ = 280,
    LT = 281,
    LE = 282,
    GT = 283,
    GE = 284,
    AND = 285,
    OR = 286,
    ASSIGN = 287,
    IF = 288,
    THEN = 289,
    ELSE = 290,
    WHILE = 291,
    FOR = 292,
    DO = 293,
    LOOP = 294,
    BREAK = 295,
    CONTINUE = 296,
    NULL_TOK = 297,
    FUNCTION = 298,
    RETURN = 299,
    QUESTION = 300,
    EXCLAMATION = 301,
    S_OR = 302,
    S_AND = 303,
    S_XOR = 304,
    PLUSPLUS = 305,
    MINUSMINUS = 306,
    DOLLAR = 307,
    POUNDPAREN = 308,
    PERCENTPAREN = 309,
    ATPAREN = 310,
    SIMULT = 311,
    PATTERN = 312,
    CODE = 313,
    TRANSPORT = 314,
    HOST = 315,
    TIME = 316,
    WHENEVER = 317,
    NEXT = 318,
    UNTIL = 319,
    EXTERNAL = 320,
    GLOBAL = 321,
    EVERY = 322,
    BEFORE = 323,
    AFTER = 324,
    AT = 325,
    AT_SYM = 326,
    ATAT_SYM = 327,
    NEW = 328,
    SIZEOF = 329,
    TYPEOF = 330,
    SAME = 331,
    PLUS_CHUCK = 332,
    MINUS_CHUCK = 333,
    TIMES_CHUCK = 334,
    DIVIDE_CHUCK = 335,
    S_AND_CHUCK = 336,
    S_OR_CHUCK = 337,
    S_XOR_CHUCK = 338,
    SHIFT_RIGHT_CHUCK = 339,
    SHIFT_LEFT_CHUCK = 340,
    PERCENT_CHUCK = 341,
    SHIFT_RIGHT = 342,
    SHIFT_LEFT = 343,
    TILDA = 344,
    CHUCK = 345,
    COLONCOLON = 346,
    S_CHUCK = 347,
    AT_CHUCK = 348,
    LEFT_S_CHUCK = 349,
    UNCHUCK = 350,
    UPCHUCK = 351,
    CLASS = 352,
    INTERFACE = 353,
    EXTENDS = 354,
    IMPLEMENTS = 355,
    PUBLIC = 356,
    PROTECTED = 357,
    PRIVATE = 358,
    STATIC = 359,
    ABSTRACT = 360,
    CONST = 361,
    SPORK = 362,
    ARROW_RIGHT = 363,
    ARROW_LEFT = 364,
    L_HACK = 365,
    R_HACK = 366,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union YYSTYPE {
    pub pos: c_int,
    pub ival: c_int,
    pub fval: f64,
    pub sval: c_str,
    pub program: a_Program,
    pub program_section: a_Section,
    pub stmt_list: a_Stmt_List,
    pub class_def: a_Class_Def,
    pub class_ext: a_Class_Ext,
    pub class_body: a_Class_Body,
    pub stmt: a_Stmt,
    pub exp: a_Exp,
    pub func_def: a_Func_Def,
    pub var_decl_list: a_Var_Decl_List,
    pub var_decl: a_Var_Decl,
    pub type_decl: a_Type_Decl,
    pub arg_list: a_Arg_List,
    pub id_list: a_Id_List,
    pub array_sub: a_Array_Sub,
    pub complex_exp: a_Complex,
    pub polar_exp: a_Polar,
    pub vec_exp: a_Vec,
    _bindgen_union_align: u64,
}
impl Default for YYSTYPE {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}
impl ::std::fmt::Debug for YYSTYPE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "YYSTYPE {{ union }}")
    }
}
extern "C" {
    pub static mut yylval: YYSTYPE;
}
extern "C" {
    pub fn yyparse() -> c_int;
}
